; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jquant1.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jquant1.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jquant1.c]
                          THUMB

                          AREA ||i.alloc_fs_workspace||, CODE, READONLY, ALIGN=1

                  alloc_fs_workspace PROC
;;;725    LOCAL(void)
;;;726    alloc_fs_workspace (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;727    {
000004  4604              MOV      r4,r0
;;;728      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  f8d471cc          LDR      r7,[r4,#0x1cc]
;;;729      size_t arraysize;
;;;730      int i;
;;;731    
;;;732      arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
00000a  6f20              LDR      r0,[r4,#0x70]
00000c  1c80              ADDS     r0,r0,#2
00000e  0046              LSLS     r6,r0,#1
;;;733      for (i = 0; i < cinfo->out_color_components; i++) {
000010  2500              MOVS     r5,#0
000012  e00a              B        |L1.42|
                  |L1.20|
;;;734        cquantize->fserrors[i] = (FSERRPTR)
000014  6860              LDR      r0,[r4,#4]
000016  4632              MOV      r2,r6
000018  2101              MOVS     r1,#1
00001a  6843              LDR      r3,[r0,#4]
00001c  4620              MOV      r0,r4
00001e  4798              BLX      r3
000020  f1070144          ADD      r1,r7,#0x44
000024  f8410025          STR      r0,[r1,r5,LSL #2]
000028  1c6d              ADDS     r5,r5,#1              ;733
                  |L1.42|
00002a  6fa0              LDR      r0,[r4,#0x78]         ;733
00002c  42a8              CMP      r0,r5                 ;733
00002e  dcf1              BGT      |L1.20|
;;;735          (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;736      }
;;;737    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;738    
                          ENDP


                          AREA ||i.color_quantize||, CODE, READONLY, ALIGN=1

                  color_quantize PROC
;;;462    METHODDEF(void)
;;;463    color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;464    		JSAMPARRAY output_buf, int num_rows)
;;;465    /* General case, no dithering */
;;;466    {
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;467      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8d091cc          LDR      r9,[r0,#0x1cc]
;;;468      JSAMPARRAY colorindex = cquantize->colorindex;
00000c  f8d9a018          LDR      r10,[r9,#0x18]
;;;469      register int pixcode, ci;
;;;470      register JSAMPROW ptrin, ptrout;
;;;471      int row;
;;;472      JDIMENSION col;
;;;473      JDIMENSION width = cinfo->output_width;
000010  f8d0b070          LDR      r11,[r0,#0x70]
000014  f8cdb004          STR      r11,[sp,#4]
;;;474      register int nc = cinfo->out_color_components;
000018  f8d0b078          LDR      r11,[r0,#0x78]
00001c  f8cdb000          STR      r11,[sp,#0]
;;;475    
;;;476      for (row = 0; row < num_rows; row++) {
000020  2100              MOVS     r1,#0
000022  e01a              B        |L2.90|
                  |L2.36|
;;;477        ptrin = input_buf[row];
000024  f854c021          LDR      r12,[r4,r1,LSL #2]
;;;478        ptrout = output_buf[row];
000028  f8558021          LDR      r8,[r5,r1,LSL #2]
;;;479        for (col = width; col > 0; col--) {
00002c  9f01              LDR      r7,[sp,#4]
00002e  e011              B        |L2.84|
                  |L2.48|
;;;480          pixcode = 0;
000030  2600              MOVS     r6,#0
;;;481          for (ci = 0; ci < nc; ci++) {
000032  2200              MOVS     r2,#0
000034  e007              B        |L2.70|
                  |L2.54|
;;;482    	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
000036  f81cbb01          LDRB     r11,[r12],#1
00003a  f85ae022          LDR      lr,[r10,r2,LSL #2]
00003e  f81eb00b          LDRB     r11,[lr,r11]
000042  445e              ADD      r6,r6,r11
000044  1c52              ADDS     r2,r2,#1              ;481
                  |L2.70|
000046  f8ddb000          LDR      r11,[sp,#0]           ;481
00004a  455a              CMP      r2,r11                ;481
00004c  dbf3              BLT      |L2.54|
;;;483          }
;;;484          *ptrout++ = (JSAMPLE) pixcode;
00004e  f8086b01          STRB     r6,[r8],#1
000052  1e7f              SUBS     r7,r7,#1              ;479
                  |L2.84|
000054  2f00              CMP      r7,#0                 ;479
000056  d1eb              BNE      |L2.48|
000058  1c49              ADDS     r1,r1,#1              ;476
                  |L2.90|
00005a  4299              CMP      r1,r3                 ;476
00005c  dbe2              BLT      |L2.36|
;;;485        }
;;;486      }
;;;487    }
00005e  e8bd8ffc          POP      {r2-r11,pc}
;;;488    
                          ENDP


                          AREA ||i.color_quantize3||, CODE, READONLY, ALIGN=1

                  color_quantize3 PROC
;;;490    METHODDEF(void)
;;;491    color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;492    		 JSAMPARRAY output_buf, int num_rows)
;;;493    /* Fast path for out_color_components==3, no dithering */
;;;494    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;495      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000c  f8d421cc          LDR      r2,[r4,#0x1cc]
;;;496      register int pixcode;
;;;497      register JSAMPROW ptrin, ptrout;
;;;498      JSAMPROW colorindex0 = cquantize->colorindex[0];
000010  f8d2b018          LDR      r11,[r2,#0x18]
000014  f8db9000          LDR      r9,[r11,#0]
;;;499      JSAMPROW colorindex1 = cquantize->colorindex[1];
000018  f8d2b018          LDR      r11,[r2,#0x18]
00001c  f8dba004          LDR      r10,[r11,#4]
;;;500      JSAMPROW colorindex2 = cquantize->colorindex[2];
000020  f8d2b018          LDR      r11,[r2,#0x18]
000024  f8dbb008          LDR      r11,[r11,#8]
000028  f8cdb004          STR      r11,[sp,#4]
;;;501      int row;
;;;502      JDIMENSION col;
;;;503      JDIMENSION width = cinfo->output_width;
00002c  f8d4b070          LDR      r11,[r4,#0x70]
000030  f8cdb000          STR      r11,[sp,#0]
;;;504    
;;;505      for (row = 0; row < num_rows; row++) {
000034  2100              MOVS     r1,#0
000036  e01e              B        |L3.118|
                  |L3.56|
;;;506        ptrin = input_buf[row];
000038  f8550021          LDR      r0,[r5,r1,LSL #2]
;;;507        ptrout = output_buf[row];
00003c  f856c021          LDR      r12,[r6,r1,LSL #2]
;;;508        for (col = width; col > 0; col--) {
000040  f8dd8000          LDR      r8,[sp,#0]
000044  e013              B        |L3.110|
                  |L3.70|
;;;509          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
000046  f810bb01          LDRB     r11,[r0],#1
00004a  f819300b          LDRB     r3,[r9,r11]
;;;510          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
00004e  f810bb01          LDRB     r11,[r0],#1
000052  f81ab00b          LDRB     r11,[r10,r11]
000056  445b              ADD      r3,r3,r11
;;;511          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
000058  f810bb01          LDRB     r11,[r0],#1
00005c  f8dde004          LDR      lr,[sp,#4]
000060  f81eb00b          LDRB     r11,[lr,r11]
000064  445b              ADD      r3,r3,r11
;;;512          *ptrout++ = (JSAMPLE) pixcode;
000066  f80c3b01          STRB     r3,[r12],#1
00006a  f1a80801          SUB      r8,r8,#1              ;508
                  |L3.110|
00006e  f1b80f00          CMP      r8,#0                 ;508
000072  d1e8              BNE      |L3.70|
000074  1c49              ADDS     r1,r1,#1              ;505
                  |L3.118|
000076  42b9              CMP      r1,r7                 ;505
000078  dbde              BLT      |L3.56|
;;;513        }
;;;514      }
;;;515    }
00007a  e8bd8ffc          POP      {r2-r11,pc}
;;;516    
                          ENDP


                          AREA ||i.create_colorindex||, CODE, READONLY, ALIGN=1

                  create_colorindex PROC
;;;336    LOCAL(void)
;;;337    create_colorindex (j_decompress_ptr cinfo)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;338    {
000004  4607              MOV      r7,r0
;;;339      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  f8d741cc          LDR      r4,[r7,#0x1cc]
;;;340      JSAMPROW indexptr;
;;;341      int i,j,k, nci, blksize, val, pad;
;;;342    
;;;343      /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
;;;344       * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
;;;345       * This is not necessary in the other dithering modes.  However, we
;;;346       * flag whether it was done in case user changes dithering mode.
;;;347       */
;;;348      if (cinfo->dither_mode == JDITHER_ORDERED) {
00000a  f8970058          LDRB     r0,[r7,#0x58]
00000e  2801              CMP      r0,#1
000010  d103              BNE      |L4.26|
;;;349        pad = MAXJSAMPLE*2;
000012  f44f79ff          MOV      r9,#0x1fe
;;;350        cquantize->is_padded = TRUE;
000016  61e0              STR      r0,[r4,#0x1c]
000018  e003              B        |L4.34|
                  |L4.26|
;;;351      } else {
;;;352        pad = 0;
00001a  f04f0900          MOV      r9,#0
;;;353        cquantize->is_padded = FALSE;
00001e  2000              MOVS     r0,#0
000020  61e0              STR      r0,[r4,#0x1c]
                  |L4.34|
;;;354      }
;;;355    
;;;356      cquantize->colorindex = (*cinfo->mem->alloc_sarray)
000022  f5097280          ADD      r2,r9,#0x100
000026  6fbb              LDR      r3,[r7,#0x78]
000028  6878              LDR      r0,[r7,#4]
00002a  2101              MOVS     r1,#1
00002c  f8d0c008          LDR      r12,[r0,#8]
000030  4638              MOV      r0,r7
000032  47e0              BLX      r12
000034  61a0              STR      r0,[r4,#0x18]
;;;357        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;358         (JDIMENSION) (MAXJSAMPLE+1 + pad),
;;;359         (JDIMENSION) cinfo->out_color_components);
;;;360    
;;;361      /* blksize is number of adjacent repeated entries for a component */
;;;362      blksize = cquantize->sv_actual;
000036  f8d4b014          LDR      r11,[r4,#0x14]
;;;363    
;;;364      for (i = 0; i < cinfo->out_color_components; i++) {
00003a  2500              MOVS     r5,#0
00003c  e049              B        |L4.210|
                  |L4.62|
;;;365        /* fill in colorindex entries for i'th color component */
;;;366        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00003e  f1040020          ADD      r0,r4,#0x20
000042  f850a025          LDR      r10,[r0,r5,LSL #2]
;;;367        blksize = blksize / nci;
000046  fb9bfbfa          SDIV     r11,r11,r10
;;;368    
;;;369        /* adjust colorindex pointers to provide padding at negative indexes. */
;;;370        if (pad)
00004a  f1b90f00          CMP      r9,#0
00004e  d006              BEQ      |L4.94|
;;;371          cquantize->colorindex[i] += MAXJSAMPLE;
000050  69a0              LDR      r0,[r4,#0x18]
000052  f8500025          LDR      r0,[r0,r5,LSL #2]
000056  30ff              ADDS     r0,r0,#0xff
000058  69a1              LDR      r1,[r4,#0x18]
00005a  f8410025          STR      r0,[r1,r5,LSL #2]
                  |L4.94|
;;;372    
;;;373        /* in loop, val = index of current output value, */
;;;374        /* and k = largest j that maps to current val */
;;;375        indexptr = cquantize->colorindex[i];
00005e  69a0              LDR      r0,[r4,#0x18]
000060  f8508025          LDR      r8,[r0,r5,LSL #2]
;;;376        val = 0;
000064  2000              MOVS     r0,#0
000066  9000              STR      r0,[sp,#0]
;;;377        k = largest_input_value(cinfo, i, 0, nci-1);
000068  f1aa0301          SUB      r3,r10,#1
00006c  2200              MOVS     r2,#0
00006e  4629              MOV      r1,r5
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       largest_input_value
000076  9001              STR      r0,[sp,#4]
;;;378        for (j = 0; j <= MAXJSAMPLE; j++) {
000078  2600              MOVS     r6,#0
00007a  e014              B        |L4.166|
                  |L4.124|
;;;379          while (j > k)		/* advance val if past boundary */
00007c  e00a              B        |L4.148|
                  |L4.126|
;;;380    	k = largest_input_value(cinfo, i, ++val, nci-1);
00007e  f1aa0301          SUB      r3,r10,#1
000082  9800              LDR      r0,[sp,#0]
000084  1c40              ADDS     r0,r0,#1
000086  4602              MOV      r2,r0
000088  4629              MOV      r1,r5
00008a  9000              STR      r0,[sp,#0]
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       largest_input_value
000092  9001              STR      r0,[sp,#4]
                  |L4.148|
000094  9801              LDR      r0,[sp,#4]            ;379
000096  4286              CMP      r6,r0                 ;379
000098  dcf1              BGT      |L4.126|
;;;381          /* premultiply so that no multiplication needed in main processing */
;;;382          indexptr[j] = (JSAMPLE) (val * blksize);
00009a  9800              LDR      r0,[sp,#0]
00009c  fb00f00b          MUL      r0,r0,r11
0000a0  f8080006          STRB     r0,[r8,r6]
0000a4  1c76              ADDS     r6,r6,#1              ;378
                  |L4.166|
0000a6  2eff              CMP      r6,#0xff              ;378
0000a8  dde8              BLE      |L4.124|
;;;383        }
;;;384        /* Pad at both ends if necessary */
;;;385        if (pad)
0000aa  f1b90f00          CMP      r9,#0
0000ae  d00f              BEQ      |L4.208|
;;;386          for (j = 1; j <= MAXJSAMPLE; j++) {
0000b0  2601              MOVS     r6,#1
0000b2  e00b              B        |L4.204|
                  |L4.180|
;;;387    	indexptr[-j] = indexptr[0];
0000b4  f8980000          LDRB     r0,[r8,#0]
0000b8  4271              RSBS     r1,r6,#0
0000ba  f8080001          STRB     r0,[r8,r1]
;;;388    	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
0000be  f89810ff          LDRB     r1,[r8,#0xff]
0000c2  f10600ff          ADD      r0,r6,#0xff
0000c6  f8081000          STRB     r1,[r8,r0]
0000ca  1c76              ADDS     r6,r6,#1              ;386
                  |L4.204|
0000cc  2eff              CMP      r6,#0xff              ;386
0000ce  ddf1              BLE      |L4.180|
                  |L4.208|
0000d0  1c6d              ADDS     r5,r5,#1              ;364
                  |L4.210|
0000d2  6fb8              LDR      r0,[r7,#0x78]         ;364
0000d4  42a8              CMP      r0,r5                 ;364
0000d6  dcb2              BGT      |L4.62|
;;;389          }
;;;390      }
;;;391    }
0000d8  e8bd9ffc          POP      {r2-r12,pc}
;;;392    
                          ENDP


                          AREA ||i.create_colormap||, CODE, READONLY, ALIGN=1

                  create_colormap PROC
;;;276    LOCAL(void)
;;;277    create_colormap (j_decompress_ptr cinfo)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;278    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
;;;279      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;280      JSAMPARRAY colormap;		/* Created colormap */
;;;281      int total_colors;		/* Number of distinct output colors */
;;;282      int i,j,k, nci, blksize, blkdist, ptr, val;
;;;283    
;;;284      /* Select number of colors for each component */
;;;285      total_colors = select_ncolors(cinfo, cquantize->Ncolors);
00000c  f1050120          ADD      r1,r5,#0x20
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       select_ncolors
000016  4606              MOV      r6,r0
;;;286    
;;;287      /* Report selected color counts */
;;;288      if (cinfo->out_color_components == 3)
000018  6fa0              LDR      r0,[r4,#0x78]
00001a  2803              CMP      r0,#3
00001c  d117              BNE      |L5.78|
;;;289        TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
00001e  bf00              NOP      
000020  6820              LDR      r0,[r4,#0]
000022  f1000b18          ADD      r11,r0,#0x18
000026  f8cb6000          STR      r6,[r11,#0]
00002a  6a28              LDR      r0,[r5,#0x20]
00002c  f8cb0004          STR      r0,[r11,#4]
000030  6a68              LDR      r0,[r5,#0x24]
000032  f8cb0008          STR      r0,[r11,#8]
000036  6aa8              LDR      r0,[r5,#0x28]
000038  f8cb000c          STR      r0,[r11,#0xc]
00003c  205e              MOVS     r0,#0x5e
00003e  6821              LDR      r1,[r4,#0]
000040  6148              STR      r0,[r1,#0x14]
000042  6820              LDR      r0,[r4,#0]
000044  2101              MOVS     r1,#1
000046  6842              LDR      r2,[r0,#4]
000048  4620              MOV      r0,r4
00004a  4790              BLX      r2
00004c  e009              B        |L5.98|
                  |L5.78|
;;;290    	     total_colors, cquantize->Ncolors[0],
;;;291    	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
;;;292      else
;;;293        TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
00004e  205f              MOVS     r0,#0x5f
000050  6821              LDR      r1,[r4,#0]
000052  6148              STR      r0,[r1,#0x14]
000054  6820              LDR      r0,[r4,#0]
000056  6186              STR      r6,[r0,#0x18]
000058  6820              LDR      r0,[r4,#0]
00005a  2101              MOVS     r1,#1
00005c  6842              LDR      r2,[r0,#4]
00005e  4620              MOV      r0,r4
000060  4790              BLX      r2
                  |L5.98|
;;;294    
;;;295      /* Allocate and fill in the colormap. */
;;;296      /* The colors are ordered in the map in standard row-major order, */
;;;297      /* i.e. rightmost (highest-indexed) color changes most rapidly. */
;;;298    
;;;299      colormap = (*cinfo->mem->alloc_sarray)
000062  6fa3              LDR      r3,[r4,#0x78]
000064  6860              LDR      r0,[r4,#4]
000066  4632              MOV      r2,r6
000068  2101              MOVS     r1,#1
00006a  f8d0c008          LDR      r12,[r0,#8]
00006e  4620              MOV      r0,r4
000070  47e0              BLX      r12
000072  4680              MOV      r8,r0
;;;300        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;301         (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
;;;302    
;;;303      /* blksize is number of adjacent repeated entries for a component */
;;;304      /* blkdist is distance between groups of identical entries for a component */
;;;305      blkdist = total_colors;
000074  9602              STR      r6,[sp,#8]
;;;306    
;;;307      for (i = 0; i < cinfo->out_color_components; i++) {
000076  2700              MOVS     r7,#0
000078  e037              B        |L5.234|
                  |L5.122|
;;;308        /* fill in colormap entries for i'th color component */
;;;309        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00007a  f1050020          ADD      r0,r5,#0x20
00007e  f850a027          LDR      r10,[r0,r7,LSL #2]
;;;310        blksize = blkdist / nci;
000082  9802              LDR      r0,[sp,#8]
000084  fb90f0fa          SDIV     r0,r0,r10
000088  9003              STR      r0,[sp,#0xc]
;;;311        for (j = 0; j < nci; j++) {
00008a  f04f0900          MOV      r9,#0
00008e  e027              B        |L5.224|
                  |L5.144|
;;;312          /* Compute j'th output value (out of nci) for component */
;;;313          val = output_value(cinfo, i, j, nci-1);
000090  f1aa0301          SUB      r3,r10,#1
000094  464a              MOV      r2,r9
000096  4639              MOV      r1,r7
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       output_value
00009e  9000              STR      r0,[sp,#0]
;;;314          /* Fill in all colormap entries that have this value of this component */
;;;315          for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
0000a0  9803              LDR      r0,[sp,#0xc]
0000a2  fb09f000          MUL      r0,r9,r0
0000a6  9001              STR      r0,[sp,#4]
0000a8  e015              B        |L5.214|
                  |L5.170|
;;;316    	/* fill in blksize entries beginning at ptr */
;;;317    	for (k = 0; k < blksize; k++)
0000aa  2000              MOVS     r0,#0
0000ac  9004              STR      r0,[sp,#0x10]
0000ae  e00a              B        |L5.198|
                  |L5.176|
;;;318    	  colormap[i][ptr+k] = (JSAMPLE) val;
0000b0  9800              LDR      r0,[sp,#0]
0000b2  b2c2              UXTB     r2,r0
0000b4  f8583027          LDR      r3,[r8,r7,LSL #2]
0000b8  9904              LDR      r1,[sp,#0x10]
0000ba  9801              LDR      r0,[sp,#4]
0000bc  4408              ADD      r0,r0,r1
0000be  541a              STRB     r2,[r3,r0]
0000c0  9804              LDR      r0,[sp,#0x10]         ;317
0000c2  1c40              ADDS     r0,r0,#1              ;317
0000c4  9004              STR      r0,[sp,#0x10]         ;317
                  |L5.198|
0000c6  e9dd1003          LDRD     r1,r0,[sp,#0xc]       ;317
0000ca  4288              CMP      r0,r1                 ;317
0000cc  dbf0              BLT      |L5.176|
0000ce  e9dd0101          LDRD     r0,r1,[sp,#4]         ;315
0000d2  4408              ADD      r0,r0,r1              ;315
0000d4  9001              STR      r0,[sp,#4]            ;315
                  |L5.214|
0000d6  9801              LDR      r0,[sp,#4]            ;315
0000d8  42b0              CMP      r0,r6                 ;315
0000da  dbe6              BLT      |L5.170|
0000dc  f1090901          ADD      r9,r9,#1              ;311
                  |L5.224|
0000e0  45d1              CMP      r9,r10                ;311
0000e2  dbd5              BLT      |L5.144|
;;;319          }
;;;320        }
;;;321        blkdist = blksize;		/* blksize of this color is blkdist of next */
0000e4  9803              LDR      r0,[sp,#0xc]
0000e6  9002              STR      r0,[sp,#8]
0000e8  1c7f              ADDS     r7,r7,#1              ;307
                  |L5.234|
0000ea  6fa0              LDR      r0,[r4,#0x78]         ;307
0000ec  42b8              CMP      r0,r7                 ;307
0000ee  dcc4              BGT      |L5.122|
;;;322      }
;;;323    
;;;324      /* Save the colormap in private storage,
;;;325       * where it will survive color quantization mode changes.
;;;326       */
;;;327      cquantize->sv_colormap = colormap;
0000f0  f8c58010          STR      r8,[r5,#0x10]
;;;328      cquantize->sv_actual = total_colors;
0000f4  616e              STR      r6,[r5,#0x14]
;;;329    }
0000f6  b005              ADD      sp,sp,#0x14
0000f8  e8bd8ff0          POP      {r4-r11,pc}
;;;330    
                          ENDP


                          AREA ||i.create_odither_tables||, CODE, READONLY, ALIGN=1

                  create_odither_tables PROC
;;;435    LOCAL(void)
;;;436    create_odither_tables (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;437    {
000004  4607              MOV      r7,r0
;;;438      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  f8d751cc          LDR      r5,[r7,#0x1cc]
;;;439      ODITHER_MATRIX_PTR odither;
;;;440      int i, j, nci;
;;;441    
;;;442      for (i = 0; i < cinfo->out_color_components; i++) {
00000a  2400              MOVS     r4,#0
00000c  e023              B        |L6.86|
                  |L6.14|
;;;443        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00000e  f1050020          ADD      r0,r5,#0x20
000012  f8508024          LDR      r8,[r0,r4,LSL #2]
;;;444        odither = NULL;		/* search for matching prior component */
000016  f04f0900          MOV      r9,#0
;;;445        for (j = 0; j < i; j++) {
00001a  2600              MOVS     r6,#0
00001c  e00b              B        |L6.54|
                  |L6.30|
;;;446          if (nci == cquantize->Ncolors[j]) {
00001e  f1050020          ADD      r0,r5,#0x20
000022  f8500026          LDR      r0,[r0,r6,LSL #2]
000026  4540              CMP      r0,r8
000028  d104              BNE      |L6.52|
;;;447    	odither = cquantize->odither[j];
00002a  f1050034          ADD      r0,r5,#0x34
00002e  f8509026          LDR      r9,[r0,r6,LSL #2]
;;;448    	break;
000032  e002              B        |L6.58|
                  |L6.52|
000034  1c76              ADDS     r6,r6,#1              ;445
                  |L6.54|
000036  42a6              CMP      r6,r4                 ;445
000038  dbf1              BLT      |L6.30|
                  |L6.58|
00003a  bf00              NOP      
;;;449          }
;;;450        }
;;;451        if (odither == NULL)	/* need a new table? */
00003c  f1b90f00          CMP      r9,#0
000040  d104              BNE      |L6.76|
;;;452          odither = make_odither_array(cinfo, nci);
000042  4641              MOV      r1,r8
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       make_odither_array
00004a  4681              MOV      r9,r0
                  |L6.76|
;;;453        cquantize->odither[i] = odither;
00004c  f1050034          ADD      r0,r5,#0x34
000050  f8409024          STR      r9,[r0,r4,LSL #2]
000054  1c64              ADDS     r4,r4,#1              ;442
                  |L6.86|
000056  6fb8              LDR      r0,[r7,#0x78]         ;442
000058  42a0              CMP      r0,r4                 ;442
00005a  dcd8              BGT      |L6.14|
;;;454      }
;;;455    }
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;456    
                          ENDP


                          AREA ||i.finish_pass_1_quant||, CODE, READONLY, ALIGN=1

                  finish_pass_1_quant PROC
;;;802    METHODDEF(void)
;;;803    finish_pass_1_quant (j_decompress_ptr cinfo)
000000  bf00              NOP      
;;;804    {
;;;805      GUI_USE_PARA(cinfo);
;;;806      /* no work in 1-pass case */
;;;807    }
000002  4770              BX       lr
;;;808    
                          ENDP


                          AREA ||i.jinit_1pass_quantizer||, CODE, READONLY, ALIGN=2

                  jinit_1pass_quantizer PROC
;;;826    GLOBAL(void)
;;;827    jinit_1pass_quantizer (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;828    {
000002  4604              MOV      r4,r0
;;;829      my_cquantize_ptr cquantize;
;;;830    
;;;831      cquantize = (my_cquantize_ptr)
000004  6860              LDR      r0,[r4,#4]
000006  2258              MOVS     r2,#0x58
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
000010  4605              MOV      r5,r0
;;;832        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;833    				SIZEOF(my_cquantizer));
;;;834      cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
000012  f8c451cc          STR      r5,[r4,#0x1cc]
;;;835      cquantize->pub.start_pass = start_pass_1_quant;
000016  4819              LDR      r0,|L8.124|
000018  6028              STR      r0,[r5,#0]
;;;836      cquantize->pub.finish_pass = finish_pass_1_quant;
00001a  4819              LDR      r0,|L8.128|
00001c  60a8              STR      r0,[r5,#8]
;;;837      cquantize->pub.new_color_map = new_color_map_1_quant;
00001e  4819              LDR      r0,|L8.132|
000020  60e8              STR      r0,[r5,#0xc]
;;;838      cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
000022  2000              MOVS     r0,#0
000024  6468              STR      r0,[r5,#0x44]
;;;839      cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
000026  6368              STR      r0,[r5,#0x34]
;;;840    
;;;841      /* Make sure my internal arrays won't overflow */
;;;842      if (cinfo->out_color_components > MAX_Q_COMPS)
000028  6fa0              LDR      r0,[r4,#0x78]
00002a  2804              CMP      r0,#4
00002c  dd09              BLE      |L8.66|
;;;843        ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
00002e  2037              MOVS     r0,#0x37
000030  6821              LDR      r1,[r4,#0]
000032  6148              STR      r0,[r1,#0x14]
000034  2004              MOVS     r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6188              STR      r0,[r1,#0x18]
00003a  6820              LDR      r0,[r4,#0]
00003c  6801              LDR      r1,[r0,#0]
00003e  4620              MOV      r0,r4
000040  4788              BLX      r1
                  |L8.66|
;;;844      /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;845      if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
000042  6e20              LDR      r0,[r4,#0x60]
000044  f5b07f80          CMP      r0,#0x100
000048  dd0a              BLE      |L8.96|
;;;846        ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
00004a  2039              MOVS     r0,#0x39
00004c  6821              LDR      r1,[r4,#0]
00004e  6148              STR      r0,[r1,#0x14]
000050  f44f7080          MOV      r0,#0x100
000054  6821              LDR      r1,[r4,#0]
000056  6188              STR      r0,[r1,#0x18]
000058  6820              LDR      r0,[r4,#0]
00005a  6801              LDR      r1,[r0,#0]
00005c  4620              MOV      r0,r4
00005e  4788              BLX      r1
                  |L8.96|
;;;847    
;;;848      /* Create the colormap and color index table. */
;;;849      create_colormap(cinfo);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       create_colormap
;;;850      create_colorindex(cinfo);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       create_colorindex
;;;851    
;;;852      /* Allocate Floyd-Steinberg workspace now if requested.
;;;853       * We do this now since it is FAR storage and may affect the memory
;;;854       * manager's space calculations.  If the user changes to FS dither
;;;855       * mode in a later pass, we will allocate the space then, and will
;;;856       * possibly overrun the max_memory_to_use setting.
;;;857       */
;;;858      if (cinfo->dither_mode == JDITHER_FS)
00006c  f8940058          LDRB     r0,[r4,#0x58]
000070  2802              CMP      r0,#2
000072  d102              BNE      |L8.122|
;;;859        alloc_fs_workspace(cinfo);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       alloc_fs_workspace
                  |L8.122|
;;;860    }
00007a  bd70              POP      {r4-r6,pc}
;;;861    
                          ENDP

                  |L8.124|
                          DCD      start_pass_1_quant
                  |L8.128|
                          DCD      finish_pass_1_quant
                  |L8.132|
                          DCD      new_color_map_1_quant

                          AREA ||i.largest_input_value||, CODE, READONLY, ALIGN=1

                  largest_input_value PROC
;;;260    LOCAL(int)
;;;261    largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
000000  b530              PUSH     {r4,r5,lr}
;;;262    /* Return largest input value that should map to j'th output value */
;;;263    /* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
;;;264    {
000002  4604              MOV      r4,r0
;;;265      GUI_USE_PARA(cinfo);
000004  bf00              NOP      
;;;266      GUI_USE_PARA(ci);
000006  bf00              NOP      
;;;267      /* Breakpoints are halfway between values returned by output_value */
;;;268      return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
000008  0050              LSLS     r0,r2,#1
00000a  1c40              ADDS     r0,r0,#1
00000c  ebc02000          RSB      r0,r0,r0,LSL #8
000010  4418              ADD      r0,r0,r3
000012  005d              LSLS     r5,r3,#1
000014  fb90f0f5          SDIV     r0,r0,r5
;;;269    }
000018  bd30              POP      {r4,r5,pc}
;;;270    
                          ENDP


                          AREA ||i.make_odither_array||, CODE, READONLY, ALIGN=2

                  make_odither_array PROC
;;;399    LOCAL(ODITHER_MATRIX_PTR)
;;;400    make_odither_array (j_decompress_ptr cinfo, int ncolors)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;401    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;402      ODITHER_MATRIX_PTR odither;
;;;403      int j,k;
;;;404      INT32 num,den;
;;;405    
;;;406      odither = (ODITHER_MATRIX_PTR)
000008  6878              LDR      r0,[r7,#4]
00000a  f44f6280          MOV      r2,#0x400
00000e  2101              MOVS     r1,#1
000010  6803              LDR      r3,[r0,#0]
000012  4638              MOV      r0,r7
000014  4798              BLX      r3
000016  4681              MOV      r9,r0
;;;407        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;408    				SIZEOF(ODITHER_MATRIX));
;;;409      /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
;;;410       * Hence the dither value for the matrix cell with fill order f
;;;411       * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
;;;412       * On 16-bit-int machine, be careful to avoid overflow.
;;;413       */
;;;414      den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
000018  f1a80001          SUB      r0,r8,#1
00001c  ea4f2a40          LSL      r10,r0,#9
;;;415      for (j = 0; j < ODITHER_SIZE; j++) {
000020  2400              MOVS     r4,#0
000022  e01b              B        |L10.92|
                  |L10.36|
;;;416        for (k = 0; k < ODITHER_SIZE; k++) {
000024  2500              MOVS     r5,#0
000026  e016              B        |L10.86|
                  |L10.40|
;;;417          num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
000028  480f              LDR      r0,|L10.104|
00002a  eb001004          ADD      r0,r0,r4,LSL #4
00002e  5d40              LDRB     r0,[r0,r5]
000030  0040              LSLS     r0,r0,#1
000032  f1c000ff          RSB      r0,r0,#0xff
000036  ebc02600          RSB      r6,r0,r0,LSL #8
;;;418    	    * MAXJSAMPLE;
;;;419          /* Ensure round towards zero despite C's lack of consistency
;;;420           * about rounding negative values in integer division...
;;;421           */
;;;422          odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
00003a  2e00              CMP      r6,#0
00003c  da04              BGE      |L10.72|
00003e  4270              RSBS     r0,r6,#0
000040  fb90f0fa          SDIV     r0,r0,r10
000044  4240              RSBS     r0,r0,#0
000046  e001              B        |L10.76|
                  |L10.72|
000048  fb96f0fa          SDIV     r0,r6,r10
                  |L10.76|
00004c  eb091184          ADD      r1,r9,r4,LSL #6
000050  f8410025          STR      r0,[r1,r5,LSL #2]
000054  1c6d              ADDS     r5,r5,#1              ;416
                  |L10.86|
000056  2d10              CMP      r5,#0x10              ;416
000058  dbe6              BLT      |L10.40|
00005a  1c64              ADDS     r4,r4,#1              ;415
                  |L10.92|
00005c  2c10              CMP      r4,#0x10              ;415
00005e  dbe1              BLT      |L10.36|
;;;423        }
;;;424      }
;;;425      return odither;
000060  4648              MOV      r0,r9
;;;426    }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;427    
                          ENDP

000066  0000              DCW      0x0000
                  |L10.104|
                          DCD      base_dither_matrix

                          AREA ||i.new_color_map_1_quant||, CODE, READONLY, ALIGN=1

                  new_color_map_1_quant PROC
;;;815    METHODDEF(void)
;;;816    new_color_map_1_quant (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;817    {
000002  4604              MOV      r4,r0
;;;818      ERREXIT(cinfo, JERR_MODE_CHANGE);
000004  202e              MOVS     r0,#0x2e
000006  6821              LDR      r1,[r4,#0]
000008  6148              STR      r0,[r1,#0x14]
00000a  6820              LDR      r0,[r4,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  4620              MOV      r0,r4
000010  4788              BLX      r1
;;;819    }
000012  bd10              POP      {r4,pc}
;;;820    
                          ENDP


                          AREA ||i.output_value||, CODE, READONLY, ALIGN=1

                  output_value PROC
;;;244    LOCAL(int)
;;;245    output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
000000  b570              PUSH     {r4-r6,lr}
;;;246    /* Return j'th output value, where j will range from 0 to maxj */
;;;247    /* The output values must fall in 0..MAXJSAMPLE in increasing order */
;;;248    {
000002  4604              MOV      r4,r0
;;;249      /* We always provide values 0 and MAXJSAMPLE for each component;
;;;250       * any additional values are equally spaced between these limits.
;;;251       * (Forcing the upper and lower values to the limits ensures that
;;;252       * dithering can't produce a color outside the selected gamut.)
;;;253       */
;;;254      GUI_USE_PARA(cinfo);
000004  bf00              NOP      
;;;255      GUI_USE_PARA(ci);
000006  bf00              NOP      
;;;256      return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
000008  461d              MOV      r5,r3
00000a  eb0370d5          ADD      r0,r3,r5,LSR #31
00000e  ebc22602          RSB      r6,r2,r2,LSL #8
000012  eb060060          ADD      r0,r6,r0,ASR #1
000016  fb90f0f3          SDIV     r0,r0,r3
;;;257    }
00001a  bd70              POP      {r4-r6,pc}
;;;258    
                          ENDP


                          AREA ||i.quantize3_ord_dither||, CODE, READONLY, ALIGN=1

                  quantize3_ord_dither PROC
;;;568    METHODDEF(void)
;;;569    quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;570    		      JSAMPARRAY output_buf, int num_rows)
;;;571    /* Fast path for out_color_components==3, with ordered dithering */
;;;572    {
000004  b084              SUB      sp,sp,#0x10
000006  4605              MOV      r5,r0
;;;573      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8d501cc          LDR      r0,[r5,#0x1cc]
;;;574      register int pixcode;
;;;575      register JSAMPROW input_ptr;
;;;576      register JSAMPROW output_ptr;
;;;577      JSAMPROW colorindex0 = cquantize->colorindex[0];
00000c  f8d0b018          LDR      r11,[r0,#0x18]
000010  f8dbb000          LDR      r11,[r11,#0]
000014  f8cdb00c          STR      r11,[sp,#0xc]
;;;578      JSAMPROW colorindex1 = cquantize->colorindex[1];
000018  f8d0b018          LDR      r11,[r0,#0x18]
00001c  f8dbb004          LDR      r11,[r11,#4]
000020  f8cdb008          STR      r11,[sp,#8]
;;;579      JSAMPROW colorindex2 = cquantize->colorindex[2];
000024  f8d0b018          LDR      r11,[r0,#0x18]
000028  f8dbb008          LDR      r11,[r11,#8]
00002c  f8cdb004          STR      r11,[sp,#4]
;;;580      int * dither0;		/* points to active row of dither matrix */
;;;581      int * dither1;
;;;582      int * dither2;
;;;583      int row_index, col_index;	/* current indexes into dither matrix */
;;;584      int row;
;;;585      JDIMENSION col;
;;;586      JDIMENSION width = cinfo->output_width;
000030  f8d5b070          LDR      r11,[r5,#0x70]
000034  f8cdb000          STR      r11,[sp,#0]
;;;587    
;;;588      for (row = 0; row < num_rows; row++) {
000038  2400              MOVS     r4,#0
00003a  e046              B        |L13.202|
                  |L13.60|
;;;589        row_index = cquantize->row_index;
00003c  6b02              LDR      r2,[r0,#0x30]
;;;590        input_ptr = input_buf[row];
00003e  f8ddb014          LDR      r11,[sp,#0x14]
000042  f85b1024          LDR      r1,[r11,r4,LSL #2]
;;;591        output_ptr = output_buf[row];
000046  f8ddb018          LDR      r11,[sp,#0x18]
00004a  f85b7024          LDR      r7,[r11,r4,LSL #2]
;;;592        dither0 = cquantize->odither[0][row_index];
00004e  f8d0b034          LDR      r11,[r0,#0x34]
000052  eb0b1c82          ADD      r12,r11,r2,LSL #6
;;;593        dither1 = cquantize->odither[1][row_index];
000056  f8d0b038          LDR      r11,[r0,#0x38]
00005a  eb0b1882          ADD      r8,r11,r2,LSL #6
;;;594        dither2 = cquantize->odither[2][row_index];
00005e  f8d0b03c          LDR      r11,[r0,#0x3c]
000062  eb0b1982          ADD      r9,r11,r2,LSL #6
;;;595        col_index = 0;
000066  2300              MOVS     r3,#0
;;;596    
;;;597        for (col = width; col > 0; col--) {
000068  f8dda000          LDR      r10,[sp,#0]
00006c  e024              B        |L13.184|
                  |L13.110|
;;;598          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
00006e  f811bb01          LDRB     r11,[r1],#1
000072  f85ce023          LDR      lr,[r12,r3,LSL #2]
000076  44de              ADD      lr,lr,r11
000078  f8ddb00c          LDR      r11,[sp,#0xc]
00007c  f81b600e          LDRB     r6,[r11,lr]
;;;599    					dither0[col_index]]);
;;;600          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
000080  f811bb01          LDRB     r11,[r1],#1
000084  f858e023          LDR      lr,[r8,r3,LSL #2]
000088  44de              ADD      lr,lr,r11
00008a  f8ddb008          LDR      r11,[sp,#8]
00008e  f81bb00e          LDRB     r11,[r11,lr]
000092  445e              ADD      r6,r6,r11
;;;601    					dither1[col_index]]);
;;;602          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
000094  f811bb01          LDRB     r11,[r1],#1
000098  f859e023          LDR      lr,[r9,r3,LSL #2]
00009c  44de              ADD      lr,lr,r11
00009e  f8ddb004          LDR      r11,[sp,#4]
0000a2  f81bb00e          LDRB     r11,[r11,lr]
0000a6  445e              ADD      r6,r6,r11
;;;603    					dither2[col_index]]);
;;;604          *output_ptr++ = (JSAMPLE) pixcode;
0000a8  f8076b01          STRB     r6,[r7],#1
;;;605          col_index = (col_index + 1) & ODITHER_MASK;
0000ac  f1030b01          ADD      r11,r3,#1
0000b0  f00b030f          AND      r3,r11,#0xf
0000b4  f1aa0a01          SUB      r10,r10,#1            ;597
                  |L13.184|
0000b8  f1ba0f00          CMP      r10,#0                ;597
0000bc  d1d7              BNE      |L13.110|
;;;606        }
;;;607        row_index = (row_index + 1) & ODITHER_MASK;
0000be  f1020b01          ADD      r11,r2,#1
0000c2  f00b020f          AND      r2,r11,#0xf
;;;608        cquantize->row_index = row_index;
0000c6  6302              STR      r2,[r0,#0x30]
0000c8  1c64              ADDS     r4,r4,#1              ;588
                  |L13.202|
0000ca  f8ddb01c          LDR      r11,[sp,#0x1c]        ;588
0000ce  455c              CMP      r4,r11                ;588
0000d0  dbb4              BLT      |L13.60|
;;;609      }
;;;610    }
0000d2  b008              ADD      sp,sp,#0x20
0000d4  e8bd8ff0          POP      {r4-r11,pc}
;;;611    
                          ENDP


                          AREA ||i.quantize_fs_dither||, CODE, READONLY, ALIGN=1

                  quantize_fs_dither PROC
;;;613    METHODDEF(void)
;;;614    quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;615    		    JSAMPARRAY output_buf, int num_rows)
;;;616    /* General case, with Floyd-Steinberg dithering */
;;;617    {
000004  b08d              SUB      sp,sp,#0x34
000006  4680              MOV      r8,r0
;;;618      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8d851cc          LDR      r5,[r8,#0x1cc]
;;;619      register LOCFSERROR cur;	/* current error or pixel value */
;;;620      LOCFSERROR belowerr;		/* error for pixel below cur */
;;;621      LOCFSERROR bpreverr;		/* error for below/prev col */
;;;622      LOCFSERROR bnexterr;		/* error for below/next col */
;;;623      LOCFSERROR delta;
;;;624      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;625      register JSAMPROW input_ptr;
;;;626      register JSAMPROW output_ptr;
;;;627      JSAMPROW colorindex_ci;
;;;628      JSAMPROW colormap_ci;
;;;629      int pixcode;
;;;630      int nc = cinfo->out_color_components;
00000c  f8d80078          LDR      r0,[r8,#0x78]
000010  9004              STR      r0,[sp,#0x10]
;;;631      int dir;			/* 1 for left-to-right, -1 for right-to-left */
;;;632      int dirnc;			/* dir * nc */
;;;633      int ci;
;;;634      int row;
;;;635      JDIMENSION col;
;;;636      JDIMENSION width = cinfo->output_width;
000012  f8d87070          LDR      r7,[r8,#0x70]
;;;637      JSAMPLE *range_limit = cinfo->sample_range_limit;
000016  f8d80144          LDR      r0,[r8,#0x144]
00001a  9000              STR      r0,[sp,#0]
;;;638      SHIFT_TEMPS
;;;639    
;;;640      for (row = 0; row < num_rows; row++) {
00001c  f04f0a00          MOV      r10,#0
000020  e08e              B        |L14.320|
                  |L14.34|
;;;641        /* Initialize output values to 0 so can process components separately */
;;;642        jzero_far((void FAR *) output_buf[row],
000022  4639              MOV      r1,r7
000024  9a0f              LDR      r2,[sp,#0x3c]
000026  f852002a          LDR      r0,[r2,r10,LSL #2]
00002a  f7fffffe          BL       jzero_far
;;;643    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;644        for (ci = 0; ci < nc; ci++) {
00002e  2600              MOVS     r6,#0
000030  e07b              B        |L14.298|
                  |L14.50|
;;;645          input_ptr = input_buf[row] + ci;
000032  980e              LDR      r0,[sp,#0x38]
000034  f850002a          LDR      r0,[r0,r10,LSL #2]
000038  4430              ADD      r0,r0,r6
00003a  9009              STR      r0,[sp,#0x24]
;;;646          output_ptr = output_buf[row];
00003c  980f              LDR      r0,[sp,#0x3c]
00003e  f850002a          LDR      r0,[r0,r10,LSL #2]
000042  9008              STR      r0,[sp,#0x20]
;;;647          if (cquantize->on_odd_row) {
000044  6d68              LDR      r0,[r5,#0x54]
000046  b1b8              CBZ      r0,|L14.120|
;;;648    	/* work right to left in this row */
;;;649    	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
000048  1e79              SUBS     r1,r7,#1
00004a  9a04              LDR      r2,[sp,#0x10]
00004c  9809              LDR      r0,[sp,#0x24]
00004e  fb010002          MLA      r0,r1,r2,r0
000052  9009              STR      r0,[sp,#0x24]
;;;650    	output_ptr += width-1;
000054  9808              LDR      r0,[sp,#0x20]
000056  4408              ADD      r0,r0,r1
000058  9008              STR      r0,[sp,#0x20]
;;;651    	dir = -1;
00005a  f04f30ff          MOV      r0,#0xffffffff
00005e  9003              STR      r0,[sp,#0xc]
;;;652    	dirnc = -nc;
000060  9804              LDR      r0,[sp,#0x10]
000062  4240              RSBS     r0,r0,#0
000064  9002              STR      r0,[sp,#8]
;;;653    	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
000066  f1050044          ADD      r0,r5,#0x44
00006a  f8501026          LDR      r1,[r0,r6,LSL #2]
00006e  1c78              ADDS     r0,r7,#1
000070  eb010040          ADD      r0,r1,r0,LSL #1
000074  900a              STR      r0,[sp,#0x28]
000076  e008              B        |L14.138|
                  |L14.120|
;;;654          } else {
;;;655    	/* work left to right in this row */
;;;656    	dir = 1;
000078  2001              MOVS     r0,#1
00007a  9003              STR      r0,[sp,#0xc]
;;;657    	dirnc = nc;
00007c  9804              LDR      r0,[sp,#0x10]
00007e  9002              STR      r0,[sp,#8]
;;;658    	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
000080  f1050044          ADD      r0,r5,#0x44
000084  f8500026          LDR      r0,[r0,r6,LSL #2]
000088  900a              STR      r0,[sp,#0x28]
                  |L14.138|
;;;659          }
;;;660          colorindex_ci = cquantize->colorindex[ci];
00008a  69a8              LDR      r0,[r5,#0x18]
00008c  f8500026          LDR      r0,[r0,r6,LSL #2]
000090  9007              STR      r0,[sp,#0x1c]
;;;661          colormap_ci = cquantize->sv_colormap[ci];
000092  6928              LDR      r0,[r5,#0x10]
000094  f8500026          LDR      r0,[r0,r6,LSL #2]
000098  9006              STR      r0,[sp,#0x18]
;;;662          /* Preset error values: no error propagated to first pixel from left */
;;;663          cur = 0;
00009a  2400              MOVS     r4,#0
;;;664          /* and no error propagated to row below yet */
;;;665          belowerr = bpreverr = 0;
00009c  2000              MOVS     r0,#0
00009e  900b              STR      r0,[sp,#0x2c]
0000a0  900c              STR      r0,[sp,#0x30]
;;;666    
;;;667          for (col = width; col > 0; col--) {
0000a2  9701              STR      r7,[sp,#4]
0000a4  e039              B        |L14.282|
                  |L14.166|
;;;668    	/* cur holds the error propagated from the previous pixel on the
;;;669    	 * current line.  Add the error propagated from the previous line
;;;670    	 * to form the complete error correction term for this pixel, and
;;;671    	 * round the error term (which is expressed * 16) to an integer.
;;;672    	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;673    	 * for either sign of the error value.
;;;674    	 * Note: errorptr points to *previous* column's array entry.
;;;675    	 */
;;;676    	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
0000a6  9903              LDR      r1,[sp,#0xc]
0000a8  980a              LDR      r0,[sp,#0x28]
0000aa  f9300011          LDRSH    r0,[r0,r1,LSL #1]
0000ae  4420              ADD      r0,r0,r4
0000b0  3008              ADDS     r0,r0,#8
0000b2  1104              ASRS     r4,r0,#4
;;;677    	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;678    	 * The maximum error is +- MAXJSAMPLE; this sets the required size
;;;679    	 * of the range_limit array.
;;;680    	 */
;;;681    	cur += GETJSAMPLE(*input_ptr);
0000b4  9809              LDR      r0,[sp,#0x24]
0000b6  7800              LDRB     r0,[r0,#0]
0000b8  4404              ADD      r4,r4,r0
;;;682    	cur = GETJSAMPLE(range_limit[cur]);
0000ba  9800              LDR      r0,[sp,#0]
0000bc  5d04              LDRB     r4,[r0,r4]
;;;683    	/* Select output value, accumulate into output code for this pixel */
;;;684    	pixcode = GETJSAMPLE(colorindex_ci[cur]);
0000be  9807              LDR      r0,[sp,#0x1c]
0000c0  5d00              LDRB     r0,[r0,r4]
0000c2  9005              STR      r0,[sp,#0x14]
;;;685    	*output_ptr += (JSAMPLE) pixcode;
0000c4  9808              LDR      r0,[sp,#0x20]
0000c6  7801              LDRB     r1,[r0,#0]
0000c8  9805              LDR      r0,[sp,#0x14]
0000ca  4408              ADD      r0,r0,r1
0000cc  b2c1              UXTB     r1,r0
0000ce  9808              LDR      r0,[sp,#0x20]
0000d0  7001              STRB     r1,[r0,#0]
;;;686    	/* Compute actual representation error at this pixel */
;;;687    	/* Note: we can do this even though we don't have the final */
;;;688    	/* pixel code, because the colormap is orthogonal. */
;;;689    	cur -= GETJSAMPLE(colormap_ci[pixcode]);
0000d2  e9dd0105          LDRD     r0,r1,[sp,#0x14]
0000d6  5c08              LDRB     r0,[r1,r0]
0000d8  1a24              SUBS     r4,r4,r0
;;;690    	/* Compute error fractions to be propagated to adjacent pixels.
;;;691    	 * Add these into the running sums, and simultaneously shift the
;;;692    	 * next-line error sums left by 1 column.
;;;693    	 */
;;;694    	bnexterr = cur;
0000da  46a1              MOV      r9,r4
;;;695    	delta = cur * 2;
0000dc  ea4f0b44          LSL      r11,r4,#1
;;;696    	cur += delta;		/* form error * 3 */
0000e0  445c              ADD      r4,r4,r11
;;;697    	errorptr[0] = (FSERROR) (bpreverr + cur);
0000e2  980b              LDR      r0,[sp,#0x2c]
0000e4  4420              ADD      r0,r0,r4
0000e6  b201              SXTH     r1,r0
0000e8  980a              LDR      r0,[sp,#0x28]
0000ea  8001              STRH     r1,[r0,#0]
;;;698    	cur += delta;		/* form error * 5 */
0000ec  445c              ADD      r4,r4,r11
;;;699    	bpreverr = belowerr + cur;
0000ee  980c              LDR      r0,[sp,#0x30]
0000f0  4420              ADD      r0,r0,r4
0000f2  900b              STR      r0,[sp,#0x2c]
;;;700    	belowerr = bnexterr;
0000f4  f8cd9030          STR      r9,[sp,#0x30]
;;;701    	cur += delta;		/* form error * 7 */
0000f8  445c              ADD      r4,r4,r11
;;;702    	/* At this point cur contains the 7/16 error value to be propagated
;;;703    	 * to the next pixel on the current line, and all the errors for the
;;;704    	 * next line have been shifted over. We are therefore ready to move on.
;;;705    	 */
;;;706    	input_ptr += dirnc;	/* advance input ptr to next column */
0000fa  9902              LDR      r1,[sp,#8]
0000fc  9809              LDR      r0,[sp,#0x24]
0000fe  4408              ADD      r0,r0,r1
000100  9009              STR      r0,[sp,#0x24]
;;;707    	output_ptr += dir;	/* advance output ptr to next column */
000102  9903              LDR      r1,[sp,#0xc]
000104  9808              LDR      r0,[sp,#0x20]
000106  4408              ADD      r0,r0,r1
000108  9008              STR      r0,[sp,#0x20]
;;;708    	errorptr += dir;	/* advance errorptr to current column */
00010a  9903              LDR      r1,[sp,#0xc]
00010c  980a              LDR      r0,[sp,#0x28]
00010e  eb000041          ADD      r0,r0,r1,LSL #1
000112  900a              STR      r0,[sp,#0x28]
000114  9801              LDR      r0,[sp,#4]            ;667
000116  1e40              SUBS     r0,r0,#1              ;667
000118  9001              STR      r0,[sp,#4]            ;667
                  |L14.282|
00011a  9801              LDR      r0,[sp,#4]            ;667
00011c  2800              CMP      r0,#0                 ;667
00011e  d1c2              BNE      |L14.166|
;;;709          }
;;;710          /* Post-loop cleanup: we must unload the final error value into the
;;;711           * final fserrors[] entry.  Note we need not unload belowerr because
;;;712           * it is for the dummy column before or after the actual array.
;;;713           */
;;;714          errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
000120  980b              LDR      r0,[sp,#0x2c]
000122  b201              SXTH     r1,r0
000124  980a              LDR      r0,[sp,#0x28]
000126  8001              STRH     r1,[r0,#0]
000128  1c76              ADDS     r6,r6,#1              ;644
                  |L14.298|
00012a  9804              LDR      r0,[sp,#0x10]         ;644
00012c  4286              CMP      r6,r0                 ;644
00012e  db80              BLT      |L14.50|
;;;715        }
;;;716        cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
000130  6d68              LDR      r0,[r5,#0x54]
000132  b908              CBNZ     r0,|L14.312|
000134  2001              MOVS     r0,#1
000136  e000              B        |L14.314|
                  |L14.312|
000138  2000              MOVS     r0,#0
                  |L14.314|
00013a  6568              STR      r0,[r5,#0x54]
00013c  f10a0a01          ADD      r10,r10,#1            ;640
                  |L14.320|
000140  9810              LDR      r0,[sp,#0x40]         ;640
000142  4582              CMP      r10,r0                ;640
000144  f6ffaf6d          BLT      |L14.34|
;;;717      }
;;;718    }
000148  b011              ADD      sp,sp,#0x44
00014a  e8bd8ff0          POP      {r4-r11,pc}
;;;719    
                          ENDP


                          AREA ||i.quantize_ord_dither||, CODE, READONLY, ALIGN=1

                  quantize_ord_dither PROC
;;;518    METHODDEF(void)
;;;519    quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;520    		     JSAMPARRAY output_buf, int num_rows)
;;;521    /* General case, with ordered dithering */
;;;522    {
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  4690              MOV      r8,r2
;;;523      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000a  f8d671cc          LDR      r7,[r6,#0x1cc]
;;;524      register JSAMPROW input_ptr;
;;;525      register JSAMPROW output_ptr;
;;;526      JSAMPROW colorindex_ci;
;;;527      int * dither;			/* points to active row of dither matrix */
;;;528      int row_index, col_index;	/* current indexes into dither matrix */
;;;529      int nc = cinfo->out_color_components;
00000e  6fb0              LDR      r0,[r6,#0x78]
000010  9002              STR      r0,[sp,#8]
;;;530      int ci;
;;;531      int row;
;;;532      JDIMENSION col;
;;;533      JDIMENSION width = cinfo->output_width;
000012  f8d6b070          LDR      r11,[r6,#0x70]
;;;534    
;;;535      for (row = 0; row < num_rows; row++) {
000016  2500              MOVS     r5,#0
000018  e049              B        |L15.174|
                  |L15.26|
;;;536        /* Initialize output values to 0 so can process components separately */
;;;537        jzero_far((void FAR *) output_buf[row],
00001a  4659              MOV      r1,r11
00001c  f8580025          LDR      r0,[r8,r5,LSL #2]
000020  f7fffffe          BL       jzero_far
;;;538    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;539        row_index = cquantize->row_index;
000024  f8d7a030          LDR      r10,[r7,#0x30]
;;;540        for (ci = 0; ci < nc; ci++) {
000028  2400              MOVS     r4,#0
00002a  e036              B        |L15.154|
                  |L15.44|
;;;541          input_ptr = input_buf[row] + ci;
00002c  9808              LDR      r0,[sp,#0x20]
00002e  f8500025          LDR      r0,[r0,r5,LSL #2]
000032  4420              ADD      r0,r0,r4
000034  9006              STR      r0,[sp,#0x18]
;;;542          output_ptr = output_buf[row];
000036  f8589025          LDR      r9,[r8,r5,LSL #2]
;;;543          colorindex_ci = cquantize->colorindex[ci];
00003a  69b8              LDR      r0,[r7,#0x18]
00003c  f8500024          LDR      r0,[r0,r4,LSL #2]
000040  9005              STR      r0,[sp,#0x14]
;;;544          dither = cquantize->odither[ci][row_index];
000042  f1070034          ADD      r0,r7,#0x34
000046  f8500024          LDR      r0,[r0,r4,LSL #2]
00004a  eb00108a          ADD      r0,r0,r10,LSL #6
00004e  9004              STR      r0,[sp,#0x10]
;;;545          col_index = 0;
000050  2000              MOVS     r0,#0
000052  9003              STR      r0,[sp,#0xc]
;;;546    
;;;547          for (col = width; col > 0; col--) {
000054  f8cdb004          STR      r11,[sp,#4]
000058  e01b              B        |L15.146|
                  |L15.90|
;;;548    	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
;;;549    	 * select output value, accumulate into output code for this pixel.
;;;550    	 * Range-limiting need not be done explicitly, as we have extended
;;;551    	 * the colorindex table to produce the right answers for out-of-range
;;;552    	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
;;;553    	 * required amount of padding.
;;;554    	 */
;;;555    	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
00005a  9806              LDR      r0,[sp,#0x18]
00005c  7802              LDRB     r2,[r0,#0]
00005e  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000062  f8500021          LDR      r0,[r0,r1,LSL #2]
000066  1811              ADDS     r1,r2,r0
000068  9805              LDR      r0,[sp,#0x14]
00006a  5c40              LDRB     r0,[r0,r1]
00006c  f8991000          LDRB     r1,[r9,#0]
000070  4408              ADD      r0,r0,r1
000072  f8890000          STRB     r0,[r9,#0]
;;;556    	input_ptr += nc;
000076  9902              LDR      r1,[sp,#8]
000078  9806              LDR      r0,[sp,#0x18]
00007a  4408              ADD      r0,r0,r1
00007c  9006              STR      r0,[sp,#0x18]
;;;557    	output_ptr++;
00007e  f1090901          ADD      r9,r9,#1
;;;558    	col_index = (col_index + 1) & ODITHER_MASK;
000082  9803              LDR      r0,[sp,#0xc]
000084  1c40              ADDS     r0,r0,#1
000086  f000000f          AND      r0,r0,#0xf
00008a  9003              STR      r0,[sp,#0xc]
00008c  9801              LDR      r0,[sp,#4]            ;547
00008e  1e40              SUBS     r0,r0,#1              ;547
000090  9001              STR      r0,[sp,#4]            ;547
                  |L15.146|
000092  9801              LDR      r0,[sp,#4]            ;547
000094  2800              CMP      r0,#0                 ;547
000096  d1e0              BNE      |L15.90|
000098  1c64              ADDS     r4,r4,#1              ;540
                  |L15.154|
00009a  9802              LDR      r0,[sp,#8]            ;540
00009c  4284              CMP      r4,r0                 ;540
00009e  dbc5              BLT      |L15.44|
;;;559          }
;;;560        }
;;;561        /* Advance row index for next row */
;;;562        row_index = (row_index + 1) & ODITHER_MASK;
0000a0  f10a0001          ADD      r0,r10,#1
0000a4  f0000a0f          AND      r10,r0,#0xf
;;;563        cquantize->row_index = row_index;
0000a8  f8c7a030          STR      r10,[r7,#0x30]
0000ac  1c6d              ADDS     r5,r5,#1              ;535
                  |L15.174|
0000ae  980a              LDR      r0,[sp,#0x28]         ;535
0000b0  4285              CMP      r5,r0                 ;535
0000b2  dbb2              BLT      |L15.26|
;;;564      }
;;;565    }
0000b4  b00b              ADD      sp,sp,#0x2c
0000b6  e8bd8ff0          POP      {r4-r11,pc}
;;;566    
                          ENDP


                          AREA ||i.select_ncolors||, CODE, READONLY, ALIGN=2

                  select_ncolors PROC
;;;185    LOCAL(int)
;;;186    select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;187    /* Determine allocation of desired colors to components, */
;;;188    /* and fill in Ncolors[] array to indicate choice. */
;;;189    /* Return value is total number of colors (product of Ncolors[] values). */
;;;190    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;191      int nc = cinfo->out_color_components; /* number of color components */
000008  f8d5b078          LDR      r11,[r5,#0x78]
;;;192      int max_colors = cinfo->desired_number_of_colors;
00000c  6e28              LDR      r0,[r5,#0x60]
00000e  9001              STR      r0,[sp,#4]
;;;193      int total_colors, iroot, i, j;
;;;194      boolean changed;
;;;195      long temp;
;;;196      static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };
;;;197    
;;;198      /* We can allocate at least the nc'th root of max_colors per component. */
;;;199      /* Compute floor(nc'th root of max_colors). */
;;;200      iroot = 1;
000010  2601              MOVS     r6,#1
;;;201      do {
000012  bf00              NOP      
                  |L16.20|
;;;202        iroot++;
000014  1c76              ADDS     r6,r6,#1
;;;203        temp = iroot;		/* set temp = iroot ** nc */
000016  46b0              MOV      r8,r6
;;;204        for (i = 1; i < nc; i++)
000018  2401              MOVS     r4,#1
00001a  e002              B        |L16.34|
                  |L16.28|
;;;205          temp *= iroot;
00001c  fb08f806          MUL      r8,r8,r6
000020  1c64              ADDS     r4,r4,#1              ;204
                  |L16.34|
000022  455c              CMP      r4,r11                ;204
000024  dbfa              BLT      |L16.28|
;;;206      } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
000026  9801              LDR      r0,[sp,#4]
000028  4580              CMP      r8,r0
00002a  ddf3              BLE      |L16.20|
;;;207      iroot--;			/* now iroot = floor(root) */
00002c  1e76              SUBS     r6,r6,#1
;;;208    
;;;209      /* Must have at least 2 color values per component */
;;;210      if (iroot < 2)
00002e  2e02              CMP      r6,#2
000030  da09              BGE      |L16.70|
;;;211        ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
000032  2038              MOVS     r0,#0x38
000034  6829              LDR      r1,[r5,#0]
000036  6148              STR      r0,[r1,#0x14]
000038  6828              LDR      r0,[r5,#0]
00003a  f8c08018          STR      r8,[r0,#0x18]
00003e  6828              LDR      r0,[r5,#0]
000040  6801              LDR      r1,[r0,#0]
000042  4628              MOV      r0,r5
000044  4788              BLX      r1
                  |L16.70|
;;;212    
;;;213      /* Initialize to iroot color values for each component */
;;;214      total_colors = 1;
000046  f04f0901          MOV      r9,#1
;;;215      for (i = 0; i < nc; i++) {
00004a  2400              MOVS     r4,#0
00004c  e004              B        |L16.88|
                  |L16.78|
;;;216        Ncolors[i] = iroot;
00004e  f8476024          STR      r6,[r7,r4,LSL #2]
;;;217        total_colors *= iroot;
000052  fb09f906          MUL      r9,r9,r6
000056  1c64              ADDS     r4,r4,#1              ;215
                  |L16.88|
000058  455c              CMP      r4,r11                ;215
00005a  dbf8              BLT      |L16.78|
;;;218      }
;;;219      /* We may be able to increment the count for one or more components without
;;;220       * exceeding max_colors, though we know not all can be incremented.
;;;221       * Sometimes, the first component can be incremented more than once!
;;;222       * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
;;;223       * In RGB colorspace, try to increment G first, then R, then B.
;;;224       */
;;;225      do {
00005c  bf00              NOP      
                  |L16.94|
;;;226        changed = FALSE;
00005e  2000              MOVS     r0,#0
000060  9000              STR      r0,[sp,#0]
;;;227        for (i = 0; i < nc; i++) {
000062  2400              MOVS     r4,#0
000064  e01f              B        |L16.166|
                  |L16.102|
;;;228          j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
000066  f8950029          LDRB     r0,[r5,#0x29]
00006a  2802              CMP      r0,#2
00006c  d103              BNE      |L16.118|
00006e  4812              LDR      r0,|L16.184|
000070  f8500024          LDR      r0,[r0,r4,LSL #2]
000074  e000              B        |L16.120|
                  |L16.118|
000076  4620              MOV      r0,r4
                  |L16.120|
000078  4682              MOV      r10,r0
;;;229          /* calculate new total_colors if Ncolors[j] is incremented */
;;;230          temp = total_colors / Ncolors[j];
00007a  f857002a          LDR      r0,[r7,r10,LSL #2]
00007e  fb99f8f0          SDIV     r8,r9,r0
;;;231          temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
000082  f857002a          LDR      r0,[r7,r10,LSL #2]
000086  1c40              ADDS     r0,r0,#1
000088  fb08f800          MUL      r8,r8,r0
;;;232          if (temp > (long) max_colors)
00008c  9801              LDR      r0,[sp,#4]
00008e  4580              CMP      r8,r0
000090  dd00              BLE      |L16.148|
;;;233    	break;			/* won't fit, done with this pass */
000092  e00a              B        |L16.170|
                  |L16.148|
;;;234          Ncolors[j]++;		/* OK, apply the increment */
000094  f857002a          LDR      r0,[r7,r10,LSL #2]
000098  1c40              ADDS     r0,r0,#1
00009a  f847002a          STR      r0,[r7,r10,LSL #2]
;;;235          total_colors = (int) temp;
00009e  46c1              MOV      r9,r8
;;;236          changed = TRUE;
0000a0  2001              MOVS     r0,#1
0000a2  9000              STR      r0,[sp,#0]
0000a4  1c64              ADDS     r4,r4,#1              ;227
                  |L16.166|
0000a6  455c              CMP      r4,r11                ;227
0000a8  dbdd              BLT      |L16.102|
                  |L16.170|
0000aa  bf00              NOP                            ;233
;;;237        }
;;;238      } while (changed);
0000ac  9800              LDR      r0,[sp,#0]
0000ae  2800              CMP      r0,#0
0000b0  d1d5              BNE      |L16.94|
;;;239    
;;;240      return total_colors;
0000b2  4648              MOV      r0,r9
;;;241    }
0000b4  e8bd9ffc          POP      {r2-r12,pc}
;;;242    
                          ENDP

                  |L16.184|
                          DCD      RGB_order

                          AREA ||i.start_pass_1_quant||, CODE, READONLY, ALIGN=2

                  start_pass_1_quant PROC
;;;744    METHODDEF(void)
;;;745    start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;746    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;747      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f1050558          ADD      r5,r5,#0x58
00000c  f8d54174          LDR      r4,[r5,#0x174]
;;;748      size_t arraysize;
;;;749      int i;
;;;750    
;;;751      GUI_USE_PARA(is_pre_scan);
000010  bf00              NOP      
;;;752      /* Install my colormap. */
;;;753      cinfo->colormap = cquantize->sv_colormap;
000012  6920              LDR      r0,[r4,#0x10]
000014  6328              STR      r0,[r5,#0x30]
;;;754      cinfo->actual_number_of_colors = cquantize->sv_actual;
000016  6960              LDR      r0,[r4,#0x14]
000018  62e8              STR      r0,[r5,#0x2c]
;;;755    
;;;756      /* Initialize for desired dithering mode. */
;;;757      switch (cinfo->dither_mode) {
00001a  f8150958          LDRB     r0,[r5],#-0x58
00001e  b120              CBZ      r0,|L17.42|
000020  2801              CMP      r0,#1
000022  d00b              BEQ      |L17.60|
000024  2802              CMP      r0,#2
000026  d139              BNE      |L17.156|
000028  e01d              B        |L17.102|
                  |L17.42|
;;;758      case JDITHER_NONE:
;;;759        if (cinfo->out_color_components == 3)
00002a  6fa8              LDR      r0,[r5,#0x78]
00002c  2803              CMP      r0,#3
00002e  d102              BNE      |L17.54|
;;;760          cquantize->pub.color_quantize = color_quantize3;
000030  4820              LDR      r0,|L17.180|
000032  6060              STR      r0,[r4,#4]
000034  e001              B        |L17.58|
                  |L17.54|
;;;761        else
;;;762          cquantize->pub.color_quantize = color_quantize;
000036  4820              LDR      r0,|L17.184|
000038  6060              STR      r0,[r4,#4]
                  |L17.58|
;;;763        break;
00003a  e037              B        |L17.172|
                  |L17.60|
;;;764      case JDITHER_ORDERED:
;;;765        if (cinfo->out_color_components == 3)
00003c  6fa8              LDR      r0,[r5,#0x78]
00003e  2803              CMP      r0,#3
000040  d102              BNE      |L17.72|
;;;766          cquantize->pub.color_quantize = quantize3_ord_dither;
000042  481e              LDR      r0,|L17.188|
000044  6060              STR      r0,[r4,#4]
000046  e001              B        |L17.76|
                  |L17.72|
;;;767        else
;;;768          cquantize->pub.color_quantize = quantize_ord_dither;
000048  481d              LDR      r0,|L17.192|
00004a  6060              STR      r0,[r4,#4]
                  |L17.76|
;;;769        cquantize->row_index = 0;	/* initialize state for ordered dither */
00004c  2000              MOVS     r0,#0
00004e  6320              STR      r0,[r4,#0x30]
;;;770        /* If user changed to ordered dither from another mode,
;;;771         * we must recreate the color index table with padding.
;;;772         * This will cost extra space, but probably isn't very likely.
;;;773         */
;;;774        if (! cquantize->is_padded)
000050  69e0              LDR      r0,[r4,#0x1c]
000052  b910              CBNZ     r0,|L17.90|
;;;775          create_colorindex(cinfo);
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       create_colorindex
                  |L17.90|
;;;776        /* Create ordered-dither tables if we didn't already. */
;;;777        if (cquantize->odither[0] == NULL)
00005a  6b60              LDR      r0,[r4,#0x34]
00005c  b910              CBNZ     r0,|L17.100|
;;;778          create_odither_tables(cinfo);
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       create_odither_tables
                  |L17.100|
;;;779        break;
000064  e022              B        |L17.172|
                  |L17.102|
;;;780      case JDITHER_FS:
;;;781        cquantize->pub.color_quantize = quantize_fs_dither;
000066  4817              LDR      r0,|L17.196|
000068  6060              STR      r0,[r4,#4]
;;;782        cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
00006a  2000              MOVS     r0,#0
00006c  6560              STR      r0,[r4,#0x54]
;;;783        /* Allocate Floyd-Steinberg workspace if didn't already. */
;;;784        if (cquantize->fserrors[0] == NULL)
00006e  6c60              LDR      r0,[r4,#0x44]
000070  b910              CBNZ     r0,|L17.120|
;;;785          alloc_fs_workspace(cinfo);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       alloc_fs_workspace
                  |L17.120|
;;;786        /* Initialize the propagated errors to zero. */
;;;787        arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
000078  6f28              LDR      r0,[r5,#0x70]
00007a  1c80              ADDS     r0,r0,#2
00007c  ea4f0840          LSL      r8,r0,#1
;;;788        for (i = 0; i < cinfo->out_color_components; i++)
000080  2600              MOVS     r6,#0
000082  e007              B        |L17.148|
                  |L17.132|
;;;789          jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
000084  f1040144          ADD      r1,r4,#0x44
000088  f8510026          LDR      r0,[r1,r6,LSL #2]
00008c  4641              MOV      r1,r8
00008e  f7fffffe          BL       jzero_far
000092  1c76              ADDS     r6,r6,#1              ;788
                  |L17.148|
000094  6fa8              LDR      r0,[r5,#0x78]         ;788
000096  42b0              CMP      r0,r6                 ;788
000098  dcf4              BGT      |L17.132|
;;;790        break;
00009a  e007              B        |L17.172|
                  |L17.156|
;;;791      default:
;;;792        ERREXIT(cinfo, JERR_NOT_COMPILED);
00009c  2030              MOVS     r0,#0x30
00009e  6829              LDR      r1,[r5,#0]
0000a0  6148              STR      r0,[r1,#0x14]
0000a2  6828              LDR      r0,[r5,#0]
0000a4  6801              LDR      r1,[r0,#0]
0000a6  4628              MOV      r0,r5
0000a8  4788              BLX      r1
;;;793        break;
0000aa  bf00              NOP      
                  |L17.172|
0000ac  bf00              NOP                            ;763
;;;794      }
;;;795    }
0000ae  e8bd81f0          POP      {r4-r8,pc}
;;;796    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L17.180|
                          DCD      color_quantize3
                  |L17.184|
                          DCD      color_quantize
                  |L17.188|
                          DCD      quantize3_ord_dither
                  |L17.192|
                          DCD      quantize_ord_dither
                  |L17.196|
                          DCD      quantize_fs_dither

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  base_dither_matrix
000000  00c030f0          DCB      0x00,0xc0,0x30,0xf0
000004  0ccc3cfc          DCB      0x0c,0xcc,0x3c,0xfc
000008  03c333f3          DCB      0x03,0xc3,0x33,0xf3
00000c  0fcf3fff          DCB      0x0f,0xcf,0x3f,0xff
000010  8040b070          DCB      0x80,0x40,0xb0,0x70
000014  8c4cbc7c          DCB      0x8c,0x4c,0xbc,0x7c
000018  8343b373          DCB      0x83,0x43,0xb3,0x73
00001c  8f4fbf7f          DCB      0x8f,0x4f,0xbf,0x7f
000020  20e010d0          DCB      0x20,0xe0,0x10,0xd0
000024  2cec1cdc          DCB      0x2c,0xec,0x1c,0xdc
000028  23e313d3          DCB      0x23,0xe3,0x13,0xd3
00002c  2fef1fdf          DCB      0x2f,0xef,0x1f,0xdf
000030  a0609050          DCB      0xa0,0x60,0x90,0x50
000034  ac6c9c5c          DCB      0xac,0x6c,0x9c,0x5c
000038  a3639353          DCB      0xa3,0x63,0x93,0x53
00003c  af6f9f5f          DCB      0xaf,0x6f,0x9f,0x5f
000040  08c838f8          DCB      0x08,0xc8,0x38,0xf8
000044  04c434f4          DCB      0x04,0xc4,0x34,0xf4
000048  0bcb3bfb          DCB      0x0b,0xcb,0x3b,0xfb
00004c  07c737f7          DCB      0x07,0xc7,0x37,0xf7
000050  8848b878          DCB      0x88,0x48,0xb8,0x78
000054  8444b474          DCB      0x84,0x44,0xb4,0x74
000058  8b4bbb7b          DCB      0x8b,0x4b,0xbb,0x7b
00005c  8747b777          DCB      0x87,0x47,0xb7,0x77
000060  28e818d8          DCB      0x28,0xe8,0x18,0xd8
000064  24e414d4          DCB      0x24,0xe4,0x14,0xd4
000068  2beb1bdb          DCB      0x2b,0xeb,0x1b,0xdb
00006c  27e717d7          DCB      0x27,0xe7,0x17,0xd7
000070  a8689858          DCB      0xa8,0x68,0x98,0x58
000074  a4649454          DCB      0xa4,0x64,0x94,0x54
000078  ab6b9b5b          DCB      0xab,0x6b,0x9b,0x5b
00007c  a7679757          DCB      0xa7,0x67,0x97,0x57
000080  02c232f2          DCB      0x02,0xc2,0x32,0xf2
000084  0ece3efe          DCB      0x0e,0xce,0x3e,0xfe
000088  01c131f1          DCB      0x01,0xc1,0x31,0xf1
00008c  0dcd3dfd          DCB      0x0d,0xcd,0x3d,0xfd
000090  8242b272          DCB      0x82,0x42,0xb2,0x72
000094  8e4ebe7e          DCB      0x8e,0x4e,0xbe,0x7e
000098  8141b171          DCB      0x81,0x41,0xb1,0x71
00009c  8d4dbd7d          DCB      0x8d,0x4d,0xbd,0x7d
0000a0  22e212d2          DCB      0x22,0xe2,0x12,0xd2
0000a4  2eee1ede          DCB      0x2e,0xee,0x1e,0xde
0000a8  21e111d1          DCB      0x21,0xe1,0x11,0xd1
0000ac  2ded1ddd          DCB      0x2d,0xed,0x1d,0xdd
0000b0  a2629252          DCB      0xa2,0x62,0x92,0x52
0000b4  ae6e9e5e          DCB      0xae,0x6e,0x9e,0x5e
0000b8  a1619151          DCB      0xa1,0x61,0x91,0x51
0000bc  ad6d9d5d          DCB      0xad,0x6d,0x9d,0x5d
0000c0  0aca3afa          DCB      0x0a,0xca,0x3a,0xfa
0000c4  06c636f6          DCB      0x06,0xc6,0x36,0xf6
0000c8  09c939f9          DCB      0x09,0xc9,0x39,0xf9
0000cc  05c535f5          DCB      0x05,0xc5,0x35,0xf5
0000d0  8a4aba7a          DCB      0x8a,0x4a,0xba,0x7a
0000d4  8646b676          DCB      0x86,0x46,0xb6,0x76
0000d8  8949b979          DCB      0x89,0x49,0xb9,0x79
0000dc  8545b575          DCB      0x85,0x45,0xb5,0x75
0000e0  2aea1ada          DCB      0x2a,0xea,0x1a,0xda
0000e4  26e616d6          DCB      0x26,0xe6,0x16,0xd6
0000e8  29e919d9          DCB      0x29,0xe9,0x19,0xd9
0000ec  25e515d5          DCB      0x25,0xe5,0x15,0xd5
0000f0  aa6a9a5a          DCB      0xaa,0x6a,0x9a,0x5a
0000f4  a6669656          DCB      0xa6,0x66,0x96,0x56
0000f8  a9699959          DCB      0xa9,0x69,0x99,0x59
0000fc  a5659555          DCB      0xa5,0x65,0x95,0x55
                  RGB_order
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000002
