; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jddctmgr.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jddctmgr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jddctmgr.c]
                          THUMB

                          AREA ||i.jinit_inverse_dct||, CODE, READONLY, ALIGN=2

                  jinit_inverse_dct PROC
;;;243    GLOBAL(void)
;;;244    jinit_inverse_dct (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;245    {
000004  4604              MOV      r4,r0
;;;246      my_idct_ptr idct;
;;;247      int ci;
;;;248      jpeg_component_info *compptr;
;;;249    
;;;250      idct = (my_idct_ptr)
000006  6860              LDR      r0,[r4,#4]
000008  2224              MOVS     r2,#0x24
00000a  2101              MOVS     r1,#1
00000c  6803              LDR      r3,[r0,#0]
00000e  4620              MOV      r0,r4
000010  4798              BLX      r3
000012  4605              MOV      r5,r0
;;;251        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;252    				SIZEOF(my_idct_controller));
;;;253      cinfo->idct = (struct jpeg_inverse_dct *) idct;
000014  f8c451c0          STR      r5,[r4,#0x1c0]
;;;254      idct->pub.start_pass = start_pass;
000018  480f              LDR      r0,|L1.88|
00001a  6028              STR      r0,[r5,#0]
;;;255    
;;;256      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00001c  2600              MOVS     r6,#0
00001e  f8d470d8          LDR      r7,[r4,#0xd8]
000022  e014              B        |L1.78|
                  |L1.36|
;;;257           ci++, compptr++) {
;;;258        /* Allocate and pre-zero a multiplier table for each component */
;;;259        compptr->dct_table =
000024  6860              LDR      r0,[r4,#4]
000026  f44f7280          MOV      r2,#0x100
00002a  2101              MOVS     r1,#1
00002c  6803              LDR      r3,[r0,#0]
00002e  4620              MOV      r0,r4
000030  4798              BLX      r3
000032  6538              STR      r0,[r7,#0x50]
;;;260          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				  SIZEOF(multiplier_table));
;;;262        MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
000034  f44f7180          MOV      r1,#0x100
000038  6d38              LDR      r0,[r7,#0x50]
00003a  f7fffffe          BL       __aeabi_memclr
;;;263        /* Mark multiplier table not yet set up for any method */
;;;264        idct->cur_method[ci] = -1;
00003e  f04f31ff          MOV      r1,#0xffffffff
000042  f1050014          ADD      r0,r5,#0x14
000046  f8401026          STR      r1,[r0,r6,LSL #2]
00004a  1c76              ADDS     r6,r6,#1              ;257
00004c  3754              ADDS     r7,r7,#0x54           ;257
                  |L1.78|
00004e  6a60              LDR      r0,[r4,#0x24]         ;256
000050  42b0              CMP      r0,r6                 ;256
000052  dce7              BGT      |L1.36|
;;;265      }
;;;266    }
000054  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.88|
                          DCD      start_pass

                          AREA ||i.start_pass||, CODE, READONLY, ALIGN=2

                  start_pass PROC
;;;87     
;;;88     METHODDEF(void) start_pass (j_decompress_ptr cinfo) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4604              MOV      r4,r0
;;;89       my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
000006  f8d491c0          LDR      r9,[r4,#0x1c0]
;;;90       int ci, i;
;;;91       jpeg_component_info *compptr;
;;;92       int method = 0;
00000a  f04f0a00          MOV      r10,#0
;;;93       inverse_DCT_method_ptr method_ptr = NULL;
00000e  46d3              MOV      r11,r10
;;;94       JQUANT_TBL * qtbl;
;;;95     
;;;96       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++, compptr++) {
000010  2700              MOVS     r7,#0
000012  f8d460d8          LDR      r6,[r4,#0xd8]
000016  e06f              B        |L2.248|
                  |L2.24|
;;;97         /* Select the proper IDCT routine for this component's scaling */
;;;98         switch (compptr->DCT_scaled_size) {
000018  6a70              LDR      r0,[r6,#0x24]
00001a  2808              CMP      r0,#8
00001c  d119              BNE      |L2.82|
;;;99     #ifdef IDCT_SCALING_SUPPORTED
;;;100        case 1:
;;;101          method_ptr = jpeg_idct_1x1;
;;;102          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;103          break;
;;;104        case 2:
;;;105          method_ptr = jpeg_idct_2x2;
;;;106          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;107          break;
;;;108        case 4:
;;;109          method_ptr = jpeg_idct_4x4;
;;;110          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;111          break;
;;;112    #endif
;;;113        case DCTSIZE:
;;;114          switch (cinfo->dct_method) {
00001e  f8940048          LDRB     r0,[r4,#0x48]
000022  b110              CBZ      r0,|L2.42|
000024  2801              CMP      r0,#1
000026  d10a              BNE      |L2.62|
000028  e004              B        |L2.52|
                  |L2.42|
;;;115    #ifdef DCT_ISLOW_SUPPORTED
;;;116          case JDCT_ISLOW:
;;;117    	method_ptr = jpeg_idct_islow;
00002a  f8dfb0d8          LDR      r11,|L2.260|
;;;118    	method = JDCT_ISLOW;
00002e  f04f0a00          MOV      r10,#0
;;;119    	break;
000032  e00c              B        |L2.78|
                  |L2.52|
;;;120    #endif
;;;121    #ifdef DCT_IFAST_SUPPORTED
;;;122          case JDCT_IFAST:
;;;123    	method_ptr = jpeg_idct_ifast;
000034  f8dfb0d0          LDR      r11,|L2.264|
;;;124    	method = JDCT_IFAST;
000038  f04f0a01          MOV      r10,#1
;;;125    	break;
00003c  e007              B        |L2.78|
                  |L2.62|
;;;126    #endif
;;;127    #ifdef DCT_FLOAT_SUPPORTED
;;;128          case JDCT_FLOAT:
;;;129    	method_ptr = jpeg_idct_float;
;;;130    	method = JDCT_FLOAT;
;;;131    	break;
;;;132    #endif
;;;133          default:
;;;134    	ERREXIT(cinfo, JERR_NOT_COMPILED);
00003e  2030              MOVS     r0,#0x30
000040  6821              LDR      r1,[r4,#0]
000042  6148              STR      r0,[r1,#0x14]
000044  6820              LDR      r0,[r4,#0]
000046  6801              LDR      r1,[r0,#0]
000048  4620              MOV      r0,r4
00004a  4788              BLX      r1
;;;135    	break;
00004c  bf00              NOP      
                  |L2.78|
00004e  bf00              NOP                            ;119
;;;136          }
;;;137          break;
000050  e00a              B        |L2.104|
                  |L2.82|
;;;138        default:
;;;139          ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
000052  2007              MOVS     r0,#7
000054  6821              LDR      r1,[r4,#0]
000056  6148              STR      r0,[r1,#0x14]
000058  6a70              LDR      r0,[r6,#0x24]
00005a  6821              LDR      r1,[r4,#0]
00005c  6188              STR      r0,[r1,#0x18]
00005e  6820              LDR      r0,[r4,#0]
000060  6801              LDR      r1,[r0,#0]
000062  4620              MOV      r0,r4
000064  4788              BLX      r1
;;;140          break;
000066  bf00              NOP      
                  |L2.104|
000068  bf00              NOP                            ;137
;;;141        }
;;;142        idct->pub.inverse_DCT[ci] = method_ptr;
00006a  f1090004          ADD      r0,r9,#4
00006e  f840b027          STR      r11,[r0,r7,LSL #2]
;;;143        /* Create multiplier table from quant table.
;;;144         * However, we can skip this if the component is uninteresting
;;;145         * or if we already built the table.  Also, if no quant table
;;;146         * has yet been saved for the component, we leave the
;;;147         * multiplier table all-zero; we'll be reading zeroes from the
;;;148         * coefficient controller's buffer anyway.
;;;149         */
;;;150        if (! compptr->component_needed || idct->cur_method[ci] == method)
000072  6b30              LDR      r0,[r6,#0x30]
000074  b128              CBZ      r0,|L2.130|
000076  f1090014          ADD      r0,r9,#0x14
00007a  f8500027          LDR      r0,[r0,r7,LSL #2]
00007e  4550              CMP      r0,r10
000080  d100              BNE      |L2.132|
                  |L2.130|
;;;151          continue;
000082  e037              B        |L2.244|
                  |L2.132|
;;;152        qtbl = compptr->quant_table;
000084  f8d6804c          LDR      r8,[r6,#0x4c]
;;;153        if (qtbl == NULL)		/* happens if no data yet for component */
000088  f1b80f00          CMP      r8,#0
00008c  d100              BNE      |L2.144|
;;;154          continue;
00008e  e031              B        |L2.244|
                  |L2.144|
;;;155        idct->cur_method[ci] = method;
000090  f1090014          ADD      r0,r9,#0x14
000094  f840a027          STR      r10,[r0,r7,LSL #2]
;;;156        switch (method) {
000098  f1ba0f00          CMP      r10,#0
00009c  d003              BEQ      |L2.166|
00009e  f1ba0f01          CMP      r10,#1
0000a2  d11d              BNE      |L2.224|
0000a4  e00a              B        |L2.188|
                  |L2.166|
;;;157    #ifdef PROVIDE_ISLOW_TABLES
;;;158        case JDCT_ISLOW:
;;;159          {
;;;160    	/* For LL&M IDCT method, multipliers are equal to raw quantization
;;;161    	 * coefficients, but are stored as ints to ensure access efficiency.
;;;162    	 */
;;;163    	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
0000a6  6d30              LDR      r0,[r6,#0x50]
;;;164    	for (i = 0; i < DCTSIZE2; i++) {
0000a8  2500              MOVS     r5,#0
0000aa  e004              B        |L2.182|
                  |L2.172|
;;;165    	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
0000ac  f8381015          LDRH     r1,[r8,r5,LSL #1]
0000b0  f8401025          STR      r1,[r0,r5,LSL #2]
0000b4  1c6d              ADDS     r5,r5,#1              ;164
                  |L2.182|
0000b6  2d40              CMP      r5,#0x40              ;164
0000b8  dbf8              BLT      |L2.172|
;;;166    	}
;;;167          }
;;;168          break;
0000ba  e019              B        |L2.240|
                  |L2.188|
;;;169    #endif
;;;170    #ifdef DCT_IFAST_SUPPORTED
;;;171        case JDCT_IFAST:
;;;172          {
;;;173    	/* For AA&N IDCT method, multipliers are equal to quantization
;;;174    	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
;;;175    	 *   scalefactor[0] = 1
;;;176    	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
;;;177    	 * For integer operation, the multiplier table is to be scaled by
;;;178    	 * IFAST_SCALE_BITS.
;;;179    	 */
;;;180    	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
0000bc  6d30              LDR      r0,[r6,#0x50]
;;;181    #define CONST_BITS 14
;;;182    	static const INT16 aanscales[DCTSIZE2] = {
;;;183    	  /* precomputed values scaled up by 14 bits */
;;;184    	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
;;;185    	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
;;;186    	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
;;;187    	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
;;;188    	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
;;;189    	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
;;;190    	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
;;;191    	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
;;;192    	};
;;;193    	SHIFT_TEMPS
;;;194    
;;;195    	for (i = 0; i < DCTSIZE2; i++) {
0000be  2500              MOVS     r5,#0
0000c0  e00b              B        |L2.218|
                  |L2.194|
;;;196    	  ifmtbl[i] = (IFAST_MULT_TYPE)
0000c2  f8381015          LDRH     r1,[r8,r5,LSL #1]
0000c6  4a11              LDR      r2,|L2.268|
0000c8  f9322015          LDRSH    r2,[r2,r5,LSL #1]
0000cc  4351              MULS     r1,r2,r1
0000ce  f5016100          ADD      r1,r1,#0x800
0000d2  1309              ASRS     r1,r1,#12
0000d4  f8401025          STR      r1,[r0,r5,LSL #2]
0000d8  1c6d              ADDS     r5,r5,#1              ;195
                  |L2.218|
0000da  2d40              CMP      r5,#0x40              ;195
0000dc  dbf1              BLT      |L2.194|
;;;197    	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
;;;198    				  (INT32) aanscales[i]),
;;;199    		    CONST_BITS-IFAST_SCALE_BITS);
;;;200    	}
;;;201          }
;;;202          break;
0000de  e007              B        |L2.240|
                  |L2.224|
;;;203    #endif
;;;204    #ifdef DCT_FLOAT_SUPPORTED
;;;205        case JDCT_FLOAT:
;;;206          {
;;;207    	/* For float AA&N IDCT method, multipliers are equal to quantization
;;;208    	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
;;;209    	 *   scalefactor[0] = 1
;;;210    	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
;;;211    	 */
;;;212    	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
;;;213    	int row, col;
;;;214    	static const double aanscalefactor[DCTSIZE] = {
;;;215    	  1.0, 1.387039845, 1.306562965, 1.175875602,
;;;216    	  1.0, 0.785694958, 0.541196100, 0.275899379
;;;217    	};
;;;218    
;;;219    	i = 0;
;;;220    	for (row = 0; row < DCTSIZE; row++) {
;;;221    	  for (col = 0; col < DCTSIZE; col++) {
;;;222    	    fmtbl[i] = (FLOAT_MULT_TYPE)
;;;223    	      ((double) qtbl->quantval[i] *
;;;224    	       aanscalefactor[row] * aanscalefactor[col]);
;;;225    	    i++;
;;;226    	  }
;;;227    	}
;;;228          }
;;;229          break;
;;;230    #endif
;;;231        default:
;;;232          ERREXIT(cinfo, JERR_NOT_COMPILED);
0000e0  2030              MOVS     r0,#0x30
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6148              STR      r0,[r1,#0x14]
0000e6  6820              LDR      r0,[r4,#0]
0000e8  6801              LDR      r1,[r0,#0]
0000ea  4620              MOV      r0,r4
0000ec  4788              BLX      r1
;;;233          break;
0000ee  bf00              NOP      
                  |L2.240|
0000f0  bf00              NOP                            ;168
0000f2  bf00              NOP                            ;151
                  |L2.244|
0000f4  1c7f              ADDS     r7,r7,#1              ;96
0000f6  3654              ADDS     r6,r6,#0x54           ;96
                  |L2.248|
0000f8  6a60              LDR      r0,[r4,#0x24]         ;96
0000fa  42b8              CMP      r0,r7                 ;96
0000fc  dc8c              BGT      |L2.24|
;;;234        }
;;;235      }
;;;236    }
0000fe  e8bd9ff0          POP      {r4-r12,pc}
;;;237    
                          ENDP

000102  0000              DCW      0x0000
                  |L2.260|
                          DCD      jpeg_idct_islow
                  |L2.264|
                          DCD      jpeg_idct_ifast
                  |L2.268|
                          DCD      aanscales

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  aanscales
000000  400058c5          DCW      0x4000,0x58c5
000004  539f4b42          DCW      0x539f,0x4b42
000008  40003249          DCW      0x4000,0x3249
00000c  22a311a8          DCW      0x22a3,0x11a8
000010  58c57b21          DCW      0x58c5,0x7b21
000014  73fc6862          DCW      0x73fc,0x6862
000018  58c545bf          DCW      0x58c5,0x45bf
00001c  300b187e          DCW      0x300b,0x187e
000020  539f73fc          DCW      0x539f,0x73fc
000024  6d416254          DCW      0x6d41,0x6254
000028  539f41b3          DCW      0x539f,0x41b3
00002c  2d411712          DCW      0x2d41,0x1712
000030  4b426862          DCW      0x4b42,0x6862
000034  6254587e          DCW      0x6254,0x587e
000038  4b423b21          DCW      0x4b42,0x3b21
00003c  28ba14c3          DCW      0x28ba,0x14c3
000040  400058c5          DCW      0x4000,0x58c5
000044  539f4b42          DCW      0x539f,0x4b42
000048  40003249          DCW      0x4000,0x3249
00004c  22a311a8          DCW      0x22a3,0x11a8
000050  324945bf          DCW      0x3249,0x45bf
000054  41b33b21          DCW      0x41b3,0x3b21
000058  32492782          DCW      0x3249,0x2782
00005c  1b370de0          DCW      0x1b37,0x0de0
000060  22a3300b          DCW      0x22a3,0x300b
000064  2d4128ba          DCW      0x2d41,0x28ba
000068  22a31b37          DCW      0x22a3,0x1b37
00006c  12bf098e          DCW      0x12bf,0x098e
000070  11a8187e          DCW      0x11a8,0x187e
000074  171214c3          DCW      0x1712,0x14c3
000078  11a80de0          DCW      0x11a8,0x0de0
00007c  098e04df          DCW      0x098e,0x04df
