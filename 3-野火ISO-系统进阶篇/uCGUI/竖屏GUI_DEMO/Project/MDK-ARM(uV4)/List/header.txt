; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\header.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\header.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\Widget\HEADER.c]
                          THUMB

                          AREA ||i.HEADER_AddItem||, CODE, READONLY, ALIGN=2

                  HEADER_AddItem PROC
;;;722    */
;;;723    void HEADER_AddItem(HEADER_Handle hObj, int Width, const char * s, int Align) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;724      if (hObj) {
00000c  2f00              CMP      r7,#0
00000e  d04e              BEQ      |L1.174|
;;;725        HEADER_Obj * pObj;
;;;726        HEADER_COLUMN Column;
;;;727        int Index;
;;;728        WM_LOCK();
000010  f7fffffe          BL       GUI_Lock
;;;729        pObj = HEADER_H2P(hObj);
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4604              MOV      r4,r0
;;;730        if (!Width) {
00001c  b995              CBNZ     r5,|L1.68|
;;;731          const GUI_FONT GUI_UNI_PTR * pFont = GUI_SetFont(pObj->pFont);
00001e  6ce0              LDR      r0,[r4,#0x4c]
000020  f7fffffe          BL       GUI_SetFont
000024  4681              MOV      r9,r0
;;;732          Width = GUI_GetStringDistX(s) + 2 * (pObj->Widget.pEffect->EffectSize + _DefaultBorderH);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       GUI_GetStringDistX
00002c  6a21              LDR      r1,[r4,#0x20]
00002e  6949              LDR      r1,[r1,#0x14]
000030  4a20              LDR      r2,|L1.180|
000032  6812              LDR      r2,[r2,#0]  ; _DefaultBorderH
000034  4411              ADD      r1,r1,r2
000036  2202              MOVS     r2,#2
000038  fb020501          MLA      r5,r2,r1,r0
;;;733          GUI_SetFont(pFont);
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       GUI_SetFont
;;;734        }
000042  bf00              NOP      
                  |L1.68|
;;;735        Column.Width    = Width;
000044  9500              STR      r5,[sp,#0]
;;;736        Column.Align    = Align;
000046  fa0ff088          SXTH     r0,r8
00004a  f8ad0004          STRH     r0,[sp,#4]
;;;737        Column.hDrawObj = 0;
00004e  2000              MOVS     r0,#0
000050  f8ad0006          STRH     r0,[sp,#6]
;;;738        Index = GUI_ARRAY_GetNumItems(&pObj->Columns);
000054  f1040030          ADD      r0,r4,#0x30
000058  f7fffffe          BL       GUI_ARRAY_GetNumItems
00005c  4682              MOV      r10,r0
;;;739        if (GUI_ARRAY_AddItem(&pObj->Columns, &Column, sizeof(HEADER_COLUMN) + strlen(s) + 1) == 0) {
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       strlen
000064  f100090d          ADD      r9,r0,#0xd
000068  464a              MOV      r2,r9
00006a  4669              MOV      r1,sp
00006c  f1040030          ADD      r0,r4,#0x30
000070  f7fffffe          BL       GUI_ARRAY_AddItem
000074  b9c0              CBNZ     r0,|L1.168|
;;;740          HEADER_COLUMN * pColumn;
;;;741          pObj = HEADER_H2P(hObj);
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       GUI_ALLOC_h2p
00007c  4604              MOV      r4,r0
;;;742          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
00007e  4651              MOV      r1,r10
000080  f1040030          ADD      r0,r4,#0x30
000084  f7fffffe          BL       GUI_ARRAY_GetpItem
000088  4681              MOV      r9,r0
;;;743          strcpy(pColumn->acText, s);
00008a  4631              MOV      r1,r6
00008c  f1090008          ADD      r0,r9,#8
000090  f7fffffe          BL       strcpy
;;;744          WM_InvalidateWindow(hObj);
000094  4638              MOV      r0,r7
000096  f7fffffe          BL       WM_InvalidateWindow
;;;745          WM_InvalidateWindow(WM_GetParent(hObj));
00009a  4638              MOV      r0,r7
00009c  f7fffffe          BL       WM_GetParent
0000a0  4683              MOV      r11,r0
0000a2  f7fffffe          BL       WM_InvalidateWindow
;;;746        }
0000a6  bf00              NOP      
                  |L1.168|
;;;747        WM_UNLOCK();
0000a8  f7fffffe          BL       GUI_Unlock
;;;748      }
0000ac  bf00              NOP      
                  |L1.174|
;;;749    }
0000ae  e8bd8ffe          POP      {r1-r11,pc}
;;;750    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L1.180|
                          DCD      _DefaultBorderH

                          AREA ||i.HEADER_Callback||, CODE, READONLY, ALIGN=1

                  HEADER_Callback PROC
;;;440    */
;;;441    void HEADER_Callback (WM_MESSAGE *pMsg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;442      HEADER_Handle hObj;
;;;443      HEADER_Obj * pObj;
;;;444      hObj = pMsg->hWin;
000004  f9b45004          LDRSH    r5,[r4,#4]
;;;445      /* Let widget handle the standard messages */
;;;446      if (WIDGET_HandleActive(hObj, pMsg) == 0) {
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       WIDGET_HandleActive
000010  b900              CBNZ     r0,|L2.20|
                  |L2.18|
;;;447        return;
;;;448      }
;;;449      WM_LOCK();
;;;450      pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
;;;451      switch (pMsg->MsgId) {
;;;452      case WM_PAINT:
;;;453        _Paint(pObj);
;;;454        break;
;;;455      case WM_PID_STATE_CHANGED:
;;;456        _OnPidStateChange(hObj, pObj, pMsg);
;;;457        break;
;;;458    #if (HEADER_SUPPORT_DRAG)
;;;459      case WM_TOUCH:
;;;460        _OnTouch(hObj, pObj, pMsg);
;;;461        break;
;;;462    #endif
;;;463    #if (HEADER_SUPPORT_DRAG & GUI_SUPPORT_MOUSE)
;;;464      case WM_MOUSEOVER:
;;;465        _OnMouseOver(hObj, pObj, pMsg);
;;;466        break;
;;;467    #endif
;;;468      case WM_DELETE:
;;;469        _FreeAttached(pObj); /* No return here ... WM_DefaultProc needs to be called */
;;;470      default:
;;;471        WM_DefaultProc(pMsg);
;;;472      }
;;;473      WM_UNLOCK();
;;;474    }
000012  bd70              POP      {r4-r6,pc}
                  |L2.20|
000014  f7fffffe          BL       GUI_Lock
000018  4628              MOV      r0,r5                 ;450
00001a  f7fffffe          BL       GUI_ALLOC_h2p
00001e  4606              MOV      r6,r0                 ;450
000020  6820              LDR      r0,[r4,#0]            ;451
000022  280b              CMP      r0,#0xb               ;451
000024  d016              BEQ      |L2.84|
000026  280c              CMP      r0,#0xc               ;451
000028  d00e              BEQ      |L2.72|
00002a  280f              CMP      r0,#0xf               ;451
00002c  d002              BEQ      |L2.52|
00002e  2811              CMP      r0,#0x11              ;451
000030  d114              BNE      |L2.92|
000032  e003              B        |L2.60|
                  |L2.52|
000034  4630              MOV      r0,r6                 ;453
000036  f7fffffe          BL       _Paint
00003a  e013              B        |L2.100|
                  |L2.60|
00003c  4622              MOV      r2,r4                 ;456
00003e  4631              MOV      r1,r6                 ;456
000040  4628              MOV      r0,r5                 ;456
000042  f7fffffe          BL       _OnPidStateChange
000046  e00d              B        |L2.100|
                  |L2.72|
000048  4622              MOV      r2,r4                 ;460
00004a  4631              MOV      r1,r6                 ;460
00004c  4628              MOV      r0,r5                 ;460
00004e  f7fffffe          BL       _OnTouch
000052  e007              B        |L2.100|
                  |L2.84|
000054  4630              MOV      r0,r6                 ;469
000056  f7fffffe          BL       _FreeAttached
00005a  bf00              NOP                            ;470
                  |L2.92|
00005c  4620              MOV      r0,r4                 ;471
00005e  f7fffffe          BL       WM_DefaultProc
000062  bf00              NOP                            ;451
                  |L2.100|
000064  bf00              NOP                            ;454
000066  f7fffffe          BL       GUI_Unlock
00006a  bf00              NOP      
00006c  e7d1              B        |L2.18|
;;;475    
                          ENDP


                          AREA ||i.HEADER_Create||, CODE, READONLY, ALIGN=1

                  HEADER_Create PROC
;;;485    */
;;;486    HEADER_Handle HEADER_Create(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int ExFlags) {
000000  e92d5fff          PUSH     {r0-r12,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000010  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;487      return HEADER_CreateEx(x0, y0, xsize, ysize, hParent, Flags, ExFlags, Id);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  e88d0d00          STM      sp,{r8,r10,r11}
000020  f8cd900c          STR      r9,[sp,#0xc]
000024  f7fffffe          BL       HEADER_CreateEx
;;;488    }
000028  b004              ADD      sp,sp,#0x10
00002a  e8bd9ff0          POP      {r4-r12,pc}
;;;489    
                          ENDP


                          AREA ||i.HEADER_CreateEx||, CODE, READONLY, ALIGN=2

                  HEADER_CreateEx PROC
;;;493    */
;;;494    HEADER_Handle HEADER_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;495                                  int WinFlags, int ExFlags, int Id)
;;;496    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;497      HEADER_Handle hObj;
;;;498      GUI_USE_PARA(ExFlags);
000010  9810              LDR      r0,[sp,#0x40]
000012  9010              STR      r0,[sp,#0x40]
;;;499      /* Create the window */
;;;500      WM_LOCK();
000014  f7fffffe          BL       GUI_Lock
;;;501      if ((xsize == 0) && (x0 == 0) && (y0 == 0)) {
000018  f1b90f00          CMP      r9,#0
00001c  d113              BNE      |L4.70|
00001e  b997              CBNZ     r7,|L4.70|
000020  f1b80f00          CMP      r8,#0
000024  d10f              BNE      |L4.70|
;;;502        GUI_RECT Rect;
;;;503        WM_GetInsideRectEx(hParent, &Rect);
000026  a902              ADD      r1,sp,#8
000028  4650              MOV      r0,r10
00002a  f7fffffe          BL       WM_GetInsideRectEx
;;;504        xsize = Rect.x1 - Rect.x0 + 1;
00002e  f9bd000c          LDRSH    r0,[sp,#0xc]
000032  f9bd1008          LDRSH    r1,[sp,#8]
000036  1a40              SUBS     r0,r0,r1
000038  f1000901          ADD      r9,r0,#1
;;;505        x0    = Rect.x0;
00003c  f9bd7008          LDRSH    r7,[sp,#8]
;;;506        y0    = Rect.y0;
000040  f9bd800a          LDRSH    r8,[sp,#0xa]
;;;507      }
000044  bf00              NOP      
                  |L4.70|
;;;508      if (ysize == 0) {
000046  b985              CBNZ     r5,|L4.106|
;;;509        const WIDGET_EFFECT* pEffect = WIDGET_GetDefaultEffect();
000048  f7fffffe          BL       WIDGET_GetDefaultEffect
00004c  4604              MOV      r4,r0
;;;510        ysize  = GUI_GetYDistOfFont(_pDefaultFont);
00004e  4820              LDR      r0,|L4.208|
000050  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
000052  f7fffffe          BL       GUI_GetYDistOfFont
000056  4605              MOV      r5,r0
;;;511        ysize += 2 * _DefaultBorderV;
000058  481e              LDR      r0,|L4.212|
00005a  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
00005c  2102              MOVS     r1,#2
00005e  fb015500          MLA      r5,r1,r0,r5
;;;512        ysize += 2 * (unsigned)pEffect->EffectSize;
000062  6960              LDR      r0,[r4,#0x14]
000064  fb015500          MLA      r5,r1,r0,r5
;;;513      }
000068  bf00              NOP      
                  |L4.106|
;;;514      WinFlags |= WM_CF_ANCHOR_LEFT | WM_CF_ANCHOR_RIGHT;
00006a  f44b7b20          ORR      r11,r11,#0x280
;;;515      hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &HEADER_Callback,
00006e  2134              MOVS     r1,#0x34
000070  4a19              LDR      r2,|L4.216|
000072  fa1ff08b          UXTH     r0,r11
000076  462b              MOV      r3,r5
000078  e9cda000          STRD     r10,r0,[sp,#0]
00007c  e9cd2102          STRD     r2,r1,[sp,#8]
000080  464a              MOV      r2,r9
000082  4641              MOV      r1,r8
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       WM_CreateWindowAsChild
00008a  4606              MOV      r6,r0
;;;516                                    sizeof(HEADER_Obj) - sizeof(WM_Obj));
;;;517      if (hObj) {
00008c  b1d6              CBZ      r6,|L4.196|
;;;518        HEADER_Obj * pObj;
;;;519        pObj = (HEADER_Obj *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       GUI_ALLOC_h2p
000094  4604              MOV      r4,r0
;;;520        /* Init sub-classes */
;;;521        GUI_ARRAY_CREATE(&pObj->Columns);
;;;522        /* init widget specific variables */
;;;523        WIDGET__Init(&pObj->Widget, Id, 0);
000096  2200              MOVS     r2,#0
000098  4620              MOV      r0,r4
00009a  9911              LDR      r1,[sp,#0x44]
00009c  f7fffffe          BL       WIDGET__Init
;;;524        /* init member variables */
;;;525        HEADER_INIT_ID(pObj);
;;;526        pObj->BkColor     = _DefaultBkColor;
0000a0  480e              LDR      r0,|L4.220|
0000a2  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
0000a4  62a0              STR      r0,[r4,#0x28]
;;;527        pObj->TextColor   = _DefaultTextColor;
0000a6  480e              LDR      r0,|L4.224|
0000a8  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
0000aa  62e0              STR      r0,[r4,#0x2c]
;;;528        pObj->pFont       = _pDefaultFont;
0000ac  4808              LDR      r0,|L4.208|
0000ae  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
0000b0  64e0              STR      r0,[r4,#0x4c]
;;;529        pObj->CapturePosX = -1;
0000b2  f04f30ff          MOV      r0,#0xffffffff
0000b6  6360              STR      r0,[r4,#0x34]
;;;530        pObj->CaptureItem = -1;
0000b8  63a0              STR      r0,[r4,#0x38]
;;;531        pObj->ScrollPos   = 0;
0000ba  2000              MOVS     r0,#0
0000bc  63e0              STR      r0,[r4,#0x3c]
;;;532        pObj->DirIndicatorColumn = -1;
0000be  1e40              SUBS     r0,r0,#1
0000c0  6460              STR      r0,[r4,#0x44]
;;;533      } else {
0000c2  bf00              NOP      
                  |L4.196|
;;;534        GUI_DEBUG_ERROROUT_IF(hObj==0, "HEADER_Create failed")
;;;535      }
;;;536      WM_UNLOCK();
0000c4  f7fffffe          BL       GUI_Unlock
;;;537      return hObj;
0000c8  4630              MOV      r0,r6
;;;538    }
0000ca  b004              ADD      sp,sp,#0x10
0000cc  e8bd9ff0          POP      {r4-r12,pc}
;;;539    
                          ENDP

                  |L4.208|
                          DCD      _pDefaultFont
                  |L4.212|
                          DCD      _DefaultBorderV
                  |L4.216|
                          DCD      HEADER_Callback
                  |L4.220|
                          DCD      _DefaultBkColor
                  |L4.224|
                          DCD      _DefaultTextColor

                          AREA ||i.HEADER_DeleteItem||, CODE, READONLY, ALIGN=1

                  HEADER_DeleteItem PROC
;;;754    */
;;;755    void HEADER_DeleteItem(HEADER_Handle hObj, unsigned Index) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;756      if (hObj) {
000008  b1e4              CBZ      r4,|L5.68|
;;;757        HEADER_Obj* pObj;
;;;758        WM_LOCK();
00000a  f7fffffe          BL       GUI_Lock
;;;759        pObj = HEADER_H2P(hObj);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4606              MOV      r6,r0
;;;760        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000016  f1060030          ADD      r0,r6,#0x30
00001a  f7fffffe          BL       GUI_ARRAY_GetNumItems
00001e  42a8              CMP      r0,r5
000020  d90d              BLS      |L5.62|
;;;761          GUI_ARRAY_DeleteItem(&pObj->Columns, Index);
000022  4629              MOV      r1,r5
000024  f1060030          ADD      r0,r6,#0x30
000028  f7fffffe          BL       GUI_ARRAY_DeleteItem
;;;762          WM_InvalidateWindow(hObj);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       WM_InvalidateWindow
;;;763          WM_InvalidateWindow(WM_GetParent(hObj));
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       WM_GetParent
000038  4607              MOV      r7,r0
00003a  f7fffffe          BL       WM_InvalidateWindow
                  |L5.62|
;;;764        }
;;;765        WM_UNLOCK();
00003e  f7fffffe          BL       GUI_Unlock
;;;766      }
000042  bf00              NOP      
                  |L5.68|
;;;767    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;768    
                          ENDP


                          AREA ||i.HEADER_GetDefaultBkColor||, CODE, READONLY, ALIGN=2

                  HEADER_GetDefaultBkColor PROC
;;;610    const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
;;;611    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
000000  4801              LDR      r0,|L6.8|
000002  6800              LDR      r0,[r0,#0]  ; _DefaultBkColor
000004  4770              BX       lr
;;;612    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      _DefaultBkColor

                          AREA ||i.HEADER_GetDefaultBorderH||, CODE, READONLY, ALIGN=2

                  HEADER_GetDefaultBorderH PROC
;;;612    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
;;;613    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
000000  4801              LDR      r0,|L7.8|
000002  6800              LDR      r0,[r0,#0]  ; _DefaultBorderH
000004  4770              BX       lr
;;;614    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      _DefaultBorderH

                          AREA ||i.HEADER_GetDefaultBorderV||, CODE, READONLY, ALIGN=2

                  HEADER_GetDefaultBorderV PROC
;;;613    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
;;;614    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
000000  4801              LDR      r0,|L8.8|
000002  6800              LDR      r0,[r0,#0]  ; _DefaultBorderV
000004  4770              BX       lr
;;;615    const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      _DefaultBorderV

                          AREA ||i.HEADER_GetDefaultCursor||, CODE, READONLY, ALIGN=2

                  HEADER_GetDefaultCursor PROC
;;;609    */
;;;610    const GUI_CURSOR GUI_UNI_PTR *  HEADER_GetDefaultCursor(void)    { return _pDefaultCursor; }
000000  4801              LDR      r0,|L9.8|
000002  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
000004  4770              BX       lr
;;;611    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      _pDefaultCursor

                          AREA ||i.HEADER_GetDefaultFont||, CODE, READONLY, ALIGN=2

                  HEADER_GetDefaultFont PROC
;;;614    int                HEADER_GetDefaultBorderV(void)   { return _DefaultBorderV; }
;;;615    const GUI_FONT GUI_UNI_PTR *    HEADER_GetDefaultFont(void)      { return _pDefaultFont; }
000000  4801              LDR      r0,|L10.8|
000002  6800              LDR      r0,[r0,#0]  ; _pDefaultFont
000004  4770              BX       lr
;;;616    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      _pDefaultFont

                          AREA ||i.HEADER_GetDefaultTextColor||, CODE, READONLY, ALIGN=2

                  HEADER_GetDefaultTextColor PROC
;;;611    GUI_COLOR          HEADER_GetDefaultBkColor(void)   { return _DefaultBkColor; }
;;;612    GUI_COLOR          HEADER_GetDefaultTextColor(void) { return _DefaultTextColor; }
000000  4801              LDR      r0,|L11.8|
000002  6800              LDR      r0,[r0,#0]  ; _DefaultTextColor
000004  4770              BX       lr
;;;613    int                HEADER_GetDefaultBorderH(void)   { return _DefaultBorderH; }
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      _DefaultTextColor

                          AREA ||i.HEADER_GetHeight||, CODE, READONLY, ALIGN=1

                  HEADER_GetHeight PROC
;;;820    */
;;;821    int HEADER_GetHeight(HEADER_Handle hObj) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4604              MOV      r4,r0
;;;822      int Height = 0;
000004  2500              MOVS     r5,#0
;;;823      if (hObj) {
000006  b19c              CBZ      r4,|L12.48|
;;;824        GUI_RECT Rect;
;;;825        WM_GetClientRectEx(hObj, &Rect);
000008  4669              MOV      r1,sp
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       WM_GetClientRectEx
;;;826        GUI_MoveRect(&Rect, -Rect.x0, -Rect.y0);
000010  f9bd0002          LDRSH    r0,[sp,#2]
000014  4242              RSBS     r2,r0,#0
000016  f9bd0000          LDRSH    r0,[sp,#0]
00001a  4241              RSBS     r1,r0,#0
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       GUI_MoveRect
;;;827        Height = Rect.y1 - Rect.y0 + 1;
000022  f9bd0006          LDRSH    r0,[sp,#6]
000026  f9bd1002          LDRSH    r1,[sp,#2]
00002a  1a40              SUBS     r0,r0,r1
00002c  1c45              ADDS     r5,r0,#1
;;;828      }
00002e  bf00              NOP      
                  |L12.48|
;;;829      return Height;
000030  4628              MOV      r0,r5
;;;830    }
000032  bd7c              POP      {r2-r6,pc}
;;;831    
                          ENDP


                          AREA ||i.HEADER_GetItemWidth||, CODE, READONLY, ALIGN=1

                  HEADER_GetItemWidth PROC
;;;835    */
;;;836    int HEADER_GetItemWidth(HEADER_Handle hObj, unsigned int Index) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;837      int Width = 0;
000008  2700              MOVS     r7,#0
;;;838      if (hObj) {
00000a  b1bc              CBZ      r4,|L13.60|
;;;839        HEADER_Obj * pObj;
;;;840        WM_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;841        pObj = HEADER_H2P(hObj);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4606              MOV      r6,r0
;;;842        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000018  f1060030          ADD      r0,r6,#0x30
00001c  f7fffffe          BL       GUI_ARRAY_GetNumItems
000020  42a8              CMP      r0,r5
000022  d308              BCC      |L13.54|
;;;843          HEADER_COLUMN * pColumn;
;;;844          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000024  4629              MOV      r1,r5
000026  f1060030          ADD      r0,r6,#0x30
00002a  f7fffffe          BL       GUI_ARRAY_GetpItem
00002e  4680              MOV      r8,r0
;;;845          Width = pColumn->Width;
000030  f8d87000          LDR      r7,[r8,#0]
;;;846        }
000034  bf00              NOP      
                  |L13.54|
;;;847        WM_UNLOCK();
000036  f7fffffe          BL       GUI_Unlock
;;;848      }
00003a  bf00              NOP      
                  |L13.60|
;;;849      return Width;
00003c  4638              MOV      r0,r7
;;;850    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;851    
                          ENDP


                          AREA ||i.HEADER_GetNumItems||, CODE, READONLY, ALIGN=1

                  HEADER_GetNumItems PROC
;;;855    */
;;;856    int  HEADER_GetNumItems(HEADER_Handle hObj) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;857      int NumCols = 0;
000004  2500              MOVS     r5,#0
;;;858      if (hObj) {
000006  b16c              CBZ      r4,|L14.36|
;;;859        HEADER_Obj * pObj;
;;;860        WM_LOCK();
000008  f7fffffe          BL       GUI_Lock
;;;861        pObj = HEADER_H2P(hObj);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4606              MOV      r6,r0
;;;862        NumCols = GUI_ARRAY_GetNumItems(&pObj->Columns);
000014  f1060030          ADD      r0,r6,#0x30
000018  f7fffffe          BL       GUI_ARRAY_GetNumItems
00001c  4605              MOV      r5,r0
;;;863        WM_UNLOCK();
00001e  f7fffffe          BL       GUI_Unlock
;;;864      }
000022  bf00              NOP      
                  |L14.36|
;;;865      return NumCols;
000024  4628              MOV      r0,r5
;;;866    }
000026  bd70              POP      {r4-r6,pc}
;;;867    
                          ENDP


                          AREA ||i.HEADER_SetBkColor||, CODE, READONLY, ALIGN=1

                  HEADER_SetBkColor PROC
;;;670    */
;;;671    void HEADER_SetBkColor(HEADER_Handle hObj, GUI_COLOR Color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;672      if (hObj) {
000006  b164              CBZ      r4,|L15.34|
;;;673        HEADER_Obj * pObj;
;;;674        WM_LOCK();
000008  f7fffffe          BL       GUI_Lock
;;;675        pObj = HEADER_H2P(hObj);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4606              MOV      r6,r0
;;;676        pObj->BkColor = Color;
000014  62b5              STR      r5,[r6,#0x28]
;;;677        WM_InvalidateWindow(hObj);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       WM_InvalidateWindow
;;;678        WM_UNLOCK();
00001c  f7fffffe          BL       GUI_Unlock
;;;679      }
000020  bf00              NOP      
                  |L15.34|
;;;680    }
000022  bd70              POP      {r4-r6,pc}
;;;681    
                          ENDP


                          AREA ||i.HEADER_SetDefaultBkColor||, CODE, READONLY, ALIGN=2

                  HEADER_SetDefaultBkColor PROC
;;;559    */
;;;560    GUI_COLOR HEADER_SetDefaultBkColor(GUI_COLOR Color) {
000000  4601              MOV      r1,r0
;;;561      GUI_COLOR OldColor = _DefaultBkColor;
000002  4a02              LDR      r2,|L16.12|
000004  6810              LDR      r0,[r2,#0]  ; _DefaultBkColor
;;;562      _DefaultBkColor = Color;
000006  6011              STR      r1,[r2,#0]  ; _DefaultBkColor
;;;563      return OldColor;
;;;564    }
000008  4770              BX       lr
;;;565    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      _DefaultBkColor

                          AREA ||i.HEADER_SetDefaultBorderH||, CODE, READONLY, ALIGN=2

                  HEADER_SetDefaultBorderH PROC
;;;579    */
;;;580    int HEADER_SetDefaultBorderH(int Spacing) {
000000  4601              MOV      r1,r0
;;;581      int OldSpacing = _DefaultBorderH;
000002  4a02              LDR      r2,|L17.12|
000004  6810              LDR      r0,[r2,#0]  ; _DefaultBorderH
;;;582      _DefaultBorderH = Spacing;
000006  6011              STR      r1,[r2,#0]  ; _DefaultBorderH
;;;583      return OldSpacing;
;;;584    }
000008  4770              BX       lr
;;;585    
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      _DefaultBorderH

                          AREA ||i.HEADER_SetDefaultBorderV||, CODE, READONLY, ALIGN=2

                  HEADER_SetDefaultBorderV PROC
;;;589    */
;;;590    int HEADER_SetDefaultBorderV(int Spacing) {
000000  4601              MOV      r1,r0
;;;591      int OldSpacing = _DefaultBorderV;
000002  4a02              LDR      r2,|L18.12|
000004  6810              LDR      r0,[r2,#0]  ; _DefaultBorderV
;;;592      _DefaultBorderV = Spacing;
000006  6011              STR      r1,[r2,#0]  ; _DefaultBorderV
;;;593      return OldSpacing;
;;;594    }
000008  4770              BX       lr
;;;595    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      _DefaultBorderV

                          AREA ||i.HEADER_SetDefaultCursor||, CODE, READONLY, ALIGN=2

                  HEADER_SetDefaultCursor PROC
;;;549    */
;;;550    const GUI_CURSOR GUI_UNI_PTR * HEADER_SetDefaultCursor(const GUI_CURSOR * pCursor) {
000000  4601              MOV      r1,r0
;;;551      const GUI_CURSOR GUI_UNI_PTR * pOldCursor = _pDefaultCursor;
000002  4a02              LDR      r2,|L19.12|
000004  6810              LDR      r0,[r2,#0]  ; _pDefaultCursor
;;;552      _pDefaultCursor = pCursor;
000006  6011              STR      r1,[r2,#0]  ; _pDefaultCursor
;;;553      return pOldCursor;
;;;554    }
000008  4770              BX       lr
;;;555    
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      _pDefaultCursor

                          AREA ||i.HEADER_SetDefaultFont||, CODE, READONLY, ALIGN=2

                  HEADER_SetDefaultFont PROC
;;;599    */
;;;600    const GUI_FONT GUI_UNI_PTR * HEADER_SetDefaultFont(const GUI_FONT GUI_UNI_PTR * pFont) {
000000  4601              MOV      r1,r0
;;;601      const GUI_FONT GUI_UNI_PTR * pOldFont = _pDefaultFont;
000002  4a02              LDR      r2,|L20.12|
000004  6810              LDR      r0,[r2,#0]  ; _pDefaultFont
;;;602      _pDefaultFont = pFont;
000006  6011              STR      r1,[r2,#0]  ; _pDefaultFont
;;;603      return pOldFont;
;;;604    }
000008  4770              BX       lr
;;;605    
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      _pDefaultFont

                          AREA ||i.HEADER_SetDefaultTextColor||, CODE, READONLY, ALIGN=2

                  HEADER_SetDefaultTextColor PROC
;;;569    */
;;;570    GUI_COLOR HEADER_SetDefaultTextColor(GUI_COLOR Color) {
000000  4601              MOV      r1,r0
;;;571      GUI_COLOR OldColor = _DefaultTextColor;
000002  4a02              LDR      r2,|L21.12|
000004  6810              LDR      r0,[r2,#0]  ; _DefaultTextColor
;;;572      _DefaultTextColor = Color;
000006  6011              STR      r1,[r2,#0]  ; _DefaultTextColor
;;;573      return OldColor;
;;;574    }
000008  4770              BX       lr
;;;575    
                          ENDP

00000a  0000              DCW      0x0000
                  |L21.12|
                          DCD      _DefaultTextColor

                          AREA ||i.HEADER_SetDirIndicator||, CODE, READONLY, ALIGN=1

                  HEADER_SetDirIndicator PROC
;;;871    */
;;;872    void HEADER_SetDirIndicator(HEADER_Handle hObj, int Column, int Reverse) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;873      if (hObj) {
00000a  b19f              CBZ      r7,|L22.52|
;;;874        HEADER_Obj * pObj;
;;;875        WM_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;876        pObj = HEADER_H2P(hObj);
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4604              MOV      r4,r0
;;;877        if ((pObj->DirIndicatorColumn != Column) || (pObj->DirIndicatorReverse != Reverse)) {
000018  6c60              LDR      r0,[r4,#0x44]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L22.36|
00001e  6ca0              LDR      r0,[r4,#0x48]
000020  42b0              CMP      r0,r6
000022  d004              BEQ      |L22.46|
                  |L22.36|
;;;878          pObj->DirIndicatorColumn = Column;
000024  6465              STR      r5,[r4,#0x44]
;;;879          pObj->DirIndicatorReverse = Reverse;
000026  64a6              STR      r6,[r4,#0x48]
;;;880          WM_InvalidateWindow(hObj);
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       WM_InvalidateWindow
                  |L22.46|
;;;881        }
;;;882        WM_UNLOCK();
00002e  f7fffffe          BL       GUI_Unlock
;;;883      }
000032  bf00              NOP      
                  |L22.52|
;;;884    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;885    
                          ENDP


                          AREA ||i.HEADER_SetFont||, CODE, READONLY, ALIGN=1

                  HEADER_SetFont PROC
;;;626    */
;;;627    void HEADER_SetFont(HEADER_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;628      if (hObj) {
000008  b1c5              CBZ      r5,|L23.60|
;;;629        HEADER_Obj * pObj;
;;;630        WM_LOCK();
00000a  f7fffffe          BL       GUI_Lock
;;;631        pObj = HEADER_H2P(hObj);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4606              MOV      r6,r0
;;;632        pObj->pFont = pFont;
000016  64f4              STR      r4,[r6,#0x4c]
;;;633        HEADER_SetHeight(hObj, GUI_GetYDistOfFont(pFont) + 2 * HEADER_BORDER_V_DEFAULT + 2 * pObj->Widget.pEffect->EffectSize);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       GUI_GetYDistOfFont
00001e  6a31              LDR      r1,[r6,#0x20]
000020  6949              LDR      r1,[r1,#0x14]
000022  2202              MOVS     r2,#2
000024  fb020701          MLA      r7,r2,r1,r0
000028  4639              MOV      r1,r7
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       HEADER_SetHeight
;;;634        WM_InvalidateWindow(hObj);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       WM_InvalidateWindow
;;;635        WM_UNLOCK();
000036  f7fffffe          BL       GUI_Unlock
;;;636      }
00003a  bf00              NOP      
                  |L23.60|
;;;637    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP


                          AREA ||i.HEADER_SetHeight||, CODE, READONLY, ALIGN=1

                  HEADER_SetHeight PROC
;;;642    */
;;;643    void HEADER_SetHeight(HEADER_Handle hObj, int Height) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;644      if (hObj) {
000006  b1a4              CBZ      r4,|L24.50|
;;;645        GUI_RECT Rect;
;;;646        WM_GetClientRectEx(hObj, &Rect);
000008  4669              MOV      r1,sp
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       WM_GetClientRectEx
;;;647        WM_SetSize(hObj, Rect.x1 - Rect.x0 + 1, Height);
000010  f9bd0004          LDRSH    r0,[sp,#4]
000014  f9bd2000          LDRSH    r2,[sp,#0]
000018  1a80              SUBS     r0,r0,r2
00001a  1c41              ADDS     r1,r0,#1
00001c  462a              MOV      r2,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       WM_SetSize
;;;648        WM_InvalidateWindow(WM_GetParent(hObj));
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       WM_GetParent
00002a  4606              MOV      r6,r0
00002c  f7fffffe          BL       WM_InvalidateWindow
;;;649      }
000030  bf00              NOP      
                  |L24.50|
;;;650    }
000032  bd7c              POP      {r2-r6,pc}
;;;651    
                          ENDP


                          AREA ||i.HEADER_SetItemText||, CODE, READONLY, ALIGN=1

                  HEADER_SetItemText PROC
;;;772    */
;;;773    void HEADER_SetItemText(HEADER_Handle hObj, unsigned int Index, const char* s) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;774      if (hObj) {
00000a  b31d              CBZ      r5,|L25.84|
;;;775        HEADER_Obj* pObj;
;;;776        WM_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;777        pObj = HEADER_H2P(hObj);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4607              MOV      r7,r0
;;;778        if (Index < GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000018  f1070030          ADD      r0,r7,#0x30
00001c  f7fffffe          BL       GUI_ARRAY_GetNumItems
000020  42b0              CMP      r0,r6
000022  d914              BLS      |L25.78|
;;;779          HEADER_COLUMN* pColumn;
;;;780          pColumn = (HEADER_COLUMN*)GUI_ARRAY_ResizeItem(&pObj->Columns, Index, sizeof(HEADER_COLUMN) + strlen(s));
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       strlen
00002a  f100090c          ADD      r9,r0,#0xc
00002e  464a              MOV      r2,r9
000030  4631              MOV      r1,r6
000032  f1070030          ADD      r0,r7,#0x30
000036  f7fffffe          BL       GUI_ARRAY_ResizeItem
00003a  4680              MOV      r8,r0
;;;781          if (pColumn) {
00003c  f1b80f00          CMP      r8,#0
000040  d004              BEQ      |L25.76|
;;;782            strcpy(pColumn->acText, s);
000042  4621              MOV      r1,r4
000044  f1080008          ADD      r0,r8,#8
000048  f7fffffe          BL       strcpy
                  |L25.76|
;;;783          }
;;;784        }
00004c  bf00              NOP      
                  |L25.78|
;;;785        WM_UNLOCK();
00004e  f7fffffe          BL       GUI_Unlock
;;;786      }
000052  bf00              NOP      
                  |L25.84|
;;;787    }
000054  e8bd87f0          POP      {r4-r10,pc}
;;;788    
                          ENDP


                          AREA ||i.HEADER_SetItemWidth||, CODE, READONLY, ALIGN=1

                  HEADER_SetItemWidth PROC
;;;792    */
;;;793    void HEADER_SetItemWidth(HEADER_Handle hObj, unsigned int Index, int Width) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;794      if (hObj && (Width >= 0)) {
00000a  b3a4              CBZ      r4,|L26.118|
00000c  2d00              CMP      r5,#0
00000e  db32              BLT      |L26.118|
;;;795        HEADER_Obj * pObj;
;;;796        WM_LOCK();
000010  f7fffffe          BL       GUI_Lock
;;;797        pObj = HEADER_H2P(hObj);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4607              MOV      r7,r0
;;;798        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
00001c  f1070030          ADD      r0,r7,#0x30
000020  f7fffffe          BL       GUI_ARRAY_GetNumItems
000024  42b0              CMP      r0,r6
000026  d323              BCC      |L26.112|
;;;799          HEADER_COLUMN * pColumn;
;;;800          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000028  4631              MOV      r1,r6
00002a  f1070030          ADD      r0,r7,#0x30
00002e  f7fffffe          BL       GUI_ARRAY_GetpItem
000032  4680              MOV      r8,r0
;;;801          if (pColumn) {
000034  f1b80f00          CMP      r8,#0
000038  d019              BEQ      |L26.110|
;;;802            WM_MESSAGE Msg;
;;;803            pColumn->Width = Width;
00003a  f8c85000          STR      r5,[r8,#0]
;;;804            Msg.hWin  = WM_GetParent(hObj);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       WM_GetParent
000044  f8ad0004          STRH     r0,[sp,#4]
;;;805            Msg.MsgId = WM_NOTIFY_CLIENTCHANGE;
000048  2025              MOVS     r0,#0x25
00004a  9000              STR      r0,[sp,#0]
;;;806            Msg.hWinSrc = hObj;
00004c  f8ad4006          STRH     r4,[sp,#6]
;;;807            WM_InvalidateWindow(hObj);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       WM_InvalidateWindow
;;;808            WM__SendMessage(Msg.hWin, &Msg);
000056  f9bd0004          LDRSH    r0,[sp,#4]
00005a  4669              MOV      r1,sp
00005c  f7fffffe          BL       WM__SendMessage
;;;809            //WM__SendMsgNoData(WM_GetParent(hObj), WM_NOTIFY_CLIENTCHANGE);
;;;810            WM_InvalidateWindow(WM_GetParent(hObj));
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       WM_GetParent
000066  4681              MOV      r9,r0
000068  f7fffffe          BL       WM_InvalidateWindow
;;;811          }
00006c  bf00              NOP      
                  |L26.110|
;;;812        }
00006e  bf00              NOP      
                  |L26.112|
;;;813        WM_UNLOCK();
000070  f7fffffe          BL       GUI_Unlock
;;;814      }
000074  bf00              NOP      
                  |L26.118|
;;;815    }
000076  e8bd83fe          POP      {r1-r9,pc}
;;;816    
                          ENDP


                          AREA ||i.HEADER_SetScrollPos||, CODE, READONLY, ALIGN=1

                  HEADER_SetScrollPos PROC
;;;704    */
;;;705    void HEADER_SetScrollPos(HEADER_Handle hObj, int ScrollPos) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;706      if (hObj && (ScrollPos >= 0)) {
000008  b1bd              CBZ      r5,|L27.58|
00000a  2c00              CMP      r4,#0
00000c  db15              BLT      |L27.58|
;;;707        HEADER_Obj* pObj;
;;;708        WM_LOCK();
00000e  f7fffffe          BL       GUI_Lock
;;;709        pObj = HEADER_H2P(hObj);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       GUI_ALLOC_h2p
000018  4606              MOV      r6,r0
;;;710        if (ScrollPos != pObj->ScrollPos) {
00001a  6bf0              LDR      r0,[r6,#0x3c]
00001c  42a0              CMP      r0,r4
00001e  d009              BEQ      |L27.52|
;;;711          pObj->ScrollPos = ScrollPos;
000020  63f4              STR      r4,[r6,#0x3c]
;;;712          WM_Invalidate(hObj);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       WM_InvalidateWindow
;;;713          WM_InvalidateWindow(WM_GetParent(hObj));
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       WM_GetParent
00002e  4607              MOV      r7,r0
000030  f7fffffe          BL       WM_InvalidateWindow
                  |L27.52|
;;;714        }
;;;715        WM_UNLOCK();
000034  f7fffffe          BL       GUI_Unlock
;;;716      }
000038  bf00              NOP      
                  |L27.58|
;;;717    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;718    
                          ENDP


                          AREA ||i.HEADER_SetTextAlign||, CODE, READONLY, ALIGN=1

                  HEADER_SetTextAlign PROC
;;;685    */
;;;686    void HEADER_SetTextAlign(HEADER_Handle hObj, unsigned int Index, int Align) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;687      if (hObj) {
00000a  b1dc              CBZ      r4,|L28.68|
;;;688        HEADER_Obj * pObj;
;;;689        WM_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;690        pObj = HEADER_H2P(hObj);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4607              MOV      r7,r0
;;;691        if (Index <= GUI_ARRAY_GetNumItems(&pObj->Columns)) {
000018  f1070030          ADD      r0,r7,#0x30
00001c  f7fffffe          BL       GUI_ARRAY_GetNumItems
000020  42a8              CMP      r0,r5
000022  d30c              BCC      |L28.62|
;;;692          HEADER_COLUMN * pColumn;
;;;693          pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000024  4629              MOV      r1,r5
000026  f1070030          ADD      r0,r7,#0x30
00002a  f7fffffe          BL       GUI_ARRAY_GetpItem
00002e  4680              MOV      r8,r0
;;;694          pColumn->Align = Align;
000030  b230              SXTH     r0,r6
000032  f8a80004          STRH     r0,[r8,#4]
;;;695          WM_InvalidateWindow(hObj);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       WM_InvalidateWindow
;;;696        }
00003c  bf00              NOP      
                  |L28.62|
;;;697        WM_UNLOCK();
00003e  f7fffffe          BL       GUI_Unlock
;;;698      }
000042  bf00              NOP      
                  |L28.68|
;;;699    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;700    
                          ENDP


                          AREA ||i.HEADER_SetTextColor||, CODE, READONLY, ALIGN=1

                  HEADER_SetTextColor PROC
;;;655    */
;;;656    void HEADER_SetTextColor(HEADER_Handle hObj, GUI_COLOR Color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;657      if (hObj) {
000006  b164              CBZ      r4,|L29.34|
;;;658        HEADER_Obj * pObj;
;;;659        WM_LOCK();
000008  f7fffffe          BL       GUI_Lock
;;;660        pObj = HEADER_H2P(hObj);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4606              MOV      r6,r0
;;;661        pObj->TextColor = Color;
000014  62f5              STR      r5,[r6,#0x2c]
;;;662        WM_InvalidateWindow(hObj);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       WM_InvalidateWindow
;;;663        WM_UNLOCK();
00001c  f7fffffe          BL       GUI_Unlock
;;;664      }
000020  bf00              NOP      
                  |L29.34|
;;;665    }
000022  bd70              POP      {r4-r6,pc}
;;;666    
                          ENDP


                          AREA ||i._DrawTriangle||, CODE, READONLY, ALIGN=1

                  _DrawTriangle PROC
;;;100    */
;;;101    static void _DrawTriangle(int x, int y, int Size, int Inc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;102      for (; Size >= 0; Size--, y += Inc) {
00000c  e006              B        |L30.28|
                  |L30.14|
;;;103        GUI_DrawHLine(y, x - Size, x + Size);
00000e  192a              ADDS     r2,r5,r4
000010  1b29              SUBS     r1,r5,r4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GUI_DrawHLine
000018  1e64              SUBS     r4,r4,#1              ;102
00001a  443e              ADD      r6,r6,r7              ;102
                  |L30.28|
00001c  2c00              CMP      r4,#0                 ;102
00001e  daf6              BGE      |L30.14|
;;;104      }
;;;105    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;106    
                          ENDP


                          AREA ||i._FreeAttached||, CODE, READONLY, ALIGN=1

                  _FreeAttached PROC
;;;199    */
;;;200    static void _FreeAttached(HEADER_Obj * pObj) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;201      int i, NumItems;
;;;202      NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
000006  f1040030          ADD      r0,r4,#0x30
00000a  f7fffffe          BL       GUI_ARRAY_GetNumItems
00000e  4607              MOV      r7,r0
;;;203      for (i = 0; i < NumItems; i++) {
000010  2500              MOVS     r5,#0
000012  e00c              B        |L31.46|
                  |L31.20|
;;;204        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
000014  4629              MOV      r1,r5
000016  f1040030          ADD      r0,r4,#0x30
00001a  f7fffffe          BL       GUI_ARRAY_GetpItem
00001e  4606              MOV      r6,r0
;;;205        if (pColumn->hDrawObj) {
000020  88f0              LDRH     r0,[r6,#6]
000022  b118              CBZ      r0,|L31.44|
;;;206          GUI_ALLOC_Free(pColumn->hDrawObj);
000024  f9b60006          LDRSH    r0,[r6,#6]
000028  f7fffffe          BL       GUI_ALLOC_Free
                  |L31.44|
00002c  1c6d              ADDS     r5,r5,#1              ;203
                  |L31.46|
00002e  42bd              CMP      r5,r7                 ;203
000030  dbf0              BLT      |L31.20|
;;;207        }
;;;208      }
;;;209      /* Delete attached objects (if any) */
;;;210      GUI_ARRAY_Delete(&pObj->Columns);
000032  f1040030          ADD      r0,r4,#0x30
000036  f7fffffe          BL       GUI_ARRAY_Delete
;;;211      _RestoreOldCursor();
00003a  f7fffffe          BL       _RestoreOldCursor
;;;212    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;213    
                          ENDP


                          AREA ||i._GetDividerIndex||, CODE, READONLY, ALIGN=1

                  _GetDividerIndex PROC
;;;218    #if (HEADER_SUPPORT_DRAG)
;;;219    static int _GetDividerIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;220      int Item = -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
000010  9000              STR      r0,[sp,#0]
;;;221      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
000012  f1b80f00          CMP      r8,#0
000016  db34              BLT      |L32.130|
000018  4648              MOV      r0,r9
00001a  f7fffffe          BL       WM_GetWindowSizeY
00001e  4540              CMP      r0,r8
000020  dd2f              BLE      |L32.130|
;;;222        if (hObj) {
000022  f1b90f00          CMP      r9,#0
000026  d02c              BEQ      |L32.130|
;;;223          int Index, xPos = 0, NumColumns;
000028  2700              MOVS     r7,#0
;;;224          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
00002a  f1050030          ADD      r0,r5,#0x30
00002e  f7fffffe          BL       GUI_ARRAY_GetNumItems
000032  4682              MOV      r10,r0
;;;225          for (Index = 0; Index < NumColumns; Index++) {
000034  2400              MOVS     r4,#0
000036  e020              B        |L32.122|
                  |L32.56|
;;;226            HEADER_COLUMN * pColumn;
;;;227            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000038  4621              MOV      r1,r4
00003a  f1050030          ADD      r0,r5,#0x30
00003e  f7fffffe          BL       GUI_ARRAY_GetpItem
000042  4683              MOV      r11,r0
;;;228            xPos += pColumn->Width;
000044  f8db0000          LDR      r0,[r11,#0]
000048  4407              ADD      r7,r7,r0
;;;229            if ((xPos >= (x - 4)) && (xPos <= (x + 4))) {
00004a  1f30              SUBS     r0,r6,#4
00004c  42b8              CMP      r0,r7
00004e  dc13              BGT      |L32.120|
000050  1d30              ADDS     r0,r6,#4
000052  4287              CMP      r7,r0
000054  dc10              BGT      |L32.120|
;;;230              Item = Index;
000056  9400              STR      r4,[sp,#0]
;;;231              if ((Index < (NumColumns - 1)) && (x < xPos)) {
000058  f1aa0001          SUB      r0,r10,#1
00005c  42a0              CMP      r0,r4
00005e  dd0b              BLE      |L32.120|
000060  42be              CMP      r6,r7
000062  da09              BGE      |L32.120|
;;;232                pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index + 1);
000064  1c61              ADDS     r1,r4,#1
000066  f1050030          ADD      r0,r5,#0x30
00006a  f7fffffe          BL       GUI_ARRAY_GetpItem
00006e  4683              MOV      r11,r0
;;;233                if (pColumn->Width == 0) {
000070  f8db0000          LDR      r0,[r11,#0]
000074  b900              CBNZ     r0,|L32.120|
;;;234                  break;
000076  e002              B        |L32.126|
                  |L32.120|
000078  1c64              ADDS     r4,r4,#1              ;225
                  |L32.122|
00007a  4554              CMP      r4,r10                ;225
00007c  dbdc              BLT      |L32.56|
                  |L32.126|
00007e  bf00              NOP      
;;;235                }
;;;236              }
;;;237            }
;;;238          }
;;;239        }
000080  bf00              NOP      
                  |L32.130|
;;;240      }
;;;241      return Item;
000082  9800              LDR      r0,[sp,#0]
;;;242    }
000084  e8bd8ff8          POP      {r3-r11,pc}
;;;243    #endif
                          ENDP


                          AREA ||i._GetItemIndex||, CODE, READONLY, ALIGN=1

                  _GetItemIndex PROC
;;;352    */
;;;353    static int _GetItemIndex(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;354      int Item = -1;
00000c  f04f30ff          MOV      r0,#0xffffffff
000010  9000              STR      r0,[sp,#0]
;;;355      if ((y >= 0) && (y < WM_GetWindowSizeY(hObj))) {
000012  2f00              CMP      r7,#0
000014  db2a              BLT      |L33.108|
000016  4648              MOV      r0,r9
000018  f7fffffe          BL       WM_GetWindowSizeY
00001c  42b8              CMP      r0,r7
00001e  dd25              BLE      |L33.108|
;;;356        if (hObj) {
000020  f1b90f00          CMP      r9,#0
000024  d022              BEQ      |L33.108|
;;;357          int Index, xPos = 0, NumColumns;
000026  f04f0800          MOV      r8,#0
;;;358          NumColumns = GUI_ARRAY_GetNumItems(&pObj->Columns);
00002a  f1050030          ADD      r0,r5,#0x30
00002e  f7fffffe          BL       GUI_ARRAY_GetNumItems
000032  4683              MOV      r11,r0
;;;359          for (Index = 0; Index < NumColumns; Index++) {
000034  2400              MOVS     r4,#0
000036  e015              B        |L33.100|
                  |L33.56|
;;;360            HEADER_COLUMN * pColumn;
;;;361            pColumn = (HEADER_COLUMN *)GUI_ARRAY_GetpItem(&pObj->Columns, Index);
000038  4621              MOV      r1,r4
00003a  f1050030          ADD      r0,r5,#0x30
00003e  f7fffffe          BL       GUI_ARRAY_GetpItem
000042  4682              MOV      r10,r0
;;;362            if ((x > (xPos + 4)) && (x < (xPos + pColumn->Width - 4))) {
000044  f1080004          ADD      r0,r8,#4
000048  4286              CMP      r6,r0
00004a  dd07              BLE      |L33.92|
00004c  f8da0000          LDR      r0,[r10,#0]
000050  4440              ADD      r0,r0,r8
000052  1f00              SUBS     r0,r0,#4
000054  42b0              CMP      r0,r6
000056  dd01              BLE      |L33.92|
;;;363              Item = Index;
000058  9400              STR      r4,[sp,#0]
;;;364              break;
00005a  e005              B        |L33.104|
                  |L33.92|
;;;365            }
;;;366            xPos += pColumn->Width;
00005c  f8da0000          LDR      r0,[r10,#0]
000060  4480              ADD      r8,r8,r0
000062  1c64              ADDS     r4,r4,#1              ;359
                  |L33.100|
000064  455c              CMP      r4,r11                ;359
000066  dbe7              BLT      |L33.56|
                  |L33.104|
000068  bf00              NOP                            ;364
;;;367          }
;;;368        }
00006a  bf00              NOP      
                  |L33.108|
;;;369      }
;;;370      return Item;
00006c  9800              LDR      r0,[sp,#0]
;;;371    }
00006e  e8bd8ff8          POP      {r3-r11,pc}
;;;372    
                          ENDP


                          AREA ||i._HandlePID||, CODE, READONLY, ALIGN=2

                  _HandlePID PROC
;;;292    #if (HEADER_SUPPORT_DRAG)
;;;293    static void _HandlePID(HEADER_Handle hObj, HEADER_Obj * pObj, int x, int y, int Pressed) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
00000c  9e08              LDR      r6,[sp,#0x20]
;;;294      int Hit = _GetDividerIndex(hObj, pObj, x, y);
00000e  4653              MOV      r3,r10
000010  462a              MOV      r2,r5
000012  4621              MOV      r1,r4
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       _GetDividerIndex
00001a  4607              MOV      r7,r0
;;;295      /* set capture position */
;;;296      if ((Pressed == 1) && (Hit >= 0) && (pObj->CapturePosX == -1)) {
00001c  2e01              CMP      r6,#1
00001e  d106              BNE      |L34.46|
000020  2f00              CMP      r7,#0
000022  db04              BLT      |L34.46|
000024  6b60              LDR      r0,[r4,#0x34]
000026  1c40              ADDS     r0,r0,#1
000028  d101              BNE      |L34.46|
;;;297        pObj->CapturePosX = x;
00002a  6365              STR      r5,[r4,#0x34]
;;;298        pObj->CaptureItem = Hit;
00002c  63a7              STR      r7,[r4,#0x38]
                  |L34.46|
;;;299      }
;;;300      if (Pressed <= 0) {
00002e  2e00              CMP      r6,#0
000030  dc02              BGT      |L34.56|
;;;301        pObj->CapturePosX = -1;
000032  f04f30ff          MOV      r0,#0xffffffff
000036  6360              STR      r0,[r4,#0x34]
                  |L34.56|
;;;302      }
;;;303      /* set mouse cursor and capture */
;;;304      if (Hit >= 0) {
000038  2f00              CMP      r7,#0
00003a  db0c              BLT      |L34.86|
;;;305        WM_SetCapture(hObj, 1);
00003c  2101              MOVS     r1,#1
00003e  4648              MOV      r0,r9
000040  f7fffffe          BL       WM_SetCapture
;;;306        #if GUI_SUPPORT_CURSOR
;;;307          if (!_pOldCursor) {
000044  4819              LDR      r0,|L34.172|
000046  6800              LDR      r0,[r0,#0]  ; _pOldCursor
000048  b928              CBNZ     r0,|L34.86|
;;;308            _pOldCursor = GUI_CURSOR_Select(_pDefaultCursor);
00004a  4819              LDR      r0,|L34.176|
00004c  6800              LDR      r0,[r0,#0]  ; _pDefaultCursor
00004e  f7fffffe          BL       GUI_CURSOR_Select
000052  4916              LDR      r1,|L34.172|
000054  6008              STR      r0,[r1,#0]  ; _pOldCursor
                  |L34.86|
;;;309          }
;;;310        #endif
;;;311      }
;;;312      /* modify header */
;;;313      if ((pObj->CapturePosX >= 0) && (x != pObj->CapturePosX) && (Pressed == 1)) {
000056  6b60              LDR      r0,[r4,#0x34]
000058  2800              CMP      r0,#0
00005a  db1b              BLT      |L34.148|
00005c  6b60              LDR      r0,[r4,#0x34]
00005e  42a8              CMP      r0,r5
000060  d018              BEQ      |L34.148|
000062  2e01              CMP      r6,#1
000064  d116              BNE      |L34.148|
;;;314        int NewSize = HEADER_GetItemWidth(hObj, pObj->CaptureItem) + x - pObj->CapturePosX;
000066  4648              MOV      r0,r9
000068  6ba1              LDR      r1,[r4,#0x38]
00006a  f7fffffe          BL       HEADER_GetItemWidth
00006e  4428              ADD      r0,r0,r5
000070  6b61              LDR      r1,[r4,#0x34]
000072  eba00801          SUB      r8,r0,r1
;;;315        if (NewSize >= 0) {
000076  f1b80f00          CMP      r8,#0
00007a  db0a              BLT      |L34.146|
;;;316          HEADER_SetItemWidth(hObj, pObj->CaptureItem, NewSize);
00007c  4642              MOV      r2,r8
00007e  4648              MOV      r0,r9
000080  6ba1              LDR      r1,[r4,#0x38]
000082  f7fffffe          BL       HEADER_SetItemWidth
;;;317          if (!_LimitDragWitdh(hObj, pObj)) {
000086  4621              MOV      r1,r4
000088  4648              MOV      r0,r9
00008a  f7fffffe          BL       _LimitDragWitdh
00008e  b900              CBNZ     r0,|L34.146|
;;;318            pObj->CapturePosX = x;
000090  6365              STR      r5,[r4,#0x34]
                  |L34.146|
;;;319          }
;;;320        }
;;;321      }
000092  bf00              NOP      
                  |L34.148|
;;;322      /* release capture & restore cursor */
;;;323      if (Pressed <= 0) {
000094  2e00              CMP      r6,#0
000096  dc06              BGT      |L34.166|
;;;324        #if (GUI_SUPPORT_MOUSE)
;;;325        if (Hit == -1)
;;;326        #endif
;;;327        {
;;;328          _RestoreOldCursor();
000098  f7fffffe          BL       _RestoreOldCursor
;;;329          pObj->CapturePosX = -1;
00009c  f04f30ff          MOV      r0,#0xffffffff
0000a0  6360              STR      r0,[r4,#0x34]
;;;330          WM_ReleaseCapture();
0000a2  f7fffffe          BL       WM_ReleaseCapture
                  |L34.166|
;;;331        }
;;;332      }
;;;333    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;334    #endif
                          ENDP

0000aa  0000              DCW      0x0000
                  |L34.172|
                          DCD      _pOldCursor
                  |L34.176|
                          DCD      _pDefaultCursor

                          AREA ||i._LimitDragWitdh||, CODE, READONLY, ALIGN=1

                  _LimitDragWitdh PROC
;;;255    */
;;;256    static int _LimitDragWitdh(HEADER_Handle hObj, HEADER_Obj * pObj) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
;;;257      if (pObj->DragLimit) {
000008  f8950050          LDRB     r0,[r5,#0x50]
00000c  2800              CMP      r0,#0
00000e  d03e              BEQ      |L35.142|
;;;258        int DragLimit, i, SumX;
;;;259        GUI_RECT Rect;
;;;260        WM_HWIN hVScroll, hParent;
;;;261        /* Take the x-size of the widgets client rectangle as limit */
;;;262        WM_GetClientRectEx(hObj, &Rect);
000010  4669              MOV      r1,sp
000012  4648              MOV      r0,r9
000014  f7fffffe          BL       WM_GetClientRectEx
;;;263        DragLimit = Rect.x1;
000018  f9bd7004          LDRSH    r7,[sp,#4]
;;;264        /* If the parent window has a vertical scrollbar, reduce the drag limit by the xsize of the scrollbar */
;;;265        hParent = WM_GetParent(hObj);
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       WM_GetParent
000022  4682              MOV      r10,r0
;;;266        if (hParent) {
000024  f1ba0f00          CMP      r10,#0
000028  d00d              BEQ      |L35.70|
;;;267          hVScroll = WM_GetScrollbarV(WM_GetParent(hObj));
00002a  4648              MOV      r0,r9
00002c  f7fffffe          BL       WM_GetParent
000030  4683              MOV      r11,r0
000032  f7fffffe          BL       WM_GetScrollbarV
000036  4680              MOV      r8,r0
;;;268          if (hVScroll) {
000038  f1b80f00          CMP      r8,#0
00003c  d003              BEQ      |L35.70|
;;;269            DragLimit -= WM_GetWindowSizeX(hVScroll);
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       WM_GetWindowSizeX
000044  1a3f              SUBS     r7,r7,r0
                  |L35.70|
;;;270          }
;;;271        }
;;;272        /* Calculate the sum of the width of all header items */
;;;273        for (SumX = i = 0; i <= pObj->CaptureItem; i++) {
000046  2400              MOVS     r4,#0
000048  4626              MOV      r6,r4
00004a  e005              B        |L35.88|
                  |L35.76|
;;;274          SumX += HEADER_GetItemWidth(hObj, i);
00004c  4621              MOV      r1,r4
00004e  4648              MOV      r0,r9
000050  f7fffffe          BL       HEADER_GetItemWidth
000054  4406              ADD      r6,r6,r0
000056  1c64              ADDS     r4,r4,#1              ;273
                  |L35.88|
000058  6ba8              LDR      r0,[r5,#0x38]         ;273
00005a  42a0              CMP      r0,r4                 ;273
00005c  daf6              BGE      |L35.76|
;;;275        }
;;;276        /* If the sum of the width of all header items exeeds the limit, limit the captured item */
;;;277        if (SumX > DragLimit) {
00005e  42be              CMP      r6,r7
000060  dd14              BLE      |L35.140|
;;;278          for (SumX = i = 0; i < pObj->CaptureItem; i++) {
000062  2000              MOVS     r0,#0
000064  4604              MOV      r4,r0
000066  4606              MOV      r6,r0
000068  e005              B        |L35.118|
                  |L35.106|
;;;279            SumX += HEADER_GetItemWidth(hObj, i);
00006a  4621              MOV      r1,r4
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       HEADER_GetItemWidth
000072  4406              ADD      r6,r6,r0
000074  1c64              ADDS     r4,r4,#1              ;278
                  |L35.118|
000076  6ba8              LDR      r0,[r5,#0x38]         ;278
000078  42a0              CMP      r0,r4                 ;278
00007a  dcf6              BGT      |L35.106|
;;;280          }
;;;281          HEADER_SetItemWidth(hObj, pObj->CaptureItem, DragLimit - SumX);
00007c  1bba              SUBS     r2,r7,r6
00007e  4648              MOV      r0,r9
000080  6ba9              LDR      r1,[r5,#0x38]
000082  f7fffffe          BL       HEADER_SetItemWidth
;;;282          return 1;
000086  2001              MOVS     r0,#1
                  |L35.136|
;;;283        }
;;;284      }
;;;285      return 0;
;;;286    }
000088  e8bd9ffc          POP      {r2-r12,pc}
                  |L35.140|
00008c  bf00              NOP                            ;284
                  |L35.142|
00008e  2000              MOVS     r0,#0                 ;285
000090  e7fa              B        |L35.136|
;;;287    
                          ENDP


                          AREA ||i._OnPidStateChange||, CODE, READONLY, ALIGN=1

                  _OnPidStateChange PROC
;;;400    */
;;;401    static void _OnPidStateChange(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;402      const WM_PID_STATE_CHANGED_INFO * pState = (const WM_PID_STATE_CHANGED_INFO *)pMsg->Data.p;
00000a  68b4              LDR      r4,[r6,#8]
;;;403      if ((pState->StatePrev == 1) && (pState->State == 0)) {
00000c  7a60              LDRB     r0,[r4,#9]
00000e  2801              CMP      r0,#1
000010  d10a              BNE      |L36.40|
000012  7a20              LDRB     r0,[r4,#8]
000014  b940              CBNZ     r0,|L36.40|
;;;404        pObj->Sel = _GetItemIndex(hObj, pObj, pState->x + pObj->ScrollPos, pState->y);
000016  6820              LDR      r0,[r4,#0]
000018  6be9              LDR      r1,[r5,#0x3c]
00001a  1842              ADDS     r2,r0,r1
00001c  4629              MOV      r1,r5
00001e  4638              MOV      r0,r7
000020  6863              LDR      r3,[r4,#4]
000022  f7fffffe          BL       _GetItemIndex
000026  6428              STR      r0,[r5,#0x40]
                  |L36.40|
;;;405      }
;;;406    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;407    
                          ENDP


                          AREA ||i._OnTouch||, CODE, READONLY, ALIGN=1

                  _OnTouch PROC
;;;377    #if (HEADER_SUPPORT_DRAG)
;;;378    static void _OnTouch(HEADER_Handle hObj, HEADER_Obj * pObj, WM_MESSAGE * pMsg) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;379      int Notification;
;;;380      const GUI_PID_STATE * pState = (const GUI_PID_STATE *)pMsg->Data.p;
00000a  68b4              LDR      r4,[r6,#8]
;;;381      if (pState) {
00000c  b14c              CBZ      r4,|L37.34|
;;;382        _HandlePID(hObj, pObj, pState->x + pObj->ScrollPos, pState->y, pState->Pressed);
00000e  7a20              LDRB     r0,[r4,#8]
000010  9000              STR      r0,[sp,#0]
000012  6820              LDR      r0,[r4,#0]
000014  6bf9              LDR      r1,[r7,#0x3c]
000016  1842              ADDS     r2,r0,r1
000018  4639              MOV      r1,r7
00001a  4640              MOV      r0,r8
00001c  6863              LDR      r3,[r4,#4]
00001e  f7fffffe          BL       _HandlePID
                  |L37.34|
;;;383      }
;;;384      if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
000022  68b0              LDR      r0,[r6,#8]
000024  b128              CBZ      r0,|L37.50|
;;;385        if (pState->Pressed) {
000026  7a20              LDRB     r0,[r4,#8]
000028  b108              CBZ      r0,|L37.46|
;;;386          Notification = WM_NOTIFICATION_CLICKED;
00002a  2501              MOVS     r5,#1
00002c  e002              B        |L37.52|
                  |L37.46|
;;;387        } else {
;;;388          Notification = WM_NOTIFICATION_RELEASED;
00002e  2502              MOVS     r5,#2
000030  e000              B        |L37.52|
                  |L37.50|
;;;389        }
;;;390      } else {
;;;391        Notification = WM_NOTIFICATION_MOVED_OUT;
000032  2503              MOVS     r5,#3
                  |L37.52|
;;;392      }
;;;393      WM_NotifyParent(hObj, Notification);
000034  4629              MOV      r1,r5
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       WM_NotifyParent
;;;394    }
00003c  e8bd83f8          POP      {r3-r9,pc}
;;;395    #endif
                          ENDP


                          AREA ||i._Paint||, CODE, READONLY, ALIGN=2

                  _Paint PROC
;;;110    */
;;;111    static void _Paint(HEADER_Obj* pObj) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b089              SUB      sp,sp,#0x24
000006  4605              MOV      r5,r0
;;;112      GUI_RECT Rect, RectItem;
;;;113      int i, xPos = -pObj->ScrollPos;
000008  6be8              LDR      r0,[r5,#0x3c]
00000a  f1c00900          RSB      r9,r0,#0
;;;114      int NumItems = GUI_ARRAY_GetNumItems(&pObj->Columns);
00000e  f1050030          ADD      r0,r5,#0x30
000012  f7fffffe          BL       GUI_ARRAY_GetNumItems
000016  9004              STR      r0,[sp,#0x10]
;;;115      int EffectSize = pObj->Widget.pEffect->EffectSize;
000018  6a28              LDR      r0,[r5,#0x20]
00001a  6946              LDR      r6,[r0,#0x14]
;;;116      int ArrowSize, ArrowPos;
;;;117      LCD_SetBkColor(pObj->BkColor);
00001c  6aa8              LDR      r0,[r5,#0x28]
00001e  f7fffffe          BL       LCD_SetBkColor
;;;118      GUI_SetFont(pObj->pFont);
000022  6ce8              LDR      r0,[r5,#0x4c]
000024  f7fffffe          BL       GUI_SetFont
;;;119      GUI_Clear();
000028  f7fffffe          BL       GUI_Clear
;;;120      for (i = 0; i < NumItems; i++) {
00002c  2700              MOVS     r7,#0
00002e  e0fa              B        |L38.550|
                  |L38.48|
;;;121        int Subtract = 0;
000030  f04f0b00          MOV      r11,#0
;;;122        HEADER_COLUMN * pColumn = (HEADER_COLUMN*)GUI_ARRAY_GetpItem(&pObj->Columns, i);
000034  4639              MOV      r1,r7
000036  f1050030          ADD      r0,r5,#0x30
00003a  f7fffffe          BL       GUI_ARRAY_GetpItem
00003e  4604              MOV      r4,r0
;;;123        GUI_GetClientRect(&Rect);
000040  a807              ADD      r0,sp,#0x1c
000042  f7fffffe          BL       GUI_GetClientRect
;;;124        Rect.x0 = xPos;
000046  fa0ff089          SXTH     r0,r9
00004a  f8ad001c          STRH     r0,[sp,#0x1c]
;;;125        Rect.x1 = Rect.x0 + pColumn->Width;
00004e  f8bd001c          LDRH     r0,[sp,#0x1c]
000052  8821              LDRH     r1,[r4,#0]
000054  4408              ADD      r0,r0,r1
000056  b200              SXTH     r0,r0
000058  f8ad0020          STRH     r0,[sp,#0x20]
;;;126        RectItem = Rect;
00005c  e9dd0107          LDRD     r0,r1,[sp,#0x1c]
000060  e9cd0105          STRD     r0,r1,[sp,#0x14]
;;;127        ArrowSize = ((RectItem.y1 - RectItem.y0 - EffectSize * 2) / 3) - 1;
000064  f9bd001a          LDRSH    r0,[sp,#0x1a]
000068  f9bd1016          LDRSH    r1,[sp,#0x16]
00006c  1a40              SUBS     r0,r0,r1
00006e  eba00046          SUB      r0,r0,r6,LSL #1
000072  2103              MOVS     r1,#3
000074  fb90f0f1          SDIV     r0,r0,r1
000078  f1a00801          SUB      r8,r0,#1
;;;128        ArrowPos = RectItem.x1 - 4 - ArrowSize;
00007c  f9bd0018          LDRSH    r0,[sp,#0x18]
000080  1f00              SUBS     r0,r0,#4
000082  eba00a08          SUB      r10,r0,r8
;;;129        if (pColumn->hDrawObj) {
000086  88e0              LDRH     r0,[r4,#6]
000088  2800              CMP      r0,#0
00008a  d055              BEQ      |L38.312|
;;;130          int xOff = 0, yOff = 0;
00008c  2000              MOVS     r0,#0
00008e  9003              STR      r0,[sp,#0xc]
000090  9002              STR      r0,[sp,#8]
;;;131          switch (pColumn->Align & GUI_TA_HORIZONTAL) {
000092  7920              LDRB     r0,[r4,#4]
000094  f0000003          AND      r0,r0,#3
000098  2801              CMP      r0,#1
00009a  d002              BEQ      |L38.162|
00009c  2802              CMP      r0,#2
00009e  d114              BNE      |L38.202|
0000a0  e007              B        |L38.178|
                  |L38.162|
;;;132            case GUI_TA_RIGHT:
;;;133              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj));
0000a2  f9b40006          LDRSH    r0,[r4,#6]
0000a6  f7fffffe          BL       GUI_DRAW__GetXSize
0000aa  6821              LDR      r1,[r4,#0]
0000ac  1a08              SUBS     r0,r1,r0
0000ae  9003              STR      r0,[sp,#0xc]
;;;134              break;
0000b0  e00b              B        |L38.202|
                  |L38.178|
;;;135            case GUI_TA_HCENTER:
;;;136              xOff = (pColumn->Width - GUI_DRAW__GetXSize(pColumn->hDrawObj)) / 2;
0000b2  f9b40006          LDRSH    r0,[r4,#6]
0000b6  f7fffffe          BL       GUI_DRAW__GetXSize
0000ba  6821              LDR      r1,[r4,#0]
0000bc  1a08              SUBS     r0,r1,r0
0000be  9001              STR      r0,[sp,#4]
0000c0  eb0070d0          ADD      r0,r0,r0,LSR #31
0000c4  1040              ASRS     r0,r0,#1
0000c6  9003              STR      r0,[sp,#0xc]
;;;137              break;
0000c8  bf00              NOP      
                  |L38.202|
0000ca  bf00              NOP                            ;134
;;;138          }
;;;139          switch (pColumn->Align & GUI_TA_VERTICAL) {
0000cc  7920              LDRB     r0,[r4,#4]
0000ce  f000000c          AND      r0,r0,#0xc
0000d2  2804              CMP      r0,#4
0000d4  d002              BEQ      |L38.220|
0000d6  280c              CMP      r0,#0xc
0000d8  d11e              BNE      |L38.280|
0000da  e00c              B        |L38.246|
                  |L38.220|
;;;140    	      case GUI_TA_BOTTOM:
;;;141              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj));
0000dc  f9b40006          LDRSH    r0,[r4,#6]
0000e0  f7fffffe          BL       GUI_DRAW__GetYSize
0000e4  f9bd1022          LDRSH    r1,[sp,#0x22]
0000e8  f9bd201e          LDRSH    r2,[sp,#0x1e]
0000ec  1a89              SUBS     r1,r1,r2
0000ee  1c49              ADDS     r1,r1,#1
0000f0  1a08              SUBS     r0,r1,r0
0000f2  9002              STR      r0,[sp,#8]
;;;142              break;
0000f4  e010              B        |L38.280|
                  |L38.246|
;;;143    	      case GUI_TA_VCENTER:
;;;144              yOff = ((Rect.y1 - Rect.y0 + 1) - GUI_DRAW__GetYSize(pColumn->hDrawObj)) / 2;
0000f6  f9b40006          LDRSH    r0,[r4,#6]
0000fa  f7fffffe          BL       GUI_DRAW__GetYSize
0000fe  f9bd1022          LDRSH    r1,[sp,#0x22]
000102  f9bd201e          LDRSH    r2,[sp,#0x1e]
000106  1a89              SUBS     r1,r1,r2
000108  1c49              ADDS     r1,r1,#1
00010a  1a08              SUBS     r0,r1,r0
00010c  9001              STR      r0,[sp,#4]
00010e  eb0070d0          ADD      r0,r0,r0,LSR #31
000112  1040              ASRS     r0,r0,#1
000114  9002              STR      r0,[sp,#8]
;;;145              break;
000116  bf00              NOP      
                  |L38.280|
000118  bf00              NOP                            ;142
;;;146          }
;;;147          WM_SetUserClipRect(&Rect);
00011a  a807              ADD      r0,sp,#0x1c
00011c  f7fffffe          BL       WM_SetUserClipRect
;;;148          GUI_DRAW__Draw(pColumn->hDrawObj, xPos + xOff, yOff);
000120  9a03              LDR      r2,[sp,#0xc]
000122  eb090102          ADD      r1,r9,r2
000126  f9b40006          LDRSH    r0,[r4,#6]
00012a  9a02              LDR      r2,[sp,#8]
00012c  f7fffffe          BL       GUI_DRAW__Draw
;;;149          WM_SetUserClipRect(NULL);
000130  2000              MOVS     r0,#0
000132  f7fffffe          BL       WM_SetUserClipRect
;;;150        }
000136  bf00              NOP      
                  |L38.312|
;;;151        WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000138  a907              ADD      r1,sp,#0x1c
00013a  4628              MOV      r0,r5
00013c  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;152        xPos += Rect.x1 - Rect.x0;
000140  f9bd0020          LDRSH    r0,[sp,#0x20]
000144  f9bd101c          LDRSH    r1,[sp,#0x1c]
000148  1a40              SUBS     r0,r0,r1
00014a  4481              ADD      r9,r9,r0
;;;153        Rect.x0 += EffectSize + _DefaultBorderH;
00014c  f8bd001c          LDRH     r0,[sp,#0x1c]
000150  4940              LDR      r1,|L38.596|
000152  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderH
000154  4431              ADD      r1,r1,r6
000156  4408              ADD      r0,r0,r1
000158  b200              SXTH     r0,r0
00015a  f8ad001c          STRH     r0,[sp,#0x1c]
;;;154        Rect.x1 -= EffectSize + _DefaultBorderH;
00015e  f8bd0020          LDRH     r0,[sp,#0x20]
000162  493c              LDR      r1,|L38.596|
000164  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderH
000166  4431              ADD      r1,r1,r6
000168  1a40              SUBS     r0,r0,r1
00016a  b200              SXTH     r0,r0
00016c  f8ad0020          STRH     r0,[sp,#0x20]
;;;155        Rect.y0 += EffectSize + _DefaultBorderV;
000170  f8bd001e          LDRH     r0,[sp,#0x1e]
000174  4938              LDR      r1,|L38.600|
000176  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderV
000178  4431              ADD      r1,r1,r6
00017a  4408              ADD      r0,r0,r1
00017c  b200              SXTH     r0,r0
00017e  f8ad001e          STRH     r0,[sp,#0x1e]
;;;156        Rect.y1 -= EffectSize + _DefaultBorderV;
000182  f8bd0022          LDRH     r0,[sp,#0x22]
000186  4934              LDR      r1,|L38.600|
000188  8809              LDRH     r1,[r1,#0]  ; _DefaultBorderV
00018a  4431              ADD      r1,r1,r6
00018c  1a40              SUBS     r0,r0,r1
00018e  b200              SXTH     r0,r0
000190  f8ad0022          STRH     r0,[sp,#0x22]
;;;157        LCD_SetColor(pObj->TextColor);
000194  6ae8              LDR      r0,[r5,#0x2c]
000196  f7fffffe          BL       LCD_SetColor
;;;158        if ((pObj->DirIndicatorColumn == i) && ((pColumn->Align & GUI_TA_HORIZONTAL) == GUI_TA_RIGHT)) {
00019a  6c68              LDR      r0,[r5,#0x44]
00019c  42b8              CMP      r0,r7
00019e  d106              BNE      |L38.430|
0001a0  7920              LDRB     r0,[r4,#4]
0001a2  f0000003          AND      r0,r0,#3
0001a6  2801              CMP      r0,#1
0001a8  d101              BNE      |L38.430|
;;;159          Subtract = (ArrowSize << 1) + 1;
0001aa  eb000b48          ADD      r11,r0,r8,LSL #1
                  |L38.430|
;;;160        }
;;;161        Rect.x1 -= Subtract;
0001ae  f8bd0020          LDRH     r0,[sp,#0x20]
0001b2  eba0000b          SUB      r0,r0,r11
0001b6  b200              SXTH     r0,r0
0001b8  f8ad0020          STRH     r0,[sp,#0x20]
;;;162        GUI_DispStringInRect(pColumn->acText, &Rect, pColumn->Align);
0001bc  f9b42004          LDRSH    r2,[r4,#4]
0001c0  a907              ADD      r1,sp,#0x1c
0001c2  f1040008          ADD      r0,r4,#8
0001c6  f7fffffe          BL       GUI_DispStringInRect
;;;163        Rect.x1 += Subtract;
0001ca  f8bd0020          LDRH     r0,[sp,#0x20]
0001ce  4458              ADD      r0,r0,r11
0001d0  b200              SXTH     r0,r0
0001d2  f8ad0020          STRH     r0,[sp,#0x20]
;;;164        if (pObj->DirIndicatorColumn == i) {
0001d6  6c68              LDR      r0,[r5,#0x44]
0001d8  42b8              CMP      r0,r7
0001da  d123              BNE      |L38.548|
;;;165          LCD_SetColor(GUI_BLACK);
0001dc  2000              MOVS     r0,#0
0001de  f7fffffe          BL       LCD_SetColor
;;;166          WM_SetUserClipRect(&RectItem);
0001e2  a805              ADD      r0,sp,#0x14
0001e4  f7fffffe          BL       WM_SetUserClipRect
;;;167          if (pObj->DirIndicatorReverse == 0) {
0001e8  6ca8              LDR      r0,[r5,#0x48]
0001ea  b958              CBNZ     r0,|L38.516|
;;;168            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1), ArrowSize, 1);
0001ec  f9bd0022          LDRSH    r0,[sp,#0x22]
0001f0  f9bd201e          LDRSH    r2,[sp,#0x1e]
0001f4  1a80              SUBS     r0,r0,r2
0001f6  1041              ASRS     r1,r0,#1
0001f8  2301              MOVS     r3,#1
0001fa  4642              MOV      r2,r8
0001fc  4650              MOV      r0,r10
0001fe  f7fffffe          BL       _DrawTriangle
000202  e00c              B        |L38.542|
                  |L38.516|
;;;169          } else {
;;;170            _DrawTriangle(ArrowPos, ((Rect.y1 - Rect.y0) >> 1) + ArrowSize, ArrowSize, -1);
000204  f9bd0022          LDRSH    r0,[sp,#0x22]
000208  f9bd201e          LDRSH    r2,[sp,#0x1e]
00020c  1a80              SUBS     r0,r0,r2
00020e  eb080160          ADD      r1,r8,r0,ASR #1
000212  f04f33ff          MOV      r3,#0xffffffff
000216  4642              MOV      r2,r8
000218  4650              MOV      r0,r10
00021a  f7fffffe          BL       _DrawTriangle
                  |L38.542|
;;;171          }
;;;172          WM_SetUserClipRect(NULL);
00021e  2000              MOVS     r0,#0
000220  f7fffffe          BL       WM_SetUserClipRect
                  |L38.548|
000224  1c7f              ADDS     r7,r7,#1              ;120
                  |L38.550|
000226  9804              LDR      r0,[sp,#0x10]         ;120
000228  4287              CMP      r7,r0                 ;120
00022a  f6ffaf01          BLT      |L38.48|
;;;173        }
;;;174      }
;;;175      GUI_GetClientRect(&Rect);
00022e  a807              ADD      r0,sp,#0x1c
000230  f7fffffe          BL       GUI_GetClientRect
;;;176      Rect.x0 = xPos;
000234  fa0ff089          SXTH     r0,r9
000238  f8ad001c          STRH     r0,[sp,#0x1c]
;;;177      Rect.x1 = 0xfff;
00023c  f64070ff          MOV      r0,#0xfff
000240  f8ad0020          STRH     r0,[sp,#0x20]
;;;178      WIDGET__EFFECT_DrawUpRect(&pObj->Widget, &Rect);
000244  a907              ADD      r1,sp,#0x1c
000246  4628              MOV      r0,r5
000248  f7fffffe          BL       WIDGET__EFFECT_DrawUpRect
;;;179    }
00024c  b009              ADD      sp,sp,#0x24
00024e  e8bd8ff0          POP      {r4-r11,pc}
;;;180    
                          ENDP

000252  0000              DCW      0x0000
                  |L38.596|
                          DCD      _DefaultBorderH
                  |L38.600|
                          DCD      _DefaultBorderV

                          AREA ||i._RestoreOldCursor||, CODE, READONLY, ALIGN=2

                  _RestoreOldCursor PROC
;;;184    */
;;;185    static void _RestoreOldCursor(void) {
000000  b510              PUSH     {r4,lr}
;;;186      if (_pOldCursor) {
000002  4805              LDR      r0,|L39.24|
000004  6800              LDR      r0,[r0,#0]  ; _pOldCursor
000006  b130              CBZ      r0,|L39.22|
;;;187        #if GUI_SUPPORT_CURSOR
;;;188          GUI_CURSOR_Select(_pOldCursor);
000008  4803              LDR      r0,|L39.24|
00000a  6800              LDR      r0,[r0,#0]  ; _pOldCursor
00000c  f7fffffe          BL       GUI_CURSOR_Select
;;;189        #endif
;;;190        _pOldCursor = 0;
000010  2000              MOVS     r0,#0
000012  4901              LDR      r1,|L39.24|
000014  6008              STR      r0,[r1,#0]  ; _pOldCursor
                  |L39.22|
;;;191      }
;;;192    }
000016  bd10              POP      {r4,pc}
;;;193    
                          ENDP

                  |L39.24|
                          DCD      _pOldCursor

                          AREA ||.data||, DATA, ALIGN=2

                  _pDefaultCursor
                          DCD      GUI_CursorHeaderM
                  _DefaultBkColor
                          DCD      0x00aaaaaa
                  _DefaultTextColor
                          DCD      0x00000000
                  _DefaultBorderH
                          DCD      0x00000002
                  _DefaultBorderV
                          DCD      0x00000000
                  _pDefaultFont
                          DCD      GUI_Font13_1
                  _pOldCursor
                          DCD      0x00000000
