; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jidctint.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jidctint.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\jidctint.c]
                          THUMB

                          AREA ||i.jpeg_idct_islow||, CODE, READONLY, ALIGN=2

                  jpeg_idct_islow PROC
;;;147    GLOBAL(void)
;;;148    jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;149    		 JCOEFPTR coef_block,
;;;150    		 JSAMPARRAY output_buf, JDIMENSION output_col)
;;;151    {
000004  b0c8              SUB      sp,sp,#0x120
;;;152      INT32 tmp0, tmp1, tmp2, tmp3;
;;;153      INT32 tmp10, tmp11, tmp12, tmp13;
;;;154      INT32 z1, z2, z3, z4, z5;
;;;155      JCOEFPTR inptr;
;;;156      ISLOW_MULT_TYPE * quantptr;
;;;157      int * wsptr;
;;;158      JSAMPROW outptr;
;;;159      JSAMPLE *range_limit = IDCT_range_limit(cinfo);
000006  f8ddb120          LDR      r11,[sp,#0x120]
00000a  f8dbb144          LDR      r11,[r11,#0x144]
00000e  f10b0b80          ADD      r11,r11,#0x80
000012  f8cdb108          STR      r11,[sp,#0x108]
;;;160      int ctr;
;;;161      int workspace[DCTSIZE2];	/* buffers data between passes */
;;;162      SHIFT_TEMPS
;;;163    
;;;164      /* Pass 1: process columns from input, store into work array. */
;;;165      /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
;;;166      /* furthermore, we scale the results by 2**PASS1_BITS. */
;;;167    
;;;168      inptr = coef_block;
000016  994a              LDR      r1,[sp,#0x128]
;;;169      quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
000018  f8ddb124          LDR      r11,[sp,#0x124]
00001c  f8db8050          LDR      r8,[r11,#0x50]
;;;170      wsptr = workspace;
000020  a801              ADD      r0,sp,#4
;;;171      for (ctr = DCTSIZE; ctr > 0; ctr--) {
000022  f04f0b08          MOV      r11,#8
000026  f8cdb104          STR      r11,[sp,#0x104]
00002a  e143              B        |L1.692|
                  |L1.44|
;;;172        /* Due to quantization, we will usually find that many of the input
;;;173         * coefficients are zero, especially the AC terms.  We can exploit this
;;;174         * by short-circuiting the IDCT calculation for any column in which all
;;;175         * the AC terms are zero.  In that case each output is equal to the
;;;176         * DC coefficient (with scale factor as needed).
;;;177         * With typical images and quantization tables, half or more of the
;;;178         * column DCT calculations can be simplified this way.
;;;179         */
;;;180        
;;;181        if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
00002c  f8b1b010          LDRH     r11,[r1,#0x10]
000030  f1bb0f00          CMP      r11,#0
000034  d14c              BNE      |L1.208|
000036  f8b1b020          LDRH     r11,[r1,#0x20]
00003a  f1bb0f00          CMP      r11,#0
00003e  d147              BNE      |L1.208|
;;;182    	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
000040  f8b1b030          LDRH     r11,[r1,#0x30]
000044  f1bb0f00          CMP      r11,#0
000048  d142              BNE      |L1.208|
00004a  f8b1b040          LDRH     r11,[r1,#0x40]
00004e  f1bb0f00          CMP      r11,#0
000052  d13d              BNE      |L1.208|
;;;183    	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
000054  f8b1b050          LDRH     r11,[r1,#0x50]
000058  f1bb0f00          CMP      r11,#0
00005c  d138              BNE      |L1.208|
00005e  f8b1b060          LDRH     r11,[r1,#0x60]
000062  f1bb0f00          CMP      r11,#0
000066  d133              BNE      |L1.208|
;;;184    	inptr[DCTSIZE*7] == 0) {
000068  f8b1b070          LDRH     r11,[r1,#0x70]
00006c  f1bb0f00          CMP      r11,#0
000070  d12e              BNE      |L1.208|
;;;185          /* AC terms all zero */
;;;186          int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
000072  f9b1b000          LDRSH    r11,[r1,#0]
000076  f8d8e000          LDR      lr,[r8,#0]
00007a  fb0bfb0e          MUL      r11,r11,lr
00007e  ea4f0b8b          LSL      r11,r11,#2
000082  f8cdb000          STR      r11,[sp,#0]
;;;187          
;;;188          wsptr[DCTSIZE*0] = dcval;
000086  f8ddb000          LDR      r11,[sp,#0]
00008a  f8c0b000          STR      r11,[r0,#0]
;;;189          wsptr[DCTSIZE*1] = dcval;
00008e  f8ddb000          LDR      r11,[sp,#0]
000092  f8c0b020          STR      r11,[r0,#0x20]
;;;190          wsptr[DCTSIZE*2] = dcval;
000096  f8ddb000          LDR      r11,[sp,#0]
00009a  f8c0b040          STR      r11,[r0,#0x40]
;;;191          wsptr[DCTSIZE*3] = dcval;
00009e  f8ddb000          LDR      r11,[sp,#0]
0000a2  f8c0b060          STR      r11,[r0,#0x60]
;;;192          wsptr[DCTSIZE*4] = dcval;
0000a6  f8ddb000          LDR      r11,[sp,#0]
0000aa  f8c0b080          STR      r11,[r0,#0x80]
;;;193          wsptr[DCTSIZE*5] = dcval;
0000ae  f8ddb000          LDR      r11,[sp,#0]
0000b2  f8c0b0a0          STR      r11,[r0,#0xa0]
;;;194          wsptr[DCTSIZE*6] = dcval;
0000b6  f8ddb000          LDR      r11,[sp,#0]
0000ba  f8c0b0c0          STR      r11,[r0,#0xc0]
;;;195          wsptr[DCTSIZE*7] = dcval;
0000be  f8ddb000          LDR      r11,[sp,#0]
0000c2  f8c0b0e0          STR      r11,[r0,#0xe0]
;;;196          
;;;197          inptr++;			/* advance pointers to next column */
0000c6  1c89              ADDS     r1,r1,#2
;;;198          quantptr++;
0000c8  f1080804          ADD      r8,r8,#4
;;;199          wsptr++;
0000cc  1d00              ADDS     r0,r0,#4
;;;200          continue;
0000ce  e0eb              B        |L1.680|
                  |L1.208|
;;;201        }
;;;202        
;;;203        /* Even part: reverse the even part of the forward DCT. */
;;;204        /* The rotator is sqrt(2)*c(-6). */
;;;205        
;;;206        z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
0000d0  f9b1b020          LDRSH    r11,[r1,#0x20]
0000d4  f8d8e040          LDR      lr,[r8,#0x40]
0000d8  fb0bfc0e          MUL      r12,r11,lr
;;;207        z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
0000dc  f9b1b060          LDRSH    r11,[r1,#0x60]
0000e0  f8d8e0c0          LDR      lr,[r8,#0xc0]
0000e4  fb0bf70e          MUL      r7,r11,lr
;;;208        
;;;209        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
0000e8  eb0c0b07          ADD      r11,r12,r7
0000ec  f2411e51          MOV      lr,#0x1151
0000f0  fb0bf90e          MUL      r9,r11,lr
;;;210        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
0000f4  f8dfb478          LDR      r11,|L1.1392|
0000f8  fb0b9507          MLA      r5,r11,r7,r9
;;;211        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
0000fc  f6404b3f          MOV      r11,#0xc3f
000100  fb0cfb0b          MUL      r11,r12,r11
000104  eb09064b          ADD      r6,r9,r11,LSL #1
;;;212        
;;;213        z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
000108  f9b1b000          LDRSH    r11,[r1,#0]
00010c  f8d8e000          LDR      lr,[r8,#0]
000110  fb0bfc0e          MUL      r12,r11,lr
;;;214        z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
000114  f9b1b040          LDRSH    r11,[r1,#0x40]
000118  f8d8e080          LDR      lr,[r8,#0x80]
00011c  fb0bf70e          MUL      r7,r11,lr
;;;215    
;;;216        tmp0 = (z2 + z3) << CONST_BITS;
000120  eb0c0b07          ADD      r11,r12,r7
000124  ea4f334b          LSL      r3,r11,#13
;;;217        tmp1 = (z2 - z3) << CONST_BITS;
000128  ebac0b07          SUB      r11,r12,r7
00012c  ea4f344b          LSL      r4,r11,#13
;;;218        
;;;219        tmp10 = tmp0 + tmp3;
000130  eb030b06          ADD      r11,r3,r6
000134  f8cdb11c          STR      r11,[sp,#0x11c]
;;;220        tmp13 = tmp0 - tmp3;
000138  eba30b06          SUB      r11,r3,r6
00013c  f8cdb110          STR      r11,[sp,#0x110]
;;;221        tmp11 = tmp1 + tmp2;
000140  eb040b05          ADD      r11,r4,r5
000144  f8cdb118          STR      r11,[sp,#0x118]
;;;222        tmp12 = tmp1 - tmp2;
000148  eba40b05          SUB      r11,r4,r5
00014c  f8cdb114          STR      r11,[sp,#0x114]
;;;223        
;;;224        /* Odd part per figure 8; the matrix is unitary and hence its
;;;225         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
;;;226         */
;;;227        
;;;228        tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
000150  f9b1b070          LDRSH    r11,[r1,#0x70]
000154  f8d8e0e0          LDR      lr,[r8,#0xe0]
000158  fb0bf30e          MUL      r3,r11,lr
;;;229        tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
00015c  f9b1b050          LDRSH    r11,[r1,#0x50]
000160  f8d8e0a0          LDR      lr,[r8,#0xa0]
000164  fb0bf40e          MUL      r4,r11,lr
;;;230        tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
000168  f9b1b030          LDRSH    r11,[r1,#0x30]
00016c  f8d8e060          LDR      lr,[r8,#0x60]
000170  fb0bf50e          MUL      r5,r11,lr
;;;231        tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
000174  f9b1b010          LDRSH    r11,[r1,#0x10]
000178  f8d8e020          LDR      lr,[r8,#0x20]
00017c  fb0bf60e          MUL      r6,r11,lr
;;;232        
;;;233        z1 = tmp0 + tmp3;
000180  eb030906          ADD      r9,r3,r6
;;;234        z2 = tmp1 + tmp2;
000184  eb040c05          ADD      r12,r4,r5
;;;235        z3 = tmp0 + tmp2;
000188  195f              ADDS     r7,r3,r5
;;;236        z4 = tmp1 + tmp3;
00018a  eb040a06          ADD      r10,r4,r6
;;;237        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
00018e  eb070b0a          ADD      r11,r7,r10
000192  f2425ea1          MOV      lr,#0x25a1
000196  fb0bfb0e          MUL      r11,r11,lr
00019a  f8cdb10c          STR      r11,[sp,#0x10c]
;;;238        
;;;239        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
00019e  f6401b8e          MOV      r11,#0x98e
0001a2  fb03f30b          MUL      r3,r3,r11
;;;240        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
0001a6  f2441bb3          MOV      r11,#0x41b3
0001aa  fb04f40b          MUL      r4,r4,r11
;;;241        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
0001ae  f2462b54          MOV      r11,#0x6254
0001b2  fb05f50b          MUL      r5,r5,r11
;;;242        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
0001b6  f2430b0b          MOV      r11,#0x300b
0001ba  fb06f60b          MUL      r6,r6,r11
;;;243        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
0001be  f8dfb3b4          LDR      r11,|L1.1396|
0001c2  fb09f90b          MUL      r9,r9,r11
;;;244        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
0001c6  f8dfb3b0          LDR      r11,|L1.1400|
0001ca  fb0cfc0b          MUL      r12,r12,r11
;;;245        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
0001ce  eba72b07          SUB      r11,r7,r7,LSL #8
0001d2  ebcb1b8b          RSB      r11,r11,r11,LSL #6
0001d6  ebab0787          SUB      r7,r11,r7,LSL #2
;;;246        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
0001da  f8dfb3a0          LDR      r11,|L1.1404|
0001de  fb0afa0b          MUL      r10,r10,r11
;;;247        
;;;248        z3 += z5;
0001e2  f8ddb10c          LDR      r11,[sp,#0x10c]
0001e6  445f              ADD      r7,r7,r11
;;;249        z4 += z5;
0001e8  f8ddb10c          LDR      r11,[sp,#0x10c]
0001ec  44da              ADD      r10,r10,r11
;;;250        
;;;251        tmp0 += z1 + z3;
0001ee  eb090b07          ADD      r11,r9,r7
0001f2  445b              ADD      r3,r3,r11
;;;252        tmp1 += z2 + z4;
0001f4  eb0c0b0a          ADD      r11,r12,r10
0001f8  445c              ADD      r4,r4,r11
;;;253        tmp2 += z2 + z3;
0001fa  eb0c0b07          ADD      r11,r12,r7
0001fe  445d              ADD      r5,r5,r11
;;;254        tmp3 += z1 + z4;
000200  eb090b0a          ADD      r11,r9,r10
000204  445e              ADD      r6,r6,r11
;;;255        
;;;256        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
;;;257        
;;;258        wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
000206  f8ddb11c          LDR      r11,[sp,#0x11c]
00020a  44b3              ADD      r11,r11,r6
00020c  f50b6b80          ADD      r11,r11,#0x400
000210  ea4f2beb          ASR      r11,r11,#11
000214  f8c0b000          STR      r11,[r0,#0]
;;;259        wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
000218  f8ddb11c          LDR      r11,[sp,#0x11c]
00021c  ebab0b06          SUB      r11,r11,r6
000220  f50b6b80          ADD      r11,r11,#0x400
000224  ea4f2beb          ASR      r11,r11,#11
000228  f8c0b0e0          STR      r11,[r0,#0xe0]
;;;260        wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
00022c  f8ddb118          LDR      r11,[sp,#0x118]
000230  44ab              ADD      r11,r11,r5
000232  f50b6b80          ADD      r11,r11,#0x400
000236  ea4f2beb          ASR      r11,r11,#11
00023a  f8c0b020          STR      r11,[r0,#0x20]
;;;261        wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
00023e  f8ddb118          LDR      r11,[sp,#0x118]
000242  ebab0b05          SUB      r11,r11,r5
000246  f50b6b80          ADD      r11,r11,#0x400
00024a  ea4f2beb          ASR      r11,r11,#11
00024e  f8c0b0c0          STR      r11,[r0,#0xc0]
;;;262        wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
000252  f8ddb114          LDR      r11,[sp,#0x114]
000256  44a3              ADD      r11,r11,r4
000258  f50b6b80          ADD      r11,r11,#0x400
00025c  ea4f2beb          ASR      r11,r11,#11
000260  f8c0b040          STR      r11,[r0,#0x40]
;;;263        wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
000264  f8ddb114          LDR      r11,[sp,#0x114]
000268  ebab0b04          SUB      r11,r11,r4
00026c  f50b6b80          ADD      r11,r11,#0x400
000270  ea4f2beb          ASR      r11,r11,#11
000274  f8c0b0a0          STR      r11,[r0,#0xa0]
;;;264        wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
000278  f8ddb110          LDR      r11,[sp,#0x110]
00027c  449b              ADD      r11,r11,r3
00027e  f50b6b80          ADD      r11,r11,#0x400
000282  ea4f2beb          ASR      r11,r11,#11
000286  f8c0b060          STR      r11,[r0,#0x60]
;;;265        wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
00028a  f8ddb110          LDR      r11,[sp,#0x110]
00028e  ebab0b03          SUB      r11,r11,r3
000292  f50b6b80          ADD      r11,r11,#0x400
000296  ea4f2beb          ASR      r11,r11,#11
00029a  f8c0b080          STR      r11,[r0,#0x80]
;;;266        
;;;267        inptr++;			/* advance pointers to next column */
00029e  1c89              ADDS     r1,r1,#2
;;;268        quantptr++;
0002a0  f1080804          ADD      r8,r8,#4
;;;269        wsptr++;
0002a4  1d00              ADDS     r0,r0,#4
0002a6  bf00              NOP                            ;200
                  |L1.680|
0002a8  f8ddb104          LDR      r11,[sp,#0x104]       ;171
0002ac  f1ab0b01          SUB      r11,r11,#1            ;171
0002b0  f8cdb104          STR      r11,[sp,#0x104]       ;171
                  |L1.692|
0002b4  f8ddb104          LDR      r11,[sp,#0x104]       ;171
0002b8  f1bb0f00          CMP      r11,#0                ;171
0002bc  f73faeb6          BGT      |L1.44|
;;;270      }
;;;271      
;;;272      /* Pass 2: process rows from work array, store into output array. */
;;;273      /* Note that we must descale the results by a factor of 8 == 2**3, */
;;;274      /* and also undo the PASS1_BITS scaling. */
;;;275    
;;;276      wsptr = workspace;
0002c0  a801              ADD      r0,sp,#4
;;;277      for (ctr = 0; ctr < DCTSIZE; ctr++) {
0002c2  f04f0b00          MOV      r11,#0
0002c6  f8cdb104          STR      r11,[sp,#0x104]
0002ca  e147              B        |L1.1372|
                  |L1.716|
;;;278        outptr = output_buf[ctr] + output_col;
0002cc  f8dde104          LDR      lr,[sp,#0x104]
0002d0  f8ddb12c          LDR      r11,[sp,#0x12c]
0002d4  f85be02e          LDR      lr,[r11,lr,LSL #2]
0002d8  f8ddb154          LDR      r11,[sp,#0x154]
0002dc  eb0e020b          ADD      r2,lr,r11
;;;279        /* Rows of zeroes can be exploited in the same way as we did with columns.
;;;280         * However, the column calculation has created many nonzero AC terms, so
;;;281         * the simplification applies less often (typically 5% to 10% of the time).
;;;282         * On machines with very fast multiplication, it's possible that the
;;;283         * test takes more time than it's worth.  In that case this section
;;;284         * may be commented out.
;;;285         */
;;;286        
;;;287    #ifndef NO_ZERO_ROW_TEST
;;;288        if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
0002e0  f8d0b004          LDR      r11,[r0,#4]
0002e4  f1bb0f00          CMP      r11,#0
0002e8  d14b              BNE      |L1.898|
0002ea  f8d0b008          LDR      r11,[r0,#8]
0002ee  f1bb0f00          CMP      r11,#0
0002f2  d146              BNE      |L1.898|
0002f4  f8d0b00c          LDR      r11,[r0,#0xc]
0002f8  f1bb0f00          CMP      r11,#0
0002fc  d141              BNE      |L1.898|
0002fe  f8d0b010          LDR      r11,[r0,#0x10]
000302  f1bb0f00          CMP      r11,#0
000306  d13c              BNE      |L1.898|
;;;289    	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
000308  f8d0b014          LDR      r11,[r0,#0x14]
00030c  f1bb0f00          CMP      r11,#0
000310  d137              BNE      |L1.898|
000312  f8d0b018          LDR      r11,[r0,#0x18]
000316  f1bb0f00          CMP      r11,#0
00031a  d132              BNE      |L1.898|
00031c  f8d0b01c          LDR      r11,[r0,#0x1c]
000320  f1bb0f00          CMP      r11,#0
000324  d12d              BNE      |L1.898|
;;;290          /* AC terms all zero */
;;;291          JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
000326  f8b0b000          LDRH     r11,[r0,#0]
00032a  f10b0b10          ADD      r11,r11,#0x10
00032e  f3cb1e49          UBFX     lr,r11,#5,#10
000332  f8ddb108          LDR      r11,[sp,#0x108]
000336  f81bb00e          LDRB     r11,[r11,lr]
00033a  f8cdb000          STR      r11,[sp,#0]
;;;292    				  & RANGE_MASK];
;;;293          
;;;294          outptr[0] = dcval;
00033e  f8ddb000          LDR      r11,[sp,#0]
000342  f882b000          STRB     r11,[r2,#0]
;;;295          outptr[1] = dcval;
000346  f8ddb000          LDR      r11,[sp,#0]
00034a  f882b001          STRB     r11,[r2,#1]
;;;296          outptr[2] = dcval;
00034e  f8ddb000          LDR      r11,[sp,#0]
000352  f882b002          STRB     r11,[r2,#2]
;;;297          outptr[3] = dcval;
000356  f8ddb000          LDR      r11,[sp,#0]
00035a  f882b003          STRB     r11,[r2,#3]
;;;298          outptr[4] = dcval;
00035e  f8ddb000          LDR      r11,[sp,#0]
000362  f882b004          STRB     r11,[r2,#4]
;;;299          outptr[5] = dcval;
000366  f8ddb000          LDR      r11,[sp,#0]
00036a  f882b005          STRB     r11,[r2,#5]
;;;300          outptr[6] = dcval;
00036e  f8ddb000          LDR      r11,[sp,#0]
000372  f882b006          STRB     r11,[r2,#6]
;;;301          outptr[7] = dcval;
000376  f8ddb000          LDR      r11,[sp,#0]
00037a  f882b007          STRB     r11,[r2,#7]
;;;302    
;;;303          wsptr += DCTSIZE;		/* advance pointer to next row */
00037e  3020              ADDS     r0,r0,#0x20
;;;304          continue;
000380  e0e6              B        |L1.1360|
                  |L1.898|
;;;305        }
;;;306    #endif
;;;307        
;;;308        /* Even part: reverse the even part of the forward DCT. */
;;;309        /* The rotator is sqrt(2)*c(-6). */
;;;310        
;;;311        z2 = (INT32) wsptr[2];
000382  f8d0c008          LDR      r12,[r0,#8]
;;;312        z3 = (INT32) wsptr[6];
000386  6987              LDR      r7,[r0,#0x18]
;;;313        
;;;314        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
000388  eb0c0b07          ADD      r11,r12,r7
00038c  f2411e51          MOV      lr,#0x1151
000390  fb0bf90e          MUL      r9,r11,lr
;;;315        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
000394  f8dfb1d8          LDR      r11,|L1.1392|
000398  fb0b9507          MLA      r5,r11,r7,r9
;;;316        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
00039c  f6404b3f          MOV      r11,#0xc3f
0003a0  fb0cfb0b          MUL      r11,r12,r11
0003a4  eb09064b          ADD      r6,r9,r11,LSL #1
;;;317        
;;;318        tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;
0003a8  f8d0e010          LDR      lr,[r0,#0x10]
0003ac  f8d0b000          LDR      r11,[r0,#0]
0003b0  44f3              ADD      r11,r11,lr
0003b2  ea4f334b          LSL      r3,r11,#13
;;;319        tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
0003b6  f8d0e010          LDR      lr,[r0,#0x10]
0003ba  f8d0b000          LDR      r11,[r0,#0]
0003be  ebab0b0e          SUB      r11,r11,lr
0003c2  ea4f344b          LSL      r4,r11,#13
;;;320        
;;;321        tmp10 = tmp0 + tmp3;
0003c6  eb030b06          ADD      r11,r3,r6
0003ca  f8cdb11c          STR      r11,[sp,#0x11c]
;;;322        tmp13 = tmp0 - tmp3;
0003ce  eba30b06          SUB      r11,r3,r6
0003d2  f8cdb110          STR      r11,[sp,#0x110]
;;;323        tmp11 = tmp1 + tmp2;
0003d6  eb040b05          ADD      r11,r4,r5
0003da  f8cdb118          STR      r11,[sp,#0x118]
;;;324        tmp12 = tmp1 - tmp2;
0003de  eba40b05          SUB      r11,r4,r5
0003e2  f8cdb114          STR      r11,[sp,#0x114]
;;;325        
;;;326        /* Odd part per figure 8; the matrix is unitary and hence its
;;;327         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
;;;328         */
;;;329        
;;;330        tmp0 = (INT32) wsptr[7];
0003e6  69c3              LDR      r3,[r0,#0x1c]
;;;331        tmp1 = (INT32) wsptr[5];
0003e8  6944              LDR      r4,[r0,#0x14]
;;;332        tmp2 = (INT32) wsptr[3];
0003ea  68c5              LDR      r5,[r0,#0xc]
;;;333        tmp3 = (INT32) wsptr[1];
0003ec  6846              LDR      r6,[r0,#4]
;;;334        
;;;335        z1 = tmp0 + tmp3;
0003ee  eb030906          ADD      r9,r3,r6
;;;336        z2 = tmp1 + tmp2;
0003f2  eb040c05          ADD      r12,r4,r5
;;;337        z3 = tmp0 + tmp2;
0003f6  195f              ADDS     r7,r3,r5
;;;338        z4 = tmp1 + tmp3;
0003f8  eb040a06          ADD      r10,r4,r6
;;;339        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
0003fc  eb070b0a          ADD      r11,r7,r10
000400  f2425ea1          MOV      lr,#0x25a1
000404  fb0bfb0e          MUL      r11,r11,lr
000408  f8cdb10c          STR      r11,[sp,#0x10c]
;;;340        
;;;341        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
00040c  f6401b8e          MOV      r11,#0x98e
000410  fb03f30b          MUL      r3,r3,r11
;;;342        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
000414  f2441bb3          MOV      r11,#0x41b3
000418  fb04f40b          MUL      r4,r4,r11
;;;343        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
00041c  f2462b54          MOV      r11,#0x6254
000420  fb05f50b          MUL      r5,r5,r11
;;;344        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
000424  f2430b0b          MOV      r11,#0x300b
000428  fb06f60b          MUL      r6,r6,r11
;;;345        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
00042c  f8dfb144          LDR      r11,|L1.1396|
000430  fb09f90b          MUL      r9,r9,r11
;;;346        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
000434  f8dfb140          LDR      r11,|L1.1400|
000438  fb0cfc0b          MUL      r12,r12,r11
;;;347        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
00043c  eba72b07          SUB      r11,r7,r7,LSL #8
000440  ebcb1b8b          RSB      r11,r11,r11,LSL #6
000444  ebab0787          SUB      r7,r11,r7,LSL #2
;;;348        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
000448  f8dfb130          LDR      r11,|L1.1404|
00044c  fb0afa0b          MUL      r10,r10,r11
;;;349        
;;;350        z3 += z5;
000450  f8ddb10c          LDR      r11,[sp,#0x10c]
000454  445f              ADD      r7,r7,r11
;;;351        z4 += z5;
000456  f8ddb10c          LDR      r11,[sp,#0x10c]
00045a  44da              ADD      r10,r10,r11
;;;352        
;;;353        tmp0 += z1 + z3;
00045c  eb090b07          ADD      r11,r9,r7
000460  445b              ADD      r3,r3,r11
;;;354        tmp1 += z2 + z4;
000462  eb0c0b0a          ADD      r11,r12,r10
000466  445c              ADD      r4,r4,r11
;;;355        tmp2 += z2 + z3;
000468  eb0c0b07          ADD      r11,r12,r7
00046c  445d              ADD      r5,r5,r11
;;;356        tmp3 += z1 + z4;
00046e  eb090b0a          ADD      r11,r9,r10
000472  445e              ADD      r6,r6,r11
;;;357        
;;;358        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
;;;359        
;;;360        outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,
000474  f8ddb11c          LDR      r11,[sp,#0x11c]
000478  44b3              ADD      r11,r11,r6
00047a  f50b3b00          ADD      r11,r11,#0x20000
00047e  f3cb4e89          UBFX     lr,r11,#18,#10
000482  f8ddb108          LDR      r11,[sp,#0x108]
000486  f81bb00e          LDRB     r11,[r11,lr]
00048a  f882b000          STRB     r11,[r2,#0]
;;;361    					  CONST_BITS+PASS1_BITS+3)
;;;362    			    & RANGE_MASK];
;;;363        outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
00048e  f8ddb11c          LDR      r11,[sp,#0x11c]
000492  ebab0b06          SUB      r11,r11,r6
000496  f50b3b00          ADD      r11,r11,#0x20000
00049a  f3cb4e89          UBFX     lr,r11,#18,#10
00049e  f8ddb108          LDR      r11,[sp,#0x108]
0004a2  f81bb00e          LDRB     r11,[r11,lr]
0004a6  f882b007          STRB     r11,[r2,#7]
;;;364    					  CONST_BITS+PASS1_BITS+3)
;;;365    			    & RANGE_MASK];
;;;366        outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,
0004aa  f8ddb118          LDR      r11,[sp,#0x118]
0004ae  44ab              ADD      r11,r11,r5
0004b0  f50b3b00          ADD      r11,r11,#0x20000
0004b4  f3cb4e89          UBFX     lr,r11,#18,#10
0004b8  f8ddb108          LDR      r11,[sp,#0x108]
0004bc  f81bb00e          LDRB     r11,[r11,lr]
0004c0  f882b001          STRB     r11,[r2,#1]
;;;367    					  CONST_BITS+PASS1_BITS+3)
;;;368    			    & RANGE_MASK];
;;;369        outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
0004c4  f8ddb118          LDR      r11,[sp,#0x118]
0004c8  ebab0b05          SUB      r11,r11,r5
0004cc  f50b3b00          ADD      r11,r11,#0x20000
0004d0  f3cb4e89          UBFX     lr,r11,#18,#10
0004d4  f8ddb108          LDR      r11,[sp,#0x108]
0004d8  f81bb00e          LDRB     r11,[r11,lr]
0004dc  f882b006          STRB     r11,[r2,#6]
;;;370    					  CONST_BITS+PASS1_BITS+3)
;;;371    			    & RANGE_MASK];
;;;372        outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,
0004e0  f8ddb114          LDR      r11,[sp,#0x114]
0004e4  44a3              ADD      r11,r11,r4
0004e6  f50b3b00          ADD      r11,r11,#0x20000
0004ea  f3cb4e89          UBFX     lr,r11,#18,#10
0004ee  f8ddb108          LDR      r11,[sp,#0x108]
0004f2  f81bb00e          LDRB     r11,[r11,lr]
0004f6  f882b002          STRB     r11,[r2,#2]
;;;373    					  CONST_BITS+PASS1_BITS+3)
;;;374    			    & RANGE_MASK];
;;;375        outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
0004fa  f8ddb114          LDR      r11,[sp,#0x114]
0004fe  ebab0b04          SUB      r11,r11,r4
000502  f50b3b00          ADD      r11,r11,#0x20000
000506  f3cb4e89          UBFX     lr,r11,#18,#10
00050a  f8ddb108          LDR      r11,[sp,#0x108]
00050e  f81bb00e          LDRB     r11,[r11,lr]
000512  f882b005          STRB     r11,[r2,#5]
;;;376    					  CONST_BITS+PASS1_BITS+3)
;;;377    			    & RANGE_MASK];
;;;378        outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,
000516  f8ddb110          LDR      r11,[sp,#0x110]
00051a  449b              ADD      r11,r11,r3
00051c  f50b3b00          ADD      r11,r11,#0x20000
000520  f3cb4e89          UBFX     lr,r11,#18,#10
000524  f8ddb108          LDR      r11,[sp,#0x108]
000528  f81bb00e          LDRB     r11,[r11,lr]
00052c  f882b003          STRB     r11,[r2,#3]
;;;379    					  CONST_BITS+PASS1_BITS+3)
;;;380    			    & RANGE_MASK];
;;;381        outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
000530  f8ddb110          LDR      r11,[sp,#0x110]
000534  ebab0b03          SUB      r11,r11,r3
000538  f50b3b00          ADD      r11,r11,#0x20000
00053c  f3cb4e89          UBFX     lr,r11,#18,#10
000540  f8ddb108          LDR      r11,[sp,#0x108]
000544  f81bb00e          LDRB     r11,[r11,lr]
000548  f882b004          STRB     r11,[r2,#4]
;;;382    					  CONST_BITS+PASS1_BITS+3)
;;;383    			    & RANGE_MASK];
;;;384        
;;;385        wsptr += DCTSIZE;		/* advance pointer to next row */
00054c  3020              ADDS     r0,r0,#0x20
00054e  bf00              NOP                            ;304
                  |L1.1360|
000550  f8ddb104          LDR      r11,[sp,#0x104]       ;277
000554  f10b0b01          ADD      r11,r11,#1            ;277
000558  f8cdb104          STR      r11,[sp,#0x104]       ;277
                  |L1.1372|
00055c  f8ddb104          LDR      r11,[sp,#0x104]       ;277
000560  f1bb0f08          CMP      r11,#8                ;277
000564  f6ffaeb2          BLT      |L1.716|
;;;386      }
;;;387    }
000568  b04c              ADD      sp,sp,#0x130
00056a  e8bd8ff0          POP      {r4-r11,pc}
;;;388    
                          ENDP

00056e  0000              DCW      0x0000
                  |L1.1392|
                          DCD      0xffffc4df
                  |L1.1396|
                          DCD      0xffffe333
                  |L1.1400|
                          DCD      0xffffadfd
                  |L1.1404|
                          DCD      0xfffff384
