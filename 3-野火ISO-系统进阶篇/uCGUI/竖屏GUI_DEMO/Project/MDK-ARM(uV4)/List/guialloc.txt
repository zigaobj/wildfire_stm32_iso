; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\guialloc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\guialloc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\Core\GUIAlloc.c]
                          THUMB

                          AREA ||i.GUI_ALLOC_AllocNoInit||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_AllocNoInit PROC
;;;356    */
;;;357    GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;358      GUI_HMEM hMem;
;;;359      if (Size == 0) {
000004  b90c              CBNZ     r4,|L1.10|
;;;360        return (GUI_HMEM)0;
000006  2000              MOVS     r0,#0
                  |L1.8|
;;;361      }
;;;362      GUI_LOCK();
;;;363      GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
;;;364      hMem = _Alloc(Size);
;;;365      GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
;;;366      GUI_UNLOCK();
;;;367      return hMem;
;;;368    }
000008  bd70              POP      {r4-r6,pc}
                  |L1.10|
00000a  f7fffffe          BL       GUI_Lock
00000e  4620              MOV      r0,r4                 ;364
000010  f7fffffe          BL       _Alloc
000014  4605              MOV      r5,r0                 ;364
000016  f7fffffe          BL       GUI_Unlock
00001a  4628              MOV      r0,r5                 ;367
00001c  e7f4              B        |L1.8|
;;;369    
                          ENDP


                          AREA ||i.GUI_ALLOC_Free||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_Free PROC
;;;608    */
;;;609    void GUI_ALLOC_Free(GUI_HMEM hMem) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;610      if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
000004  b904              CBNZ     r4,|L2.8|
                  |L2.6|
;;;611        return;
;;;612      }
;;;613      GUI_LOCK();
;;;614      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;615      _Free(hMem);
;;;616      GUI_UNLOCK();
;;;617    }
000006  bd10              POP      {r4,pc}
                  |L2.8|
000008  f7fffffe          BL       GUI_Lock
00000c  4620              MOV      r0,r4                 ;615
00000e  f7fffffe          BL       _Free
000012  f7fffffe          BL       GUI_Unlock
000016  bf00              NOP      
000018  e7f5              B        |L2.6|
;;;618    
                          ENDP


                          AREA ||i.GUI_ALLOC_FreePtr||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_FreePtr PROC
;;;623    */
;;;624    void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;625      GUI_LOCK();
000004  f7fffffe          BL       GUI_Lock
;;;626      GUI_ALLOC_Free(*ph);
000008  f9b40000          LDRSH    r0,[r4,#0]
00000c  f7fffffe          BL       GUI_ALLOC_Free
;;;627      *ph =0;
000010  2000              MOVS     r0,#0
000012  8020              STRH     r0,[r4,#0]
;;;628      GUI_UNLOCK();
000014  f7fffffe          BL       GUI_Unlock
;;;629    }
000018  bd10              POP      {r4,pc}
;;;630    
                          ENDP


                          AREA ||i.GUI_ALLOC_FreePtrArray||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_FreePtrArray PROC
;;;634    */
;;;635    void GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;636      int i;
;;;637      for (i = 0; i < NumElems; i++) {
000006  2400              MOVS     r4,#0
000008  e004              B        |L4.20|
                  |L4.10|
;;;638        GUI_ALLOC_FreePtr(&pArray[i]);
00000a  eb050044          ADD      r0,r5,r4,LSL #1
00000e  f7fffffe          BL       GUI_ALLOC_FreePtr
000012  1c64              ADDS     r4,r4,#1              ;637
                  |L4.20|
000014  42b4              CMP      r4,r6                 ;637
000016  dbf8              BLT      |L4.10|
;;;639      }
;;;640    }
000018  bd70              POP      {r4-r6,pc}
;;;641    
                          ENDP


                          AREA ||i.GUI_ALLOC_GetMaxSize||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetMaxSize PROC
;;;431    */
;;;432    GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;433      GUI_ALLOC_DATATYPE r = 0;
000004  2700              MOVS     r7,#0
;;;434      GUI_ALLOC_DATATYPE NumFreeBytes;
;;;435      int i, iNext;
;;;436    
;;;437      GUI_LOCK();
000006  f7fffffe          BL       GUI_Lock
;;;438      _CheckInit();
00000a  f7fffffe          BL       _CheckInit
;;;439      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
00000e  2500              MOVS     r5,#0
000010  e010              B        |L5.52|
                  |L5.18|
;;;440        NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000012  4815              LDR      r0,|L5.104|
000014  f8300035          LDRH     r0,[r0,r5,LSL #3]
000018  4913              LDR      r1,|L5.104|
00001a  eb0101c5          ADD      r1,r1,r5,LSL #3
00001e  8849              LDRH     r1,[r1,#2]
000020  4408              ADD      r0,r0,r1
000022  4911              LDR      r1,|L5.104|
000024  f8311036          LDRH     r1,[r1,r6,LSL #3]
000028  1a08              SUBS     r0,r1,r0
00002a  b204              SXTH     r4,r0
;;;441        if (NumFreeBytes > r) {
00002c  42bc              CMP      r4,r7
00002e  dd00              BLE      |L5.50|
;;;442          r = NumFreeBytes;
000030  4627              MOV      r7,r4
                  |L5.50|
000032  4635              MOV      r5,r6                 ;439
                  |L5.52|
000034  480c              LDR      r0,|L5.104|
000036  eb0000c5          ADD      r0,r0,r5,LSL #3       ;439
00003a  8886              LDRH     r6,[r0,#4]            ;439
00003c  2e00              CMP      r6,#0                 ;439
00003e  d1e8              BNE      |L5.18|
;;;443        }
;;;444      }
;;;445      /* Check last block */
;;;446      NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
000040  4809              LDR      r0,|L5.104|
000042  f8300035          LDRH     r0,[r0,r5,LSL #3]
000046  4908              LDR      r1,|L5.104|
000048  eb0101c5          ADD      r1,r1,r5,LSL #3
00004c  8849              LDRH     r1,[r1,#2]
00004e  4408              ADD      r0,r0,r1
000050  f6446120          MOV      r1,#0x4e20
000054  1a08              SUBS     r0,r1,r0
000056  b204              SXTH     r4,r0
;;;447      if (NumFreeBytes > r) {
000058  42bc              CMP      r4,r7
00005a  dd00              BLE      |L5.94|
;;;448        r = NumFreeBytes;
00005c  4627              MOV      r7,r4
                  |L5.94|
;;;449      }
;;;450      GUI_UNLOCK();
00005e  f7fffffe          BL       GUI_Unlock
;;;451      return r;
000062  4638              MOV      r0,r7
;;;452    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;453    
                          ENDP

                  |L5.104|
                          DCD      aBlock

                          AREA ||i.GUI_ALLOC_GetNumFreeBlocks||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumFreeBlocks PROC
;;;401    */
;;;402    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void) {
000000  b510              PUSH     {r4,lr}
;;;403      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;404      return GUI_ALLOC.NumFreeBlocks;
000006  4802              LDR      r0,|L6.16|
000008  8880              LDRH     r0,[r0,#4]  ; GUI_ALLOC
00000a  b200              SXTH     r0,r0
;;;405    }
00000c  bd10              POP      {r4,pc}
;;;406    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetNumFreeBytes||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumFreeBytes PROC
;;;392    */
;;;393    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;394      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;395      return GUI_ALLOC.NumFreeBytes;
000006  4802              LDR      r0,|L7.16|
000008  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;396    }
00000c  bd10              POP      {r4,pc}
;;;397    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetNumUsedBlocks||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumUsedBlocks PROC
;;;419    */
;;;420    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void) {
000000  b510              PUSH     {r4,lr}
;;;421      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;422      return GUI_ALLOC.NumUsedBlocks;
000006  4802              LDR      r0,|L8.16|
000008  8800              LDRH     r0,[r0,#0]  ; GUI_ALLOC
00000a  b200              SXTH     r0,r0
;;;423    }
00000c  bd10              POP      {r4,pc}
;;;424    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetNumUsedBytes||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumUsedBytes PROC
;;;410    */
;;;411    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;412      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;413      return GUI_ALLOC.NumUsedBytes;
000006  4802              LDR      r0,|L9.16|
000008  f9b0000c          LDRSH    r0,[r0,#0xc]  ; GUI_ALLOC
;;;414    }
00000c  bd10              POP      {r4,pc}
;;;415    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      GUI_ALLOC

                          AREA ||i.GUI_ALLOC_GetSize||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_GetSize PROC
;;;594    */
;;;595    GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;596      GUI_ALLOC_DATATYPE r;
;;;597    
;;;598      r = 0;
000004  2500              MOVS     r5,#0
;;;599      if (hMem) {
000006  b11c              CBZ      r4,|L10.16|
;;;600        r = _GetSize(hMem);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _GetSize
00000e  4605              MOV      r5,r0
                  |L10.16|
;;;601      }
;;;602      return r;
000010  4628              MOV      r0,r5
;;;603    }
000012  bd70              POP      {r4-r6,pc}
;;;604    
                          ENDP


                          AREA ||i.GUI_ALLOC_Init||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Init PROC
;;;340    */
;;;341    void GUI_ALLOC_Init(void) {
000000  f2402072          MOV      r0,#0x272
;;;342      GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
;;;343      GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
000004  4909              LDR      r1,|L11.44|
000006  6048              STR      r0,[r1,#4]  ; GUI_ALLOC
000008  6088              STR      r0,[r1,#8]  ; GUI_ALLOC
;;;344      GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
00000a  f6446020          MOV      r0,#0x4e20
00000e  81c8              STRH     r0,[r1,#0xe]
000010  8208              STRH     r0,[r1,#0x10]
;;;345      GUI_ALLOC.NumUsedBlocks = 0;
000012  2000              MOVS     r0,#0
000014  6008              STR      r0,[r1,#0]  ; GUI_ALLOC
;;;346      GUI_ALLOC.NumUsedBytes = 0;
000016  8188              STRH     r0,[r1,#0xc]
;;;347      aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
000018  2004              MOVS     r0,#4
00001a  4905              LDR      r1,|L11.48|
00001c  8048              STRH     r0,[r1,#2]
;;;348      aBlock[0].Off  = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;349      aBlock[0].Next = 0;
000022  8088              STRH     r0,[r1,#4]
;;;350      IsInitialized =1;
000024  2001              MOVS     r0,#1
000026  4903              LDR      r1,|L11.52|
000028  7008              STRB     r0,[r1,#0]
;;;351    }
00002a  4770              BX       lr
;;;352    
                          ENDP

                  |L11.44|
                          DCD      GUI_ALLOC
                  |L11.48|
                          DCD      aBlock
                  |L11.52|
                          DCD      IsInitialized

                          AREA ||i.GUI_ALLOC_Lock||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Lock PROC
;;;461    */
;;;462    void GUI_ALLOC_Lock(void) {
000000  4802              LDR      r0,|L12.12|
;;;463      _LockCnt++;
000002  6800              LDR      r0,[r0,#0]  ; _LockCnt
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L12.12|
000008  6008              STR      r0,[r1,#0]  ; _LockCnt
;;;464    }
00000a  4770              BX       lr
;;;465    
                          ENDP

                  |L12.12|
                          DCD      _LockCnt

                          AREA ||i.GUI_ALLOC_Unlock||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Unlock PROC
;;;473    */
;;;474    void GUI_ALLOC_Unlock(void) {
000000  4802              LDR      r0,|L13.12|
;;;475      _LockCnt--;
000002  6800              LDR      r0,[r0,#0]  ; _LockCnt
000004  1e40              SUBS     r0,r0,#1
000006  4901              LDR      r1,|L13.12|
000008  6008              STR      r0,[r1,#0]  ; _LockCnt
;;;476    }
00000a  4770              BX       lr
;;;477    
                          ENDP

                  |L13.12|
                          DCD      _LockCnt

                          AREA ||i.GUI_ALLOC_h2p||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_h2p PROC
;;;373    */
;;;374    void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
000000  4601              MOV      r1,r0
;;;375      GUI_ASSERT_LOCK();
;;;376      #if GUI_DEBUG_LEVEL > 0
;;;377        if (!hMem) {
000002  b909              CBNZ     r1,|L14.8|
;;;378          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;379          return 0;
000004  2000              MOVS     r0,#0
                  |L14.6|
;;;380        }
;;;381        if (aBlock[hMem].Size == 0) {
;;;382          GUI_DEBUG_ERROROUT("Dereferencing free block");
;;;383        }
;;;384    
;;;385      #endif
;;;386      return HMEM2PTR(hMem);
;;;387    }
000006  4770              BX       lr
                  |L14.8|
000008  4802              LDR      r0,|L14.20|
00000a  f9300031          LDRSH    r0,[r0,r1,LSL #3]     ;386
00000e  4a02              LDR      r2,|L14.24|
000010  4410              ADD      r0,r0,r2              ;386
000012  e7f8              B        |L14.6|
;;;388    
                          ENDP

                  |L14.20|
                          DCD      aBlock
                  |L14.24|
                          DCD      GUI_Heap

                          AREA ||i._Alloc||, CODE, READONLY, ALIGN=2

                  _Alloc PROC
;;;278    */
;;;279    static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;280      GUI_HMEM hMemNew, hMemIns;
;;;281      _CheckInit();
000004  f7fffffe          BL       _CheckInit
;;;282      size = _Size2LegalSize(size);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       _Size2LegalSize
00000e  4606              MOV      r6,r0
;;;283      /* Check if memory is available at all ...*/
;;;284      if (size > _GetNumFreeBytes()) {
000010  f7fffffe          BL       _GetNumFreeBytes
000014  42b0              CMP      r0,r6
000016  da01              BGE      |L15.28|
;;;285        GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
;;;286        return 0;
000018  2000              MOVS     r0,#0
                  |L15.26|
;;;287      }
;;;288      /* Locate free handle */
;;;289      if ((hMemNew = _FindFreeHandle()) == 0) {
;;;290        return 0;
;;;291      }
;;;292      /* Locate or Create hole of sufficient size */
;;;293      hMemIns = _FindHole(size);
;;;294      #if GUI_ALLOC_AUTDEFRAG
;;;295        if (hMemIns == -1) {
;;;296          if (_LockCnt == 0) {
;;;297            hMemIns = _CreateHole(size);
;;;298          }
;;;299        }
;;;300      #endif
;;;301      /* Occupy hole */
;;;302      if (hMemIns==-1) {
;;;303        GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
;;;304        return 0;
;;;305    	}
;;;306      {
;;;307        GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
;;;308        int Next = aBlock[hMemIns].Next;
;;;309        aBlock[hMemNew].Size  = size;
;;;310        aBlock[hMemNew].Off   = Off;
;;;311        if ((aBlock[hMemNew].Next  = Next) >0) {
;;;312          aBlock[Next].Prev = hMemNew;  
;;;313        }
;;;314        aBlock[hMemNew].Prev  = hMemIns;
;;;315        aBlock[hMemIns].Next  = hMemNew;
;;;316      }
;;;317      /* Keep track of number of blocks and av. memory */
;;;318      GUI_ALLOC.NumUsedBlocks++;
;;;319      GUI_ALLOC.NumFreeBlocks--;
;;;320      if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
;;;321        GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
;;;322      }
;;;323      GUI_ALLOC.NumUsedBytes += size;
;;;324      GUI_ALLOC.NumFreeBytes -= size;
;;;325      if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
;;;326        GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
;;;327      }
;;;328      return hMemNew;
;;;329    }
00001a  bd70              POP      {r4-r6,pc}
                  |L15.28|
00001c  f7fffffe          BL       _FindFreeHandle
000020  0005              MOVS     r5,r0                 ;289
000022  d100              BNE      |L15.38|
000024  e7f9              B        |L15.26|
                  |L15.38|
000026  4630              MOV      r0,r6                 ;293
000028  f7fffffe          BL       _FindHole
00002c  4604              MOV      r4,r0                 ;293
00002e  1c60              ADDS     r0,r4,#1              ;295
000030  d106              BNE      |L15.64|
000032  482c              LDR      r0,|L15.228|
000034  6800              LDR      r0,[r0,#0]            ;296  ; _LockCnt
000036  b918              CBNZ     r0,|L15.64|
000038  4630              MOV      r0,r6                 ;297
00003a  f7fffffe          BL       _CreateHole
00003e  4604              MOV      r4,r0                 ;297
                  |L15.64|
000040  1c60              ADDS     r0,r4,#1              ;302
000042  d100              BNE      |L15.70|
000044  e7e9              B        |L15.26|
                  |L15.70|
000046  4a28              LDR      r2,|L15.232|
000048  f8322034          LDRH     r2,[r2,r4,LSL #3]     ;307
00004c  4b26              LDR      r3,|L15.232|
00004e  eb0303c4          ADD      r3,r3,r4,LSL #3       ;307
000052  885b              LDRH     r3,[r3,#2]            ;307
000054  441a              ADD      r2,r2,r3              ;307
000056  b211              SXTH     r1,r2                 ;307
000058  4a23              LDR      r2,|L15.232|
00005a  eb0202c4          ADD      r2,r2,r4,LSL #3       ;308
00005e  8890              LDRH     r0,[r2,#4]            ;308
000060  4a21              LDR      r2,|L15.232|
000062  eb0202c5          ADD      r2,r2,r5,LSL #3       ;309
000066  8056              STRH     r6,[r2,#2]            ;309
000068  4a1f              LDR      r2,|L15.232|
00006a  f8221035          STRH     r1,[r2,r5,LSL #3]     ;310
00006e  eb0202c5          ADD      r2,r2,r5,LSL #3       ;311
000072  8090              STRH     r0,[r2,#4]            ;311
000074  2800              CMP      r0,#0                 ;311
000076  dd03              BLE      |L15.128|
000078  4b1b              LDR      r3,|L15.232|
00007a  eb0303c0          ADD      r3,r3,r0,LSL #3       ;312
00007e  80dd              STRH     r5,[r3,#6]            ;312
                  |L15.128|
000080  4b19              LDR      r3,|L15.232|
000082  eb0303c5          ADD      r3,r3,r5,LSL #3       ;314
000086  80dc              STRH     r4,[r3,#6]            ;314
000088  4b17              LDR      r3,|L15.232|
00008a  eb0303c4          ADD      r3,r3,r4,LSL #3       ;315
00008e  809d              STRH     r5,[r3,#4]            ;315
000090  4816              LDR      r0,|L15.236|
000092  6800              LDR      r0,[r0,#0]            ;318  ; GUI_ALLOC
000094  1c40              ADDS     r0,r0,#1              ;318
000096  4915              LDR      r1,|L15.236|
000098  6008              STR      r0,[r1,#0]            ;318  ; GUI_ALLOC
00009a  4608              MOV      r0,r1                 ;319
00009c  6840              LDR      r0,[r0,#4]            ;319  ; GUI_ALLOC
00009e  1e40              SUBS     r0,r0,#1              ;319
0000a0  6048              STR      r0,[r1,#4]            ;319  ; GUI_ALLOC
0000a2  4608              MOV      r0,r1                 ;320
0000a4  6880              LDR      r0,[r0,#8]            ;320  ; GUI_ALLOC
0000a6  6849              LDR      r1,[r1,#4]            ;320  ; GUI_ALLOC
0000a8  4288              CMP      r0,r1                 ;320
0000aa  dd03              BLE      |L15.180|
0000ac  480f              LDR      r0,|L15.236|
0000ae  6840              LDR      r0,[r0,#4]            ;321  ; GUI_ALLOC
0000b0  490e              LDR      r1,|L15.236|
0000b2  6088              STR      r0,[r1,#8]            ;321  ; GUI_ALLOC
                  |L15.180|
0000b4  480d              LDR      r0,|L15.236|
0000b6  8980              LDRH     r0,[r0,#0xc]          ;323  ; GUI_ALLOC
0000b8  4430              ADD      r0,r0,r6              ;323
0000ba  b200              SXTH     r0,r0                 ;323
0000bc  490b              LDR      r1,|L15.236|
0000be  8188              STRH     r0,[r1,#0xc]          ;323
0000c0  4608              MOV      r0,r1                 ;324
0000c2  89c0              LDRH     r0,[r0,#0xe]          ;324  ; GUI_ALLOC
0000c4  1b80              SUBS     r0,r0,r6              ;324
0000c6  b200              SXTH     r0,r0                 ;324
0000c8  81c8              STRH     r0,[r1,#0xe]          ;324
0000ca  4608              MOV      r0,r1                 ;325
0000cc  f9b00010          LDRSH    r0,[r0,#0x10]         ;325  ; GUI_ALLOC
0000d0  f9b1100e          LDRSH    r1,[r1,#0xe]          ;325  ; GUI_ALLOC
0000d4  4288              CMP      r0,r1                 ;325
0000d6  dd03              BLE      |L15.224|
0000d8  4804              LDR      r0,|L15.236|
0000da  89c0              LDRH     r0,[r0,#0xe]          ;326  ; GUI_ALLOC
0000dc  4903              LDR      r1,|L15.236|
0000de  8208              STRH     r0,[r1,#0x10]         ;326
                  |L15.224|
0000e0  4628              MOV      r0,r5                 ;328
0000e2  e79a              B        |L15.26|
;;;330    
                          ENDP

                  |L15.228|
                          DCD      _LockCnt
                  |L15.232|
                          DCD      aBlock
                  |L15.236|
                          DCD      GUI_ALLOC

                          AREA ||i._CheckInit||, CODE, READONLY, ALIGN=2

                  _CheckInit PROC
;;;256    */
;;;257    static void _CheckInit(void) {
000000  b500              PUSH     {lr}
;;;258      if (!IsInitialized) {
000002  4803              LDR      r0,|L16.16|
000004  7800              LDRB     r0,[r0,#0]  ; IsInitialized
000006  b908              CBNZ     r0,|L16.12|
;;;259        GUI_ALLOC_Init();
000008  f7fffffe          BL       GUI_ALLOC_Init
                  |L16.12|
;;;260      }
;;;261    }
00000c  bd00              POP      {pc}
;;;262    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      IsInitialized

                          AREA ||i._CreateHole||, CODE, READONLY, ALIGN=2

                  _CreateHole PROC
;;;231    */
;;;232    static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;233      int i, iNext;
;;;234      int r = -1;
000006  f04f39ff          MOV      r9,#0xffffffff
;;;235      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
00000a  2400              MOVS     r4,#0
00000c  e038              B        |L17.128|
                  |L17.14|
;;;236        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
00000e  4829              LDR      r0,|L17.180|
000010  f8300034          LDRH     r0,[r0,r4,LSL #3]
000014  4927              LDR      r1,|L17.180|
000016  eb0101c4          ADD      r1,r1,r4,LSL #3
00001a  8849              LDRH     r1,[r1,#2]
00001c  4408              ADD      r0,r0,r1
00001e  4925              LDR      r1,|L17.180|
000020  f8311035          LDRH     r1,[r1,r5,LSL #3]
000024  1a08              SUBS     r0,r1,r0
000026  fa0ffa80          SXTH     r10,r0
;;;237        if (NumFreeBytes < Size) {
00002a  45b2              CMP      r10,r6
00002c  da27              BGE      |L17.126|
;;;238          GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
00002e  4821              LDR      r0,|L17.180|
000030  f8300034          LDRH     r0,[r0,r4,LSL #3]
000034  491f              LDR      r1,|L17.180|
000036  eb0101c4          ADD      r1,r1,r4,LSL #3
00003a  8849              LDRH     r1,[r1,#2]
00003c  4408              ADD      r0,r0,r1
00003e  491d              LDR      r1,|L17.180|
000040  f8311035          LDRH     r1,[r1,r5,LSL #3]
000044  1a08              SUBS     r0,r1,r0
000046  b207              SXTH     r7,r0
;;;239          if (NumBytesBeforeBlock) {
000048  b1c7              CBZ      r7,|L17.124|
;;;240            U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
00004a  481a              LDR      r0,|L17.180|
00004c  f9300035          LDRSH    r0,[r0,r5,LSL #3]
000050  4919              LDR      r1,|L17.184|
000052  eb000801          ADD      r8,r0,r1
;;;241            memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
000056  4917              LDR      r1,|L17.180|
000058  eb0101c5          ADD      r1,r1,r5,LSL #3
00005c  f9b12002          LDRSH    r2,[r1,#2]
000060  eba80007          SUB      r0,r8,r7
000064  4641              MOV      r1,r8
000066  f7fffffe          BL       __aeabi_memmove
;;;242            aBlock[iNext].Off -=NumBytesBeforeBlock;
00006a  4812              LDR      r0,|L17.180|
00006c  f8300035          LDRH     r0,[r0,r5,LSL #3]
000070  1bc0              SUBS     r0,r0,r7
000072  b200              SXTH     r0,r0
000074  490f              LDR      r1,|L17.180|
000076  f8210035          STRH     r0,[r1,r5,LSL #3]
;;;243          }
00007a  bf00              NOP      
                  |L17.124|
;;;244        }
00007c  bf00              NOP      
                  |L17.126|
00007e  462c              MOV      r4,r5                 ;235
                  |L17.128|
000080  480c              LDR      r0,|L17.180|
000082  eb0000c4          ADD      r0,r0,r4,LSL #3       ;235
000086  8885              LDRH     r5,[r0,#4]            ;235
000088  2d00              CMP      r5,#0                 ;235
00008a  d1c0              BNE      |L17.14|
;;;245      }
;;;246      /* Check last block */
;;;247      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
00008c  4809              LDR      r0,|L17.180|
00008e  f9300034          LDRSH    r0,[r0,r4,LSL #3]
000092  4908              LDR      r1,|L17.180|
000094  eb0101c4          ADD      r1,r1,r4,LSL #3
000098  f9b11002          LDRSH    r1,[r1,#2]
00009c  4408              ADD      r0,r0,r1
00009e  f6446120          MOV      r1,#0x4e20
0000a2  1a08              SUBS     r0,r1,r0
0000a4  42b0              CMP      r0,r6
0000a6  db00              BLT      |L17.170|
;;;248        r = i;
0000a8  46a1              MOV      r9,r4
                  |L17.170|
;;;249      }
;;;250      return r;
0000aa  fa0ff089          SXTH     r0,r9
;;;251    }
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;252    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L17.180|
                          DCD      aBlock
                  |L17.184|
                          DCD      GUI_Heap

                          AREA ||i._FindFreeHandle||, CODE, READONLY, ALIGN=2

                  _FindFreeHandle PROC
;;;188    */
;;;189    static GUI_HMEM _FindFreeHandle(void) {
000000  4809              LDR      r0,|L18.40|
;;;190      int i;
;;;191      for (i = _FirstFreeHandle; i < GUI_MAXBLOCKS; i++) {
000002  6801              LDR      r1,[r0,#0]  ; _FirstFreeHandle
000004  e009              B        |L18.26|
                  |L18.6|
;;;192        if (aBlock[i].Size == 0) {
000006  4809              LDR      r0,|L18.44|
000008  eb0000c1          ADD      r0,r0,r1,LSL #3
00000c  8840              LDRH     r0,[r0,#2]
00000e  b918              CBNZ     r0,|L18.24|
;;;193          _FirstFreeHandle = i;
000010  4805              LDR      r0,|L18.40|
000012  6001              STR      r1,[r0,#0]  ; _FirstFreeHandle
;;;194          return i;
000014  b208              SXTH     r0,r1
                  |L18.22|
;;;195        }
;;;196      }
;;;197      GUI_DEBUG_ERROROUT1("Insufficient memory handles configured (GUI_MAXBLOCKS == %d (See GUIConf.h))", GUI_MAXBLOCKS);
;;;198      return GUI_HMEM_NULL;
;;;199    }
000016  4770              BX       lr
                  |L18.24|
000018  1c49              ADDS     r1,r1,#1              ;191
                  |L18.26|
00001a  f2402073          MOV      r0,#0x273             ;191
00001e  4281              CMP      r1,r0                 ;191
000020  dbf1              BLT      |L18.6|
000022  2000              MOVS     r0,#0                 ;198
000024  e7f7              B        |L18.22|
;;;200    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      _FirstFreeHandle
                  |L18.44|
                          DCD      aBlock

                          AREA ||i._FindHole||, CODE, READONLY, ALIGN=2

                  _FindHole PROC
;;;208    */
;;;209    static GUI_HMEM _FindHole(GUI_ALLOC_DATATYPE Size) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;210      int i, iNext;
;;;211      for (i=0; (iNext = aBlock[i].Next) != 0; i = iNext) {
000004  2100              MOVS     r1,#0
000006  e011              B        |L19.44|
                  |L19.8|
;;;212        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
000008  4815              LDR      r0,|L19.96|
00000a  f8300031          LDRH     r0,[r0,r1,LSL #3]
00000e  4d14              LDR      r5,|L19.96|
000010  eb0505c1          ADD      r5,r5,r1,LSL #3
000014  886d              LDRH     r5,[r5,#2]
000016  4428              ADD      r0,r0,r5
000018  4d11              LDR      r5,|L19.96|
00001a  f8355033          LDRH     r5,[r5,r3,LSL #3]
00001e  1a28              SUBS     r0,r5,r0
000020  b204              SXTH     r4,r0
;;;213        if (NumFreeBytes>=Size) {
000022  4294              CMP      r4,r2
000024  db01              BLT      |L19.42|
;;;214          return i;
000026  b208              SXTH     r0,r1
                  |L19.40|
;;;215        }
;;;216      }
;;;217      /* Check last block */
;;;218      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
;;;219        return i;
;;;220      }
;;;221      return -1;
;;;222    }
000028  bd30              POP      {r4,r5,pc}
                  |L19.42|
00002a  4619              MOV      r1,r3                 ;211
                  |L19.44|
00002c  480c              LDR      r0,|L19.96|
00002e  eb0000c1          ADD      r0,r0,r1,LSL #3       ;211
000032  8883              LDRH     r3,[r0,#4]            ;211
000034  2b00              CMP      r3,#0                 ;211
000036  d1e7              BNE      |L19.8|
000038  4809              LDR      r0,|L19.96|
00003a  f9300031          LDRSH    r0,[r0,r1,LSL #3]     ;218
00003e  4c08              LDR      r4,|L19.96|
000040  eb0404c1          ADD      r4,r4,r1,LSL #3       ;218
000044  f9b44002          LDRSH    r4,[r4,#2]            ;218
000048  4420              ADD      r0,r0,r4              ;218
00004a  f6446420          MOV      r4,#0x4e20            ;218
00004e  1a20              SUBS     r0,r4,r0              ;218
000050  4290              CMP      r0,r2                 ;218
000052  db01              BLT      |L19.88|
000054  b208              SXTH     r0,r1                 ;219
000056  e7e7              B        |L19.40|
                  |L19.88|
000058  f04f30ff          MOV      r0,#0xffffffff        ;221
00005c  e7e4              B        |L19.40|
;;;223    
                          ENDP

00005e  0000              DCW      0x0000
                  |L19.96|
                          DCD      aBlock

                          AREA ||i._Free||, CODE, READONLY, ALIGN=2

                  _Free PROC
;;;148    */
;;;149    static void _Free(GUI_HMEM hMem) {
000000  b530              PUSH     {r4,r5,lr}
;;;150      GUI_ALLOC_DATATYPE Size;
;;;151      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;152      /* Do some error checking ... */
;;;153      #if GUI_DEBUG_LEVEL>0
;;;154        /* Block not allocated ? */
;;;155        if (aBlock[hMem].Size == 0) {
000002  491e              LDR      r1,|L20.124|
000004  eb0101c0          ADD      r1,r1,r0,LSL #3
000008  8849              LDRH     r1,[r1,#2]
00000a  b901              CBNZ     r1,|L20.14|
                  |L20.12|
;;;156          GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
;;;157          return;
;;;158        }
;;;159      #endif
;;;160      Size = aBlock[hMem].Size;
;;;161      #ifdef WIN32
;;;162        GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
;;;163      #endif
;;;164      GUI_ALLOC.NumFreeBytes += Size;
;;;165      GUI_ALLOC.NumUsedBytes -= Size;
;;;166      aBlock[hMem].Size = 0;
;;;167      if (_FirstFreeHandle > hMem) {
;;;168        _FirstFreeHandle = hMem;
;;;169      }
;;;170      {
;;;171        int Next = aBlock[hMem].Next;
;;;172        int Prev = aBlock[hMem].Prev;
;;;173        aBlock[Prev].Next = Next;
;;;174        if (Next) {
;;;175          aBlock[Next].Prev = Prev;
;;;176        }
;;;177      }  
;;;178      GUI_ALLOC.NumFreeBlocks++;
;;;179      GUI_ALLOC.NumUsedBlocks--;
;;;180    }
00000c  bd30              POP      {r4,r5,pc}
                  |L20.14|
00000e  491b              LDR      r1,|L20.124|
000010  eb0101c0          ADD      r1,r1,r0,LSL #3       ;160
000014  f9b12002          LDRSH    r2,[r1,#2]            ;160
000018  4919              LDR      r1,|L20.128|
00001a  89c9              LDRH     r1,[r1,#0xe]          ;164  ; GUI_ALLOC
00001c  4411              ADD      r1,r1,r2              ;164
00001e  b209              SXTH     r1,r1                 ;164
000020  4b17              LDR      r3,|L20.128|
000022  81d9              STRH     r1,[r3,#0xe]          ;164
000024  4619              MOV      r1,r3                 ;165
000026  8989              LDRH     r1,[r1,#0xc]          ;165  ; GUI_ALLOC
000028  1a89              SUBS     r1,r1,r2              ;165
00002a  b209              SXTH     r1,r1                 ;165
00002c  8199              STRH     r1,[r3,#0xc]          ;165
00002e  2100              MOVS     r1,#0                 ;166
000030  4b12              LDR      r3,|L20.124|
000032  eb0303c0          ADD      r3,r3,r0,LSL #3       ;166
000036  8059              STRH     r1,[r3,#2]            ;166
000038  4912              LDR      r1,|L20.132|
00003a  6809              LDR      r1,[r1,#0]            ;167  ; _FirstFreeHandle
00003c  4281              CMP      r1,r0                 ;167
00003e  dd01              BLE      |L20.68|
000040  4910              LDR      r1,|L20.132|
000042  6008              STR      r0,[r1,#0]            ;168  ; _FirstFreeHandle
                  |L20.68|
000044  4c0d              LDR      r4,|L20.124|
000046  eb0404c0          ADD      r4,r4,r0,LSL #3       ;171
00004a  88a1              LDRH     r1,[r4,#4]            ;171
00004c  4c0b              LDR      r4,|L20.124|
00004e  eb0404c0          ADD      r4,r4,r0,LSL #3       ;172
000052  88e3              LDRH     r3,[r4,#6]            ;172
000054  4c09              LDR      r4,|L20.124|
000056  eb0404c3          ADD      r4,r4,r3,LSL #3       ;173
00005a  80a1              STRH     r1,[r4,#4]            ;173
00005c  b119              CBZ      r1,|L20.102|
00005e  4d07              LDR      r5,|L20.124|
000060  eb0505c1          ADD      r5,r5,r1,LSL #3       ;175
000064  80eb              STRH     r3,[r5,#6]            ;175
                  |L20.102|
000066  4906              LDR      r1,|L20.128|
000068  6849              LDR      r1,[r1,#4]            ;178  ; GUI_ALLOC
00006a  1c49              ADDS     r1,r1,#1              ;178
00006c  4b04              LDR      r3,|L20.128|
00006e  6059              STR      r1,[r3,#4]            ;178  ; GUI_ALLOC
000070  4619              MOV      r1,r3                 ;179
000072  6809              LDR      r1,[r1,#0]            ;179  ; GUI_ALLOC
000074  1e49              SUBS     r1,r1,#1              ;179
000076  6019              STR      r1,[r3,#0]            ;179  ; GUI_ALLOC
000078  bf00              NOP      
00007a  e7c7              B        |L20.12|
;;;181    
                          ENDP

                  |L20.124|
                          DCD      aBlock
                  |L20.128|
                          DCD      GUI_ALLOC
                  |L20.132|
                          DCD      _FirstFreeHandle

                          AREA ||i._GetNumFreeBytes||, CODE, READONLY, ALIGN=2

                  _GetNumFreeBytes PROC
;;;266    */
;;;267    static GUI_ALLOC_DATATYPE _GetNumFreeBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;268      if (_LockCnt) {
000002  4805              LDR      r0,|L21.24|
000004  6800              LDR      r0,[r0,#0]  ; _LockCnt
000006  b110              CBZ      r0,|L21.14|
;;;269        return GUI_ALLOC_GetMaxSize();
000008  f7fffffe          BL       GUI_ALLOC_GetMaxSize
                  |L21.12|
;;;270      } else {
;;;271        return GUI_ALLOC.NumFreeBytes;  
;;;272      }
;;;273    }
00000c  bd10              POP      {r4,pc}
                  |L21.14|
00000e  4803              LDR      r0,|L21.28|
000010  f9b0000e          LDRSH    r0,[r0,#0xe]          ;271  ; GUI_ALLOC
000014  e7fa              B        |L21.12|
;;;274    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      _LockCnt
                  |L21.28|
                          DCD      GUI_ALLOC

                          AREA ||i._GetSize||, CODE, READONLY, ALIGN=2

                  _GetSize PROC
;;;140    */
;;;141    static GUI_ALLOC_DATATYPE _GetSize(GUI_HMEM  hMem) {
000000  4601              MOV      r1,r0
;;;142      return aBlock[hMem].Size;
000002  4803              LDR      r0,|L22.16|
000004  eb0000c1          ADD      r0,r0,r1,LSL #3
000008  f9b00002          LDRSH    r0,[r0,#2]
;;;143    }
00000c  4770              BX       lr
;;;144    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      aBlock

                          AREA ||i._Size2LegalSize||, CODE, READONLY, ALIGN=1

                  _Size2LegalSize PROC
;;;132    */
;;;133    static GUI_ALLOC_DATATYPE _Size2LegalSize(GUI_ALLOC_DATATYPE size) {
000000  4601              MOV      r1,r0
;;;134      return (size + ((1 << GUI_BLOCK_ALIGN) - 1)) & ~((1 << GUI_BLOCK_ALIGN) - 1);
000002  1cc8              ADDS     r0,r1,#3
000004  f0200003          BIC      r0,r0,#3
000008  b200              SXTH     r0,r0
;;;135    }
00000a  4770              BX       lr
;;;136      
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GUI_Heap
                          %        20000
                  aBlock
                          %        5016
                  GUI_ALLOC
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  IsInitialized
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _FirstFreeHandle
                          DCD      0x00000001
                  _LockCnt
                          DCD      0x00000000
