; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\gui_jpeg.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\gui_jpeg.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\uCGUI\JPEG\GUI_JPEG.c]
                          THUMB

                          AREA ||i.GUI_JPEG_Draw||, CODE, READONLY, ALIGN=2

                  GUI_JPEG_Draw PROC
;;;355    */
;;;356    int GUI_JPEG_Draw(const void * pFileData, int DataSize, int x0, int y0) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  f5ad7d19          SUB      sp,sp,#0x264
000008  4607              MOV      r7,r0
00000a  4688              MOV      r8,r1
00000c  4615              MOV      r5,r2
00000e  461c              MOV      r4,r3
;;;357      #if (GUI_WINSUPPORT)
;;;358        GUI_RECT r;
;;;359      #endif
;;;360      int Ret = 0;
000010  f04f0900          MOV      r9,#0
;;;361      GUI_HMEM hBuffer = 0;
000014  2600              MOVS     r6,#0
;;;362    	struct jpeg_decompress_struct cinfo;
;;;363    	struct jpeg_error_mgr jerr;
;;;364      GUI_LOCK();
000016  f7fffffe          BL       GUI_Lock
;;;365      _Init(&jerr, &cinfo, pFileData, DataSize);
00001a  4643              MOV      r3,r8
00001c  463a              MOV      r2,r7
00001e  a922              ADD      r1,sp,#0x88
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       _Init
;;;366      #if (GUI_WINSUPPORT)
;;;367        WM_ADDORG(x0,y0);
000026  4833              LDR      r0,|L1.244|
000028  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
00002a  4405              ADD      r5,r5,r0
00002c  4831              LDR      r0,|L1.244|
00002e  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
000030  4404              ADD      r4,r4,r0
;;;368        r.x1 = (r.x0 = x0) + cinfo.image_width - 1;
000032  b228              SXTH     r0,r5
000034  f8ad0258          STRH     r0,[sp,#0x258]
000038  9929              LDR      r1,[sp,#0xa4]
00003a  4408              ADD      r0,r0,r1
00003c  1e40              SUBS     r0,r0,#1
00003e  b200              SXTH     r0,r0
000040  f8ad025c          STRH     r0,[sp,#0x25c]
;;;369        r.y1 = (r.y0 = y0) + cinfo.image_height - 1;
000044  b220              SXTH     r0,r4
000046  f8ad025a          STRH     r0,[sp,#0x25a]
00004a  992a              LDR      r1,[sp,#0xa8]
00004c  4408              ADD      r0,r0,r1
00004e  1e40              SUBS     r0,r0,#1
000050  b200              SXTH     r0,r0
000052  f8ad025e          STRH     r0,[sp,#0x25e]
;;;370        WM_ITERATE_START(&r) {
000056  a896              ADD      r0,sp,#0x258
000058  f7fffffe          BL       WM__InitIVRSearch
00005c  2800              CMP      r0,#0
00005e  d03e              BEQ      |L1.222|
000060  bf00              NOP      
                  |L1.98|
;;;371      #endif
;;;372        if (hBuffer) {
000062  b12e              CBZ      r6,|L1.112|
;;;373          _Init(&jerr, &cinfo, pFileData, DataSize);
000064  4643              MOV      r3,r8
000066  463a              MOV      r2,r7
000068  a922              ADD      r1,sp,#0x88
00006a  a801              ADD      r0,sp,#4
00006c  f7fffffe          BL       _Init
                  |L1.112|
;;;374        }
;;;375        /* 4. Set up parameters for decompression (optional ...) */
;;;376        /* 5. jpeg_start_decompress(...); Should normally return quickly */
;;;377    	  jpeg_start_decompress(&cinfo);
000070  a822              ADD      r0,sp,#0x88
000072  f7fffffe          BL       jpeg_start_decompress
;;;378        /* 6. while (scan lines remain to be read) */
;;;379    	  /*     jpeg_read_scanlines(...); */
;;;380        if (!hBuffer) {
000076  b936              CBNZ     r6,|L1.134|
;;;381          hBuffer = GUI_ALLOC_AllocNoInit(cinfo.image_width * 3);
000078  9929              LDR      r1,[sp,#0xa4]
00007a  eb010141          ADD      r1,r1,r1,LSL #1
00007e  b208              SXTH     r0,r1
000080  f7fffffe          BL       GUI_ALLOC_AllocNoInit
000084  4606              MOV      r6,r0
                  |L1.134|
;;;382        }
;;;383        while (cinfo.output_scanline < cinfo.output_height) {
000086  e01c              B        |L1.194|
                  |L1.136|
;;;384          U8* p;
;;;385          p = (U8*)GUI_ALLOC_h2p(hBuffer);
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       GUI_ALLOC_h2p
00008e  9000              STR      r0,[sp,#0]
;;;386          jpeg_read_scanlines(&cinfo, &p, 1);
000090  2201              MOVS     r2,#1
000092  4669              MOV      r1,sp
000094  a822              ADD      r0,sp,#0x88
000096  f7fffffe          BL       jpeg_read_scanlines
;;;387          if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {
00009a  f89d00b0          LDRB     r0,[sp,#0xb0]
00009e  2801              CMP      r0,#1
0000a0  d107              BNE      |L1.178|
;;;388            _WritePixelsGray(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
0000a2  9845              LDR      r0,[sp,#0x114]
0000a4  1902              ADDS     r2,r0,r4
0000a6  4629              MOV      r1,r5
0000a8  9b29              LDR      r3,[sp,#0xa4]
0000aa  9800              LDR      r0,[sp,#0]
0000ac  f7fffffe          BL       _WritePixelsGray
0000b0  e006              B        |L1.192|
                  |L1.178|
;;;389          } else {
;;;390            _WritePixelsRGB(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
0000b2  9845              LDR      r0,[sp,#0x114]
0000b4  1902              ADDS     r2,r0,r4
0000b6  4629              MOV      r1,r5
0000b8  9b29              LDR      r3,[sp,#0xa4]
0000ba  9800              LDR      r0,[sp,#0]
0000bc  f7fffffe          BL       _WritePixelsRGB
                  |L1.192|
;;;391          }
;;;392        }
0000c0  bf00              NOP      
                  |L1.194|
0000c2  993f              LDR      r1,[sp,#0xfc]         ;383
0000c4  9845              LDR      r0,[sp,#0x114]        ;383
0000c6  4288              CMP      r0,r1                 ;383
0000c8  d3de              BCC      |L1.136|
;;;393        /* 7. jpeg_finish_decompress(...); */
;;;394        /*    Complete the decompression cycle.  This causes working memory associated */
;;;395        /*    with the JPEG object to be released. */
;;;396    	  jpeg_finish_decompress(&cinfo);
0000ca  a822              ADD      r0,sp,#0x88
0000cc  f7fffffe          BL       jpeg_finish_decompress
;;;397        /* 8. Release the JPEG decompression object. */
;;;398        jpeg_destroy_decompress(&cinfo);
0000d0  a822              ADD      r0,sp,#0x88
0000d2  f7fffffe          BL       jpeg_destroy_decompress
;;;399      #if (GUI_WINSUPPORT)
;;;400        } WM_ITERATE_END();
0000d6  f7fffffe          BL       WM__GetNextIVR
0000da  2800              CMP      r0,#0
0000dc  d1c1              BNE      |L1.98|
                  |L1.222|
;;;401      #endif
;;;402      GUI_ALLOC_Free(hBuffer);
0000de  4630              MOV      r0,r6
0000e0  f7fffffe          BL       GUI_ALLOC_Free
;;;403      GUI_UNLOCK();
0000e4  f7fffffe          BL       GUI_Unlock
;;;404      return Ret;
0000e8  4648              MOV      r0,r9
;;;405    }
0000ea  f50d7d19          ADD      sp,sp,#0x264
0000ee  e8bd83f0          POP      {r4-r9,pc}
;;;406    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L1.244|
                          DCD      GUI_Context

                          AREA ||i.GUI_JPEG_GetInfo||, CODE, READONLY, ALIGN=1

                  GUI_JPEG_GetInfo PROC
;;;335    */
;;;336    int GUI_JPEG_GetInfo(const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo) {
000000  b570              PUSH     {r4-r6,lr}
000002  f5ad7d16          SUB      sp,sp,#0x258
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
;;;337    	struct jpeg_decompress_struct cinfo;
;;;338    	struct jpeg_error_mgr jerr;
;;;339      _Init(&jerr, &cinfo, pFileData, DataSize);
00000c  4633              MOV      r3,r6
00000e  462a              MOV      r2,r5
000010  a922              ADD      r1,sp,#0x88
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       _Init
;;;340      /*
;;;341       * Release the JPEG decompression object.
;;;342       */
;;;343      jpeg_destroy_decompress(&cinfo);
000018  a822              ADD      r0,sp,#0x88
00001a  f7fffffe          BL       jpeg_destroy_decompress
;;;344      if (pInfo) {
00001e  b11c              CBZ      r4,|L2.40|
;;;345        pInfo->XSize = cinfo.image_width;
000020  9829              LDR      r0,[sp,#0xa4]
000022  6020              STR      r0,[r4,#0]
;;;346        pInfo->YSize = cinfo.image_height;
000024  982a              LDR      r0,[sp,#0xa8]
000026  6060              STR      r0,[r4,#4]
                  |L2.40|
;;;347      }
;;;348      return 0;
000028  2000              MOVS     r0,#0
;;;349    }
00002a  f50d7d16          ADD      sp,sp,#0x258
00002e  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP


                          AREA ||i._FillInputBuffer||, CODE, READONLY, ALIGN=2

                  _FillInputBuffer PROC
;;;104    
;;;105    static boolean _FillInputBuffer(j_decompress_ptr cinfo) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
;;;106      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
000006  69ac              LDR      r4,[r5,#0x18]
;;;107      size_t nbytes;
;;;108      int RemBytes = pSrc->FileSize - pSrc->Off;
000008  e9d40108          LDRD     r0,r1,[r4,#0x20]
00000c  1a47              SUBS     r7,r0,r1
;;;109      if (RemBytes > 0) {
00000e  2f00              CMP      r7,#0
000010  dd0f              BLE      |L3.50|
;;;110        nbytes = (RemBytes > INPUT_BUF_SIZE) ? INPUT_BUF_SIZE : RemBytes;
000012  f5b75f80          CMP      r7,#0x1000
000016  dd02              BLE      |L3.30|
000018  f44f5080          MOV      r0,#0x1000
00001c  e000              B        |L3.32|
                  |L3.30|
00001e  4638              MOV      r0,r7
                  |L3.32|
000020  4606              MOV      r6,r0
;;;111        pSrc->pub.next_input_byte = pSrc->pFileData + pSrc->Off;
000022  6a61              LDR      r1,[r4,#0x24]
000024  69e0              LDR      r0,[r4,#0x1c]
000026  4408              ADD      r0,r0,r1
000028  6020              STR      r0,[r4,#0]
;;;112        pSrc->Off += nbytes;
00002a  6a60              LDR      r0,[r4,#0x24]
00002c  4430              ADD      r0,r0,r6
00002e  6260              STR      r0,[r4,#0x24]
000030  e014              B        |L3.92|
                  |L3.50|
;;;113      } else {
;;;114        if (pSrc->start_of_file)	/* Treat empty input file as fatal error */
000032  6aa0              LDR      r0,[r4,#0x28]
000034  b130              CBZ      r0,|L3.68|
;;;115          ERREXIT(cinfo, JERR_INPUT_EMPTY);
000036  202a              MOVS     r0,#0x2a
000038  6829              LDR      r1,[r5,#0]
00003a  6148              STR      r0,[r1,#0x14]
00003c  6828              LDR      r0,[r5,#0]
00003e  6801              LDR      r1,[r0,#0]
000040  4628              MOV      r0,r5
000042  4788              BLX      r1
                  |L3.68|
;;;116        WARNMS(cinfo, JWRN_JPEG_EOF);
000044  2078              MOVS     r0,#0x78
000046  6829              LDR      r1,[r5,#0]
000048  6148              STR      r0,[r1,#0x14]
00004a  6828              LDR      r0,[r5,#0]
00004c  f04f31ff          MOV      r1,#0xffffffff
000050  6842              LDR      r2,[r0,#4]
000052  4628              MOV      r0,r5
000054  4790              BLX      r2
;;;117        /* Insert a fake EOI marker */
;;;118        nbytes = 2;
000056  2602              MOVS     r6,#2
;;;119        pSrc->pub.next_input_byte = _abEnd;
000058  4803              LDR      r0,|L3.104|
00005a  6020              STR      r0,[r4,#0]
                  |L3.92|
;;;120      }
;;;121    
;;;122      pSrc->pub.bytes_in_buffer = nbytes;
00005c  6066              STR      r6,[r4,#4]
;;;123      pSrc->start_of_file = FALSE;
00005e  2000              MOVS     r0,#0
000060  62a0              STR      r0,[r4,#0x28]
;;;124      return TRUE;
000062  2001              MOVS     r0,#1
;;;125    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;126    
                          ENDP

                  |L3.104|
                          DCD      _abEnd

                          AREA ||i._Init||, CODE, READONLY, ALIGN=1

                  _Init PROC
;;;285    */
;;;286    static void _Init(struct jpeg_error_mgr* pjerr, struct jpeg_decompress_struct *pcinfo, const void * pFileData, int DataSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;287      /* 1. Allocate and initialize a JPEG decompression object. */
;;;288      pcinfo->err = jpeg_std_error(pjerr);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       jpeg_std_error
000012  6020              STR      r0,[r4,#0]
;;;289    	jpeg_create_decompress(pcinfo);
000014  f44f72e8          MOV      r2,#0x1d0
000018  213e              MOVS     r1,#0x3e
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       jpeg_CreateDecompress
;;;290      /* 2. Init the source manager so the library can retrieve data via methods */
;;;291      _InitSrc(pcinfo, (const U8*)pFileData, DataSize);
000020  4632              MOV      r2,r6
000022  4629              MOV      r1,r5
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _InitSrc
;;;292      /* 3. Call jpeg_read_header() to obtain image info. */
;;;293    	jpeg_read_header(pcinfo, TRUE);
00002a  2101              MOVS     r1,#1
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       jpeg_read_header
;;;294    }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;295    
                          ENDP


                          AREA ||i._InitSource||, CODE, READONLY, ALIGN=1

                  _InitSource PROC
;;;61     
;;;62     static void _InitSource (j_decompress_ptr cinfo) {
000000  6981              LDR      r1,[r0,#0x18]
;;;63       SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
;;;64     
;;;65       /* We reset the empty-input-file flag for each image,
;;;66        * but we don't clear the input buffer.
;;;67        * This is correct behavior for reading a series of images from one source.
;;;68        */
;;;69       pSrc->start_of_file = TRUE;
000002  2201              MOVS     r2,#1
000004  628a              STR      r2,[r1,#0x28]
;;;70     }
000006  4770              BX       lr
;;;71     
                          ENDP


                          AREA ||i._InitSrc||, CODE, READONLY, ALIGN=2

                  _InitSrc PROC
;;;180    
;;;181    static void _InitSrc(j_decompress_ptr cinfo, const U8* pFileData, I32 FileSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;182      SOURCE_MANAGER* pSrc;
;;;183      /* The source object and input buffer are made permanent so that a series
;;;184       * of JPEG images can be read from the same file by calling jpeg_stdio_src
;;;185       * only before the first one.  (If we discarded the buffer at the end of
;;;186       * one image, we'd likely lose the start of the next one.)
;;;187       * This makes it unsafe to use this manager and a different source
;;;188       * manager serially with the same JPEG object.  Caveat programmer.
;;;189       */
;;;190      if (cinfo->src == NULL) {	/* first time for this JPEG object? */
00000a  69a8              LDR      r0,[r5,#0x18]
00000c  b930              CBNZ     r0,|L6.28|
;;;191        cinfo->src = (jpeg_source_mgr *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof(SOURCE_MANAGER));
00000e  6868              LDR      r0,[r5,#4]
000010  222c              MOVS     r2,#0x2c
000012  2100              MOVS     r1,#0
000014  6803              LDR      r3,[r0,#0]
000016  4628              MOV      r0,r5
000018  4798              BLX      r3
00001a  61a8              STR      r0,[r5,#0x18]
                  |L6.28|
;;;192      }
;;;193      pSrc = (SOURCE_MANAGER*) cinfo->src;
00001c  69ac              LDR      r4,[r5,#0x18]
;;;194      pSrc->pub.init_source       = _InitSource;
00001e  4809              LDR      r0,|L6.68|
000020  60a0              STR      r0,[r4,#8]
;;;195      pSrc->pub.fill_input_buffer = _FillInputBuffer;
000022  4809              LDR      r0,|L6.72|
000024  60e0              STR      r0,[r4,#0xc]
;;;196      pSrc->pub.skip_input_data   = _SkipInputData;
000026  4809              LDR      r0,|L6.76|
000028  6120              STR      r0,[r4,#0x10]
;;;197      pSrc->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
00002a  4809              LDR      r0,|L6.80|
00002c  6160              STR      r0,[r4,#0x14]
;;;198      pSrc->pub.term_source       = _TermSource;
00002e  4809              LDR      r0,|L6.84|
000030  61a0              STR      r0,[r4,#0x18]
;;;199      pSrc->pub.bytes_in_buffer   = 0;    /* forces fill_input_buffer on first read */
000032  2000              MOVS     r0,#0
000034  6060              STR      r0,[r4,#4]
;;;200      pSrc->pub.next_input_byte   = NULL; /* until buffer loaded */
000036  6020              STR      r0,[r4,#0]
;;;201      /*
;;;202       *  Init private part of Source manager
;;;203       */
;;;204      pSrc->FileSize  = FileSize;
000038  6227              STR      r7,[r4,#0x20]
;;;205      pSrc->pFileData = pFileData;
00003a  61e6              STR      r6,[r4,#0x1c]
;;;206      pSrc->Off       = 0;
00003c  6260              STR      r0,[r4,#0x24]
;;;207    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;208    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      _InitSource
                  |L6.72|
                          DCD      _FillInputBuffer
                  |L6.76|
                          DCD      _SkipInputData
                  |L6.80|
                          DCD      jpeg_resync_to_restart
                  |L6.84|
                          DCD      _TermSource

                          AREA ||i._SkipInputData||, CODE, READONLY, ALIGN=1

                  _SkipInputData PROC
;;;138    
;;;139    static void _SkipInputData (j_decompress_ptr cinfo, long num_bytes) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;140      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
000006  69b5              LDR      r5,[r6,#0x18]
;;;141      /* Just a dumb implementation for now.  Could use fseek() except
;;;142       * it doesn't work on pipes.  Not clear that being smart is worth
;;;143       * any trouble anyway --- large skips are infrequent.
;;;144       */
;;;145      if (num_bytes > 0) {
000008  2c00              CMP      r4,#0
00000a  dd0e              BLE      |L7.42|
;;;146        while (num_bytes > (long) pSrc->pub.bytes_in_buffer) {
00000c  e004              B        |L7.24|
                  |L7.14|
;;;147          num_bytes -= (long) pSrc->pub.bytes_in_buffer;
00000e  6868              LDR      r0,[r5,#4]
000010  1a24              SUBS     r4,r4,r0
;;;148          (void) _FillInputBuffer(cinfo);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       _FillInputBuffer
                  |L7.24|
000018  6868              LDR      r0,[r5,#4]            ;146
00001a  42a0              CMP      r0,r4                 ;146
00001c  dbf7              BLT      |L7.14|
;;;149          /* note we assume that fill_input_buffer will never return FALSE,
;;;150           * so suspension need not be handled.
;;;151           */
;;;152        }
;;;153        pSrc->pub.next_input_byte += (size_t) num_bytes;
00001e  6828              LDR      r0,[r5,#0]
000020  4420              ADD      r0,r0,r4
000022  6028              STR      r0,[r5,#0]
;;;154        pSrc->pub.bytes_in_buffer -= (size_t) num_bytes;
000024  6868              LDR      r0,[r5,#4]
000026  1b00              SUBS     r0,r0,r4
000028  6068              STR      r0,[r5,#4]
                  |L7.42|
;;;155      }
;;;156    }
00002a  bd70              POP      {r4-r6,pc}
;;;157    /*
                          ENDP


                          AREA ||i._TermSource||, CODE, READONLY, ALIGN=1

                  _TermSource PROC
;;;174    
;;;175    static void _TermSource(j_decompress_ptr cinfo) {
000000  bf00              NOP      
;;;176      /* no work necessary here */
;;;177      GUI_USE_PARA(cinfo);
;;;178    }
000002  4770              BX       lr
;;;179    
                          ENDP


                          AREA ||i._WritePixelsGray||, CODE, READONLY, ALIGN=1

                  _WritePixelsGray PROC
;;;315    */
;;;316    static void _WritePixelsGray(const U8*p, int x0, int y0, int xSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;317      U8 u;
;;;318      while (xSize) {
00000c  e00d              B        |L9.42|
                  |L9.14|
;;;319        u = *p++;
00000e  f8148b01          LDRB     r8,[r4],#1
;;;320        LCD_SetColor(u * (U32)0x10101);
000012  eb082108          ADD      r1,r8,r8,LSL #8
000016  eb014008          ADD      r0,r1,r8,LSL #16
00001a  f7fffffe          BL       LCD_SetColor
;;;321        LCD_DrawPixel(x0++, y0);
00001e  4630              MOV      r0,r6
000020  1c76              ADDS     r6,r6,#1
000022  4639              MOV      r1,r7
000024  f7fffffe          BL       LCD_DrawPixel
;;;322        xSize--;
000028  1e6d              SUBS     r5,r5,#1
                  |L9.42|
00002a  2d00              CMP      r5,#0                 ;318
00002c  d1ef              BNE      |L9.14|
;;;323      }
;;;324    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;325    
                          ENDP


                          AREA ||i._WritePixelsRGB||, CODE, READONLY, ALIGN=1

                  _WritePixelsRGB PROC
;;;299    */
;;;300    static void _WritePixelsRGB(const U8*p, int x0, int y0, int xSize) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;301      U8 r,g,b;
;;;302      while (xSize) {
00000c  e011              B        |L10.50|
                  |L10.14|
;;;303        r = *p++;
00000e  f8148b01          LDRB     r8,[r4],#1
;;;304        g = *p++;
000012  f8149b01          LDRB     r9,[r4],#1
;;;305        b = *p++;
000016  f814ab01          LDRB     r10,[r4],#1
;;;306        LCD_SetColor(r | (g << 8) | (U32)((U32)b << 16));
00001a  ea482109          ORR      r1,r8,r9,LSL #8
00001e  ea41400a          ORR      r0,r1,r10,LSL #16
000022  f7fffffe          BL       LCD_SetColor
;;;307        LCD_DrawPixel(x0++, y0);
000026  4630              MOV      r0,r6
000028  1c76              ADDS     r6,r6,#1
00002a  4639              MOV      r1,r7
00002c  f7fffffe          BL       LCD_DrawPixel
;;;308        xSize--;
000030  1e6d              SUBS     r5,r5,#1
                  |L10.50|
000032  2d00              CMP      r5,#0                 ;302
000034  d1eb              BNE      |L10.14|
;;;309      }
;;;310    }
000036  e8bd87f0          POP      {r4-r10,pc}
;;;311    
                          ENDP


                          AREA ||i.jpeg_free_small||, CODE, READONLY, ALIGN=2

                  jpeg_free_small PROC
;;;230    
;;;231    GLOBAL(void) jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;232      GUI_USE_PARA(cinfo);
000008  bf00              NOP      
;;;233      GUI_USE_PARA(sizeofobject);
00000a  bf00              NOP      
;;;234      if (--AllocCnt) {
00000c  4806              LDR      r0,|L11.40|
00000e  6800              LDR      r0,[r0,#0]  ; AllocCnt
000010  1e40              SUBS     r0,r0,#1
000012  4905              LDR      r1,|L11.40|
000014  6008              STR      r0,[r1,#0]  ; AllocCnt
000016  d002              BEQ      |L11.30|
;;;235        TotalSize = 0;
000018  2000              MOVS     r0,#0
00001a  4904              LDR      r1,|L11.44|
00001c  6008              STR      r0,[r1,#0]  ; TotalSize
                  |L11.30|
;;;236      }
;;;237      free(object);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       free
;;;238    }
000024  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      AllocCnt
                  |L11.44|
                          DCD      TotalSize

                          AREA ||i.jpeg_get_small||, CODE, READONLY, ALIGN=2

                  jpeg_get_small PROC
;;;223    
;;;224    GLOBAL(void *) jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;225      GUI_USE_PARA(cinfo);
000006  bf00              NOP      
;;;226      AllocCnt++;
000008  4806              LDR      r0,|L12.36|
00000a  6800              LDR      r0,[r0,#0]  ; AllocCnt
00000c  1c40              ADDS     r0,r0,#1
00000e  4905              LDR      r1,|L12.36|
000010  6008              STR      r0,[r1,#0]  ; AllocCnt
;;;227      TotalSize += sizeofobject;
000012  4805              LDR      r0,|L12.40|
000014  6800              LDR      r0,[r0,#0]  ; TotalSize
000016  4420              ADD      r0,r0,r4
000018  4903              LDR      r1,|L12.40|
00001a  6008              STR      r0,[r1,#0]  ; TotalSize
;;;228      return (void *) malloc(sizeofobject);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       malloc
;;;229    }
000022  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

                  |L12.36|
                          DCD      AllocCnt
                  |L12.40|
                          DCD      TotalSize

                          AREA ||i.jpeg_mem_available||, CODE, READONLY, ALIGN=1

                  jpeg_mem_available PROC
;;;244    
;;;245    GLOBAL(long) jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;246      GUI_USE_PARA(cinfo);
000004  bf00              NOP      
;;;247      GUI_USE_PARA(min_bytes_needed);
000006  bf00              NOP      
;;;248      GUI_USE_PARA(already_allocated);
000008  bf00              NOP      
;;;249      return max_bytes_needed;
00000a  4610              MOV      r0,r2
;;;250    }
00000c  bd10              POP      {r4,pc}
;;;251    
                          ENDP


                          AREA ||i.jpeg_mem_init||, CODE, READONLY, ALIGN=1

                  jpeg_mem_init PROC
;;;258    
;;;259    GLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { 
000000  4601              MOV      r1,r0
;;;260      GUI_USE_PARA(cinfo);
000002  bf00              NOP      
;;;261      return 0;
000004  2000              MOVS     r0,#0
;;;262    }
000006  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.jpeg_mem_term||, CODE, READONLY, ALIGN=1

                  jpeg_mem_term PROC
;;;263    
;;;264    GLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {
000000  bf00              NOP      
;;;265      GUI_USE_PARA(cinfo);
;;;266    }
000002  4770              BX       lr
;;;267    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _abEnd
000000  ffd9              DCB      0xff,0xd9

                          AREA ||.data||, DATA, ALIGN=2

                  AllocCnt
                          DCD      0x00000000
                  TotalSize
                          DCD      0x00000000
