; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdhuff.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdhuff.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\jdhuff.crf ..\..\uCGUI\JPEG\jdhuff.c]
                          THUMB

                          AREA ||i.decode_mcu||, CODE, READONLY, ALIGN=2

                  decode_mcu PROC
;;;516    METHODDEF(boolean)
;;;517    decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;518    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4680              MOV      r8,r0
;;;519      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
000008  f8d861bc          LDR      r6,[r8,#0x1bc]
;;;520      int blkn;
;;;521      BITREAD_STATE_VARS;
;;;522      savable_state state;
;;;523    
;;;524      /* Process restart marker if needed; may have to suspend */
;;;525      if (cinfo->restart_interval) {
00000c  f8d80114          LDR      r0,[r8,#0x114]
000010  b148              CBZ      r0,|L1.38|
;;;526        if (entropy->restarts_to_go == 0)
000012  6a70              LDR      r0,[r6,#0x24]
000014  b938              CBNZ     r0,|L1.38|
;;;527          if (! process_restart(cinfo))
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       process_restart
00001c  b918              CBNZ     r0,|L1.38|
;;;528    	return FALSE;
00001e  2000              MOVS     r0,#0
                  |L1.32|
;;;529      }
;;;530    
;;;531      /* If we've run out of data, just leave the MCU set to zeroes.
;;;532       * This way, we return uniform gray for the remainder of the segment.
;;;533       */
;;;534      if (! entropy->pub.insufficient_data) {
;;;535    
;;;536        /* Load up working state */
;;;537        BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
;;;538        ASSIGN_STATE(state, entropy->saved);
;;;539    
;;;540        /* Outer loop handles each block in the MCU */
;;;541    
;;;542        for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
;;;543          JBLOCKROW block = MCU_data[blkn];
;;;544          d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
;;;545          d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
;;;546          register int s, k, r;
;;;547    
;;;548          /* Decode a single block's worth of coefficients */
;;;549    
;;;550          /* Section F.2.2.1: decode the DC coefficient difference */
;;;551          HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
;;;552          if (s) {
;;;553    	CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;554    	r = GET_BITS(s);
;;;555    	s = HUFF_EXTEND(r, s);
;;;556          }
;;;557    
;;;558          if (entropy->dc_needed[blkn]) {
;;;559    	/* Convert DC difference to actual value, update last_dc_val */
;;;560    	int ci = cinfo->MCU_membership[blkn];
;;;561    	s += state.last_dc_val[ci];
;;;562    	state.last_dc_val[ci] = s;
;;;563    	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
;;;564    	(*block)[0] = (JCOEF) s;
;;;565          }
;;;566    
;;;567          if (entropy->ac_needed[blkn]) {
;;;568    
;;;569    	/* Section F.2.2.2: decode the AC coefficients */
;;;570    	/* Since zeroes are skipped, output area must be cleared beforehand */
;;;571    	for (k = 1; k < DCTSIZE2; k++) {
;;;572    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
;;;573          
;;;574    	  r = s >> 4;
;;;575    	  s &= 15;
;;;576          
;;;577    	  if (s) {
;;;578    	    k += r;
;;;579    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;580    	    r = GET_BITS(s);
;;;581    	    s = HUFF_EXTEND(r, s);
;;;582    	    /* Output coefficient in natural (dezigzagged) order.
;;;583    	     * Note: the extra entries in jpeg_natural_order[] will save us
;;;584    	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
;;;585    	     */
;;;586    	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
;;;587    	  } else {
;;;588    	    if (r != 15)
;;;589    	      break;
;;;590    	    k += 15;
;;;591    	  }
;;;592    	}
;;;593    
;;;594          } else {
;;;595    
;;;596    	/* Section F.2.2.2: decode the AC coefficients */
;;;597    	/* In this path we just discard the values */
;;;598    	for (k = 1; k < DCTSIZE2; k++) {
;;;599    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
;;;600          
;;;601    	  r = s >> 4;
;;;602    	  s &= 15;
;;;603          
;;;604    	  if (s) {
;;;605    	    k += r;
;;;606    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;607    	    DROP_BITS(s);
;;;608    	  } else {
;;;609    	    if (r != 15)
;;;610    	      break;
;;;611    	    k += 15;
;;;612    	  }
;;;613    	}
;;;614    
;;;615          }
;;;616        }
;;;617    
;;;618        /* Completed MCU, so update state */
;;;619        BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
;;;620        ASSIGN_STATE(entropy->saved, state);
;;;621      }
;;;622    
;;;623      /* Account for restart interval (no-op if not using restarts) */
;;;624      entropy->restarts_to_go--;
;;;625    
;;;626      return TRUE;
;;;627    }
000020  b011              ADD      sp,sp,#0x44
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.38|
000026  68b0              LDR      r0,[r6,#8]            ;534
000028  2800              CMP      r0,#0                 ;534
00002a  d17d              BNE      |L1.296|
00002c  f8cd8038          STR      r8,[sp,#0x38]         ;537
000030  f8d80018          LDR      r0,[r8,#0x18]         ;537
000034  6800              LDR      r0,[r0,#0]            ;537
000036  900a              STR      r0,[sp,#0x28]         ;537
000038  f8d80018          LDR      r0,[r8,#0x18]         ;537
00003c  6840              LDR      r0,[r0,#4]            ;537
00003e  900b              STR      r0,[sp,#0x2c]         ;537
000040  f8d6b00c          LDR      r11,[r6,#0xc]         ;537
000044  6935              LDR      r5,[r6,#0x10]         ;537
000046  e9d62307          LDRD     r2,r3,[r6,#0x1c]      ;538
00004a  e9d61005          LDRD     r1,r0,[r6,#0x14]      ;538
00004e  ac07              ADD      r4,sp,#0x1c           ;538
000050  c40d              STM      r4!,{r0,r2,r3}        ;538
000052  9106              STR      r1,[sp,#0x18]         ;538
000054  f04f0900          MOV      r9,#0                 ;542
000058  e15e              B        |L1.792|
                  |L1.90|
00005a  9810              LDR      r0,[sp,#0x40]         ;543
00005c  f8500029          LDR      r0,[r0,r9,LSL #2]     ;543
000060  9005              STR      r0,[sp,#0x14]         ;543
000062  f1060048          ADD      r0,r6,#0x48           ;544
000066  f8500029          LDR      r0,[r0,r9,LSL #2]     ;544
00006a  9004              STR      r0,[sp,#0x10]         ;544
00006c  f1060070          ADD      r0,r6,#0x70           ;545
000070  f8500029          LDR      r0,[r0,r9,LSL #2]     ;545
000074  9003              STR      r0,[sp,#0xc]          ;545
000076  2d08              CMP      r5,#8                 ;551
000078  da10              BGE      |L1.156|
00007a  2300              MOVS     r3,#0                 ;551
00007c  462a              MOV      r2,r5                 ;551
00007e  4659              MOV      r1,r11                ;551
000080  a80a              ADD      r0,sp,#0x28           ;551
000082  f7fffffe          BL       jpeg_fill_bit_buffer
000086  b908              CBNZ     r0,|L1.140|
000088  2000              MOVS     r0,#0                 ;551
00008a  e7c9              B        |L1.32|
                  |L1.140|
00008c  f8ddb030          LDR      r11,[sp,#0x30]        ;551
000090  9d0d              LDR      r5,[sp,#0x34]         ;551
000092  2d08              CMP      r5,#8                 ;551
000094  da02              BGE      |L1.156|
000096  2001              MOVS     r0,#1                 ;551
000098  9002              STR      r0,[sp,#8]            ;551
00009a  e018              B        |L1.206|
                  |L1.156|
00009c  f1a50008          SUB      r0,r5,#8              ;551
0000a0  fa4bf000          ASR      r0,r11,r0             ;551
0000a4  b2c0              UXTB     r0,r0                 ;551
0000a6  9001              STR      r0,[sp,#4]            ;551
0000a8  9804              LDR      r0,[sp,#0x10]         ;551
0000aa  f1000190          ADD      r1,r0,#0x90           ;551
0000ae  9801              LDR      r0,[sp,#4]            ;551
0000b0  f8510020          LDR      r0,[r1,r0,LSL #2]     ;551
0000b4  9002              STR      r0,[sp,#8]            ;551
0000b6  b138              CBZ      r0,|L1.200|
0000b8  9802              LDR      r0,[sp,#8]            ;551
0000ba  1a2d              SUBS     r5,r5,r0              ;551
0000bc  9804              LDR      r0,[sp,#0x10]         ;551
0000be  f5006092          ADD      r0,r0,#0x490          ;551
0000c2  9901              LDR      r1,[sp,#4]            ;551
0000c4  5c44              LDRB     r4,[r0,r1]            ;551
0000c6  e011              B        |L1.236|
                  |L1.200|
0000c8  2009              MOVS     r0,#9                 ;551
0000ca  9002              STR      r0,[sp,#8]            ;551
0000cc  bf00              NOP                            ;551
                  |L1.206|
0000ce  9802              LDR      r0,[sp,#8]            ;551
0000d0  9000              STR      r0,[sp,#0]            ;551
0000d2  462a              MOV      r2,r5                 ;551
0000d4  4659              MOV      r1,r11                ;551
0000d6  a80a              ADD      r0,sp,#0x28           ;551
0000d8  9b04              LDR      r3,[sp,#0x10]         ;551
0000da  f7fffffe          BL       jpeg_huff_decode
0000de  1e04              SUBS     r4,r0,#0              ;551
0000e0  da01              BGE      |L1.230|
0000e2  2000              MOVS     r0,#0                 ;551
0000e4  e79c              B        |L1.32|
                  |L1.230|
0000e6  f8ddb030          LDR      r11,[sp,#0x30]        ;551
0000ea  9d0d              LDR      r5,[sp,#0x34]         ;551
                  |L1.236|
0000ec  b324              CBZ      r4,|L1.312|
0000ee  42a5              CMP      r5,r4                 ;553
0000f0  da0b              BGE      |L1.266|
0000f2  4623              MOV      r3,r4                 ;553
0000f4  462a              MOV      r2,r5                 ;553
0000f6  4659              MOV      r1,r11                ;553
0000f8  a80a              ADD      r0,sp,#0x28           ;553
0000fa  f7fffffe          BL       jpeg_fill_bit_buffer
0000fe  b908              CBNZ     r0,|L1.260|
000100  2000              MOVS     r0,#0                 ;553
000102  e78d              B        |L1.32|
                  |L1.260|
000104  f8ddb030          LDR      r11,[sp,#0x30]        ;553
000108  9d0d              LDR      r5,[sp,#0x34]         ;553
                  |L1.266|
00010a  1b29              SUBS     r1,r5,r4              ;554
00010c  460d              MOV      r5,r1                 ;554
00010e  fa4bf001          ASR      r0,r11,r1             ;554
000112  2101              MOVS     r1,#1                 ;554
000114  40a1              LSLS     r1,r1,r4              ;554
000116  1e49              SUBS     r1,r1,#1              ;554
000118  ea000a01          AND      r10,r0,r1             ;554
00011c  488b              LDR      r0,|L1.844|
00011e  f8500024          LDR      r0,[r0,r4,LSL #2]     ;555
000122  4550              CMP      r0,r10                ;555
000124  dd06              BLE      |L1.308|
000126  e000              B        |L1.298|
                  |L1.296|
000128  e10b              B        |L1.834|
                  |L1.298|
00012a  4889              LDR      r0,|L1.848|
00012c  f8500024          LDR      r0,[r0,r4,LSL #2]     ;555
000130  4450              ADD      r0,r0,r10             ;555
000132  e000              B        |L1.310|
                  |L1.308|
000134  4650              MOV      r0,r10                ;555
                  |L1.310|
000136  4604              MOV      r4,r0                 ;555
                  |L1.312|
000138  f1060098          ADD      r0,r6,#0x98           ;558
00013c  f8500029          LDR      r0,[r0,r9,LSL #2]     ;558
000140  b170              CBZ      r0,|L1.352|
000142  f50871b4          ADD      r1,r8,#0x168          ;560
000146  f8510029          LDR      r0,[r1,r9,LSL #2]     ;560
00014a  a906              ADD      r1,sp,#0x18           ;561
00014c  f8511020          LDR      r1,[r1,r0,LSL #2]     ;561
000150  440c              ADD      r4,r4,r1              ;561
000152  a906              ADD      r1,sp,#0x18           ;562
000154  f8414020          STR      r4,[r1,r0,LSL #2]     ;562
000158  b222              SXTH     r2,r4                 ;564
00015a  9905              LDR      r1,[sp,#0x14]         ;564
00015c  800a              STRH     r2,[r1,#0]            ;564
00015e  bf00              NOP                            ;565
                  |L1.352|
000160  f10600c0          ADD      r0,r6,#0xc0           ;567
000164  f8500029          LDR      r0,[r0,r9,LSL #2]     ;567
000168  2800              CMP      r0,#0                 ;567
00016a  d077              BEQ      |L1.604|
00016c  2701              MOVS     r7,#1                 ;571
00016e  e072              B        |L1.598|
                  |L1.368|
000170  2d08              CMP      r5,#8                 ;572
000172  da10              BGE      |L1.406|
000174  2300              MOVS     r3,#0                 ;572
000176  462a              MOV      r2,r5                 ;572
000178  4659              MOV      r1,r11                ;572
00017a  a80a              ADD      r0,sp,#0x28           ;572
00017c  f7fffffe          BL       jpeg_fill_bit_buffer
000180  b908              CBNZ     r0,|L1.390|
000182  2000              MOVS     r0,#0                 ;572
000184  e74c              B        |L1.32|
                  |L1.390|
000186  f8ddb030          LDR      r11,[sp,#0x30]        ;572
00018a  9d0d              LDR      r5,[sp,#0x34]         ;572
00018c  2d08              CMP      r5,#8                 ;572
00018e  da02              BGE      |L1.406|
000190  2001              MOVS     r0,#1                 ;572
000192  9002              STR      r0,[sp,#8]            ;572
000194  e018              B        |L1.456|
                  |L1.406|
000196  f1a50008          SUB      r0,r5,#8              ;572
00019a  fa4bf000          ASR      r0,r11,r0             ;572
00019e  b2c0              UXTB     r0,r0                 ;572
0001a0  9001              STR      r0,[sp,#4]            ;572
0001a2  9803              LDR      r0,[sp,#0xc]          ;572
0001a4  f1000190          ADD      r1,r0,#0x90           ;572
0001a8  9801              LDR      r0,[sp,#4]            ;572
0001aa  f8510020          LDR      r0,[r1,r0,LSL #2]     ;572
0001ae  9002              STR      r0,[sp,#8]            ;572
0001b0  b138              CBZ      r0,|L1.450|
0001b2  9802              LDR      r0,[sp,#8]            ;572
0001b4  1a2d              SUBS     r5,r5,r0              ;572
0001b6  9803              LDR      r0,[sp,#0xc]          ;572
0001b8  f5006092          ADD      r0,r0,#0x490          ;572
0001bc  9901              LDR      r1,[sp,#4]            ;572
0001be  5c44              LDRB     r4,[r0,r1]            ;572
0001c0  e011              B        |L1.486|
                  |L1.450|
0001c2  2009              MOVS     r0,#9                 ;572
0001c4  9002              STR      r0,[sp,#8]            ;572
0001c6  bf00              NOP                            ;572
                  |L1.456|
0001c8  9802              LDR      r0,[sp,#8]            ;572
0001ca  9000              STR      r0,[sp,#0]            ;572
0001cc  462a              MOV      r2,r5                 ;572
0001ce  4659              MOV      r1,r11                ;572
0001d0  a80a              ADD      r0,sp,#0x28           ;572
0001d2  9b03              LDR      r3,[sp,#0xc]          ;572
0001d4  f7fffffe          BL       jpeg_huff_decode
0001d8  1e04              SUBS     r4,r0,#0              ;572
0001da  da01              BGE      |L1.480|
0001dc  2000              MOVS     r0,#0                 ;572
0001de  e71f              B        |L1.32|
                  |L1.480|
0001e0  f8ddb030          LDR      r11,[sp,#0x30]        ;572
0001e4  9d0d              LDR      r5,[sp,#0x34]         ;572
                  |L1.486|
0001e6  ea4f1a24          ASR      r10,r4,#4             ;574
0001ea  f004040f          AND      r4,r4,#0xf            ;575
0001ee  b35c              CBZ      r4,|L1.584|
0001f0  4457              ADD      r7,r7,r10             ;578
0001f2  42a5              CMP      r5,r4                 ;579
0001f4  da0b              BGE      |L1.526|
0001f6  4623              MOV      r3,r4                 ;579
0001f8  462a              MOV      r2,r5                 ;579
0001fa  4659              MOV      r1,r11                ;579
0001fc  a80a              ADD      r0,sp,#0x28           ;579
0001fe  f7fffffe          BL       jpeg_fill_bit_buffer
000202  b908              CBNZ     r0,|L1.520|
000204  2000              MOVS     r0,#0                 ;579
000206  e70b              B        |L1.32|
                  |L1.520|
000208  f8ddb030          LDR      r11,[sp,#0x30]        ;579
00020c  9d0d              LDR      r5,[sp,#0x34]         ;579
                  |L1.526|
00020e  1b29              SUBS     r1,r5,r4              ;580
000210  460d              MOV      r5,r1                 ;580
000212  fa4bf001          ASR      r0,r11,r1             ;580
000216  2101              MOVS     r1,#1                 ;580
000218  40a1              LSLS     r1,r1,r4              ;580
00021a  1e49              SUBS     r1,r1,#1              ;580
00021c  ea000a01          AND      r10,r0,r1             ;580
000220  484a              LDR      r0,|L1.844|
000222  f8500024          LDR      r0,[r0,r4,LSL #2]     ;581
000226  4550              CMP      r0,r10                ;581
000228  dd04              BLE      |L1.564|
00022a  4849              LDR      r0,|L1.848|
00022c  f8500024          LDR      r0,[r0,r4,LSL #2]     ;581
000230  4450              ADD      r0,r0,r10             ;581
000232  e000              B        |L1.566|
                  |L1.564|
000234  4650              MOV      r0,r10                ;581
                  |L1.566|
000236  4604              MOV      r4,r0                 ;581
000238  b221              SXTH     r1,r4                 ;586
00023a  4846              LDR      r0,|L1.852|
00023c  f8502027          LDR      r2,[r0,r7,LSL #2]     ;586
000240  9805              LDR      r0,[sp,#0x14]         ;586
000242  f8201012          STRH     r1,[r0,r2,LSL #1]     ;586
000246  e005              B        |L1.596|
                  |L1.584|
000248  f1ba0f0f          CMP      r10,#0xf              ;588
00024c  d001              BEQ      |L1.594|
00024e  e004              B        |L1.602|
000250  e004              B        |L1.604|
                  |L1.594|
000252  370f              ADDS     r7,r7,#0xf            ;590
                  |L1.596|
000254  1c7f              ADDS     r7,r7,#1              ;571
                  |L1.598|
000256  2f40              CMP      r7,#0x40              ;571
000258  db8a              BLT      |L1.368|
                  |L1.602|
00025a  e05b              B        |L1.788|
                  |L1.604|
00025c  2701              MOVS     r7,#1                 ;598
00025e  e056              B        |L1.782|
                  |L1.608|
000260  2d08              CMP      r5,#8                 ;599
000262  da10              BGE      |L1.646|
000264  2300              MOVS     r3,#0                 ;599
000266  462a              MOV      r2,r5                 ;599
000268  4659              MOV      r1,r11                ;599
00026a  a80a              ADD      r0,sp,#0x28           ;599
00026c  f7fffffe          BL       jpeg_fill_bit_buffer
000270  b908              CBNZ     r0,|L1.630|
000272  2000              MOVS     r0,#0                 ;599
000274  e6d4              B        |L1.32|
                  |L1.630|
000276  f8ddb030          LDR      r11,[sp,#0x30]        ;599
00027a  9d0d              LDR      r5,[sp,#0x34]         ;599
00027c  2d08              CMP      r5,#8                 ;599
00027e  da02              BGE      |L1.646|
000280  2001              MOVS     r0,#1                 ;599
000282  9002              STR      r0,[sp,#8]            ;599
000284  e018              B        |L1.696|
                  |L1.646|
000286  f1a50008          SUB      r0,r5,#8              ;599
00028a  fa4bf000          ASR      r0,r11,r0             ;599
00028e  b2c0              UXTB     r0,r0                 ;599
000290  9001              STR      r0,[sp,#4]            ;599
000292  9803              LDR      r0,[sp,#0xc]          ;599
000294  f1000190          ADD      r1,r0,#0x90           ;599
000298  9801              LDR      r0,[sp,#4]            ;599
00029a  f8510020          LDR      r0,[r1,r0,LSL #2]     ;599
00029e  9002              STR      r0,[sp,#8]            ;599
0002a0  b138              CBZ      r0,|L1.690|
0002a2  9802              LDR      r0,[sp,#8]            ;599
0002a4  1a2d              SUBS     r5,r5,r0              ;599
0002a6  9803              LDR      r0,[sp,#0xc]          ;599
0002a8  f5006092          ADD      r0,r0,#0x490          ;599
0002ac  9901              LDR      r1,[sp,#4]            ;599
0002ae  5c44              LDRB     r4,[r0,r1]            ;599
0002b0  e011              B        |L1.726|
                  |L1.690|
0002b2  2009              MOVS     r0,#9                 ;599
0002b4  9002              STR      r0,[sp,#8]            ;599
0002b6  bf00              NOP                            ;599
                  |L1.696|
0002b8  9802              LDR      r0,[sp,#8]            ;599
0002ba  9000              STR      r0,[sp,#0]            ;599
0002bc  462a              MOV      r2,r5                 ;599
0002be  4659              MOV      r1,r11                ;599
0002c0  a80a              ADD      r0,sp,#0x28           ;599
0002c2  9b03              LDR      r3,[sp,#0xc]          ;599
0002c4  f7fffffe          BL       jpeg_huff_decode
0002c8  1e04              SUBS     r4,r0,#0              ;599
0002ca  da01              BGE      |L1.720|
0002cc  2000              MOVS     r0,#0                 ;599
0002ce  e6a7              B        |L1.32|
                  |L1.720|
0002d0  f8ddb030          LDR      r11,[sp,#0x30]        ;599
0002d4  9d0d              LDR      r5,[sp,#0x34]         ;599
                  |L1.726|
0002d6  ea4f1a24          ASR      r10,r4,#4             ;601
0002da  f004040f          AND      r4,r4,#0xf            ;602
0002de  b184              CBZ      r4,|L1.770|
0002e0  4457              ADD      r7,r7,r10             ;605
0002e2  42a5              CMP      r5,r4                 ;606
0002e4  da0b              BGE      |L1.766|
0002e6  4623              MOV      r3,r4                 ;606
0002e8  462a              MOV      r2,r5                 ;606
0002ea  4659              MOV      r1,r11                ;606
0002ec  a80a              ADD      r0,sp,#0x28           ;606
0002ee  f7fffffe          BL       jpeg_fill_bit_buffer
0002f2  b908              CBNZ     r0,|L1.760|
0002f4  2000              MOVS     r0,#0                 ;606
0002f6  e693              B        |L1.32|
                  |L1.760|
0002f8  f8ddb030          LDR      r11,[sp,#0x30]        ;606
0002fc  9d0d              LDR      r5,[sp,#0x34]         ;606
                  |L1.766|
0002fe  1b2d              SUBS     r5,r5,r4              ;607
000300  e004              B        |L1.780|
                  |L1.770|
000302  f1ba0f0f          CMP      r10,#0xf              ;609
000306  d000              BEQ      |L1.778|
000308  e003              B        |L1.786|
                  |L1.778|
00030a  370f              ADDS     r7,r7,#0xf            ;611
                  |L1.780|
00030c  1c7f              ADDS     r7,r7,#1              ;598
                  |L1.782|
00030e  2f40              CMP      r7,#0x40              ;598
000310  dba6              BLT      |L1.608|
                  |L1.786|
000312  bf00              NOP                            ;610
                  |L1.788|
000314  f1090901          ADD      r9,r9,#1              ;542
                  |L1.792|
000318  f8d80164          LDR      r0,[r8,#0x164]        ;542
00031c  4548              CMP      r0,r9                 ;542
00031e  f73fae9c          BGT      |L1.90|
000322  980a              LDR      r0,[sp,#0x28]         ;619
000324  f8d81018          LDR      r1,[r8,#0x18]         ;619
000328  6008              STR      r0,[r1,#0]            ;619
00032a  980b              LDR      r0,[sp,#0x2c]         ;619
00032c  f8d81018          LDR      r1,[r8,#0x18]         ;619
000330  6048              STR      r0,[r1,#4]            ;619
000332  f8c6b00c          STR      r11,[r6,#0xc]         ;619
000336  6135              STR      r5,[r6,#0x10]         ;619
000338  a806              ADD      r0,sp,#0x18           ;620
00033a  c80f              LDM      r0,{r0-r3}            ;620
00033c  f1060414          ADD      r4,r6,#0x14           ;620
000340  c40f              STM      r4!,{r0-r3}           ;620
                  |L1.834|
000342  6a70              LDR      r0,[r6,#0x24]         ;624
000344  1e40              SUBS     r0,r0,#1              ;624
000346  6270              STR      r0,[r6,#0x24]         ;624
000348  2001              MOVS     r0,#1                 ;626
00034a  e669              B        |L1.32|
;;;628    
                          ENDP

                  |L1.844|
                          DCD      extend_test
                  |L1.848|
                          DCD      extend_offset
                  |L1.852|
                          DCD      jpeg_natural_order

                          AREA ||i.jinit_huff_decoder||, CODE, READONLY, ALIGN=2

                  jinit_huff_decoder PROC
;;;634    GLOBAL(void)
;;;635    jinit_huff_decoder (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;636    {
000002  4606              MOV      r6,r0
;;;637      huff_entropy_ptr entropy;
;;;638      int i;
;;;639    
;;;640      entropy = (huff_entropy_ptr)
000004  6870              LDR      r0,[r6,#4]
000006  22e8              MOVS     r2,#0xe8
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4630              MOV      r0,r6
00000e  4798              BLX      r3
000010  4604              MOV      r4,r0
;;;641        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;642    				SIZEOF(huff_entropy_decoder));
;;;643      cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
000012  f8c641bc          STR      r4,[r6,#0x1bc]
;;;644      entropy->pub.start_pass = start_pass_huff_decoder;
000016  4809              LDR      r0,|L2.60|
000018  6020              STR      r0,[r4,#0]
;;;645      entropy->pub.decode_mcu = decode_mcu;
00001a  4809              LDR      r0,|L2.64|
00001c  6060              STR      r0,[r4,#4]
;;;646    
;;;647      /* Mark tables unallocated */
;;;648      for (i = 0; i < NUM_HUFF_TBLS; i++) {
00001e  2500              MOVS     r5,#0
000020  e008              B        |L2.52|
                  |L2.34|
;;;649        entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
000022  2100              MOVS     r1,#0
000024  f1040038          ADD      r0,r4,#0x38
000028  f8401025          STR      r1,[r0,r5,LSL #2]
00002c  3810              SUBS     r0,r0,#0x10
00002e  f8401025          STR      r1,[r0,r5,LSL #2]
000032  1c6d              ADDS     r5,r5,#1              ;648
                  |L2.52|
000034  2d04              CMP      r5,#4                 ;648
000036  dbf4              BLT      |L2.34|
;;;650      }
;;;651    }
000038  bd70              POP      {r4-r6,pc}
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      start_pass_huff_decoder
                  |L2.64|
                          DCD      decode_mcu

                          AREA ||i.jpeg_fill_bit_buffer||, CODE, READONLY, ALIGN=1

                  jpeg_fill_bit_buffer PROC
;;;291    GLOBAL(boolean)
;;;292    jpeg_fill_bit_buffer (bitread_working_state * state,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;293    		      register bit_buf_type get_buffer, register int bits_left,
;;;294    		      int nbits)
;;;295    /* Load up the bit buffer to a depth of at least nbits */
;;;296    {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
00000a  469b              MOV      r11,r3
;;;297      /* Copy heavily used state fields into locals (hopefully registers) */
;;;298      register const JOCTET * next_input_byte = state->next_input_byte;
00000c  f8d58000          LDR      r8,[r5,#0]
;;;299      register size_t bytes_in_buffer = state->bytes_in_buffer;
000010  f8d59004          LDR      r9,[r5,#4]
;;;300      j_decompress_ptr cinfo = state->cinfo;
000014  692c              LDR      r4,[r5,#0x10]
;;;301    
;;;302      /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
;;;303      /* (It is assumed that no request will be for more than that many bits.) */
;;;304      /* We fail to do so only if we hit a marker or are forced to suspend. */
;;;305    
;;;306      if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
000016  f8d401a0          LDR      r0,[r4,#0x1a0]
00001a  2800              CMP      r0,#0
00001c  d13b              BNE      |L3.150|
;;;307        while (bits_left < MIN_GET_BITS) {
00001e  e037              B        |L3.144|
                  |L3.32|
;;;308          register int c;
;;;309    
;;;310          /* Attempt to read a byte */
;;;311          if (bytes_in_buffer == 0) {
000020  f1b90f00          CMP      r9,#0
000024  d10d              BNE      |L3.66|
;;;312    	if (! (*cinfo->src->fill_input_buffer) (cinfo))
000026  69a0              LDR      r0,[r4,#0x18]
000028  68c1              LDR      r1,[r0,#0xc]
00002a  4620              MOV      r0,r4
00002c  4788              BLX      r1
00002e  b910              CBNZ     r0,|L3.54|
;;;313    	  return FALSE;
000030  2000              MOVS     r0,#0
                  |L3.50|
;;;314    	next_input_byte = cinfo->src->next_input_byte;
;;;315    	bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;316          }
;;;317          bytes_in_buffer--;
;;;318          c = GETJOCTET(*next_input_byte++);
;;;319    
;;;320          /* If it's 0xFF, check and discard stuffed zero byte */
;;;321          if (c == 0xFF) {
;;;322    	/* Loop here to discard any padding FF's on terminating marker,
;;;323    	 * so that we can save a valid unread_marker value.  NOTE: we will
;;;324    	 * accept multiple FF's followed by a 0 as meaning a single FF data
;;;325    	 * byte.  This data pattern is not valid according to the standard.
;;;326    	 */
;;;327    	do {
;;;328    	  if (bytes_in_buffer == 0) {
;;;329    	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
;;;330    	      return FALSE;
;;;331    	    next_input_byte = cinfo->src->next_input_byte;
;;;332    	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;333    	  }
;;;334    	  bytes_in_buffer--;
;;;335    	  c = GETJOCTET(*next_input_byte++);
;;;336    	} while (c == 0xFF);
;;;337    
;;;338    	if (c == 0) {
;;;339    	  /* Found FF/00, which represents an FF data byte */
;;;340    	  c = 0xFF;
;;;341    	} else {
;;;342    	  /* Oops, it's actually a marker indicating end of compressed data.
;;;343    	   * Save the marker code for later use.
;;;344    	   * Fine point: it might appear that we should save the marker into
;;;345    	   * bitread working state, not straight into permanent state.  But
;;;346    	   * once we have hit a marker, we cannot need to suspend within the
;;;347    	   * current MCU, because we will read no more bytes from the data
;;;348    	   * source.  So it is OK to update permanent state right away.
;;;349    	   */
;;;350    	  cinfo->unread_marker = c;
;;;351    	  /* See if we need to insert some fake zero bits. */
;;;352    	  goto no_more_bytes;
;;;353    	}
;;;354          }
;;;355    
;;;356          /* OK, load c into get_buffer */
;;;357          get_buffer = (get_buffer << 8) | c;
;;;358          bits_left += 8;
;;;359        } /* end while */
;;;360      } else {
;;;361      no_more_bytes:
;;;362        /* We get here if we've read the marker that terminates the compressed
;;;363         * data segment.  There should be enough bits in the buffer register
;;;364         * to satisfy the request; if so, no problem.
;;;365         */
;;;366        if (nbits > bits_left) {
;;;367          /* Uh-oh.  Report corrupted data to user and stuff zeroes into
;;;368           * the data stream, so that we can produce some kind of image.
;;;369           * We use a nonvolatile flag to ensure that only one warning message
;;;370           * appears per data segment.
;;;371           */
;;;372          if (! cinfo->entropy->insufficient_data) {
;;;373    	WARNMS(cinfo, JWRN_HIT_MARKER);
;;;374    	cinfo->entropy->insufficient_data = TRUE;
;;;375          }
;;;376          /* Fill the buffer with zero bits */
;;;377          get_buffer <<= MIN_GET_BITS - bits_left;
;;;378          bits_left = MIN_GET_BITS;
;;;379        }
;;;380      }
;;;381    
;;;382      /* Unload the local registers */
;;;383      state->next_input_byte = next_input_byte;
;;;384      state->bytes_in_buffer = bytes_in_buffer;
;;;385      state->get_buffer = get_buffer;
;;;386      state->bits_left = bits_left;
;;;387    
;;;388      return TRUE;
;;;389    }
000032  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.54|
000036  69a0              LDR      r0,[r4,#0x18]         ;314
000038  f8d08000          LDR      r8,[r0,#0]            ;314
00003c  69a0              LDR      r0,[r4,#0x18]         ;315
00003e  f8d09004          LDR      r9,[r0,#4]            ;315
                  |L3.66|
000042  f1a90901          SUB      r9,r9,#1              ;317
000046  f8187b01          LDRB     r7,[r8],#1            ;318
00004a  2fff              CMP      r7,#0xff              ;321
00004c  d11c              BNE      |L3.136|
00004e  bf00              NOP                            ;327
                  |L3.80|
000050  f1b90f00          CMP      r9,#0                 ;328
000054  d10c              BNE      |L3.112|
000056  69a0              LDR      r0,[r4,#0x18]         ;329
000058  68c1              LDR      r1,[r0,#0xc]          ;329
00005a  4620              MOV      r0,r4                 ;329
00005c  4788              BLX      r1                    ;329
00005e  b908              CBNZ     r0,|L3.100|
000060  2000              MOVS     r0,#0                 ;330
000062  e7e6              B        |L3.50|
                  |L3.100|
000064  69a0              LDR      r0,[r4,#0x18]         ;331
000066  f8d08000          LDR      r8,[r0,#0]            ;331
00006a  69a0              LDR      r0,[r4,#0x18]         ;332
00006c  f8d09004          LDR      r9,[r0,#4]            ;332
                  |L3.112|
000070  f1a90901          SUB      r9,r9,#1              ;334
000074  f8187b01          LDRB     r7,[r8],#1            ;335
000078  2fff              CMP      r7,#0xff              ;336
00007a  d0e9              BEQ      |L3.80|
00007c  b90f              CBNZ     r7,|L3.130|
00007e  27ff              MOVS     r7,#0xff              ;340
000080  e002              B        |L3.136|
                  |L3.130|
000082  f8c471a0          STR      r7,[r4,#0x1a0]        ;350
000086  e007              B        |L3.152|
                  |L3.136|
000088  ea472a0a          ORR      r10,r7,r10,LSL #8     ;357
00008c  3608              ADDS     r6,r6,#8              ;358
00008e  bf00              NOP                            ;359
                  |L3.144|
000090  2e19              CMP      r6,#0x19              ;307
000092  dbc5              BLT      |L3.32|
000094  e018              B        |L3.200|
                  |L3.150|
000096  bf00              NOP                            ;361
                  |L3.152|
000098  45b3              CMP      r11,r6                ;366
00009a  dd15              BLE      |L3.200|
00009c  f8d401bc          LDR      r0,[r4,#0x1bc]        ;372
0000a0  6880              LDR      r0,[r0,#8]            ;372
0000a2  b960              CBNZ     r0,|L3.190|
0000a4  2075              MOVS     r0,#0x75              ;373
0000a6  6821              LDR      r1,[r4,#0]            ;373
0000a8  6148              STR      r0,[r1,#0x14]         ;373
0000aa  6820              LDR      r0,[r4,#0]            ;373
0000ac  f04f31ff          MOV      r1,#0xffffffff        ;373
0000b0  6842              LDR      r2,[r0,#4]            ;373
0000b2  4620              MOV      r0,r4                 ;373
0000b4  4790              BLX      r2                    ;373
0000b6  2001              MOVS     r0,#1                 ;374
0000b8  f8d411bc          LDR      r1,[r4,#0x1bc]        ;374
0000bc  6088              STR      r0,[r1,#8]            ;374
                  |L3.190|
0000be  f1c60019          RSB      r0,r6,#0x19           ;377
0000c2  fa0afa00          LSL      r10,r10,r0            ;377
0000c6  2619              MOVS     r6,#0x19              ;378
                  |L3.200|
0000c8  f8c58000          STR      r8,[r5,#0]            ;383
0000cc  f8c59004          STR      r9,[r5,#4]            ;384
0000d0  f8c5a008          STR      r10,[r5,#8]           ;385
0000d4  60ee              STR      r6,[r5,#0xc]          ;386
0000d6  2001              MOVS     r0,#1                 ;388
0000d8  e7ab              B        |L3.50|
;;;390    
                          ENDP


                          AREA ||i.jpeg_huff_decode||, CODE, READONLY, ALIGN=1

                  jpeg_huff_decode PROC
;;;397    GLOBAL(int)
;;;398    jpeg_huff_decode (bitread_working_state * state,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;399    		  register bit_buf_type get_buffer, register int bits_left,
;;;400    		  d_derived_tbl * htbl, int min_bits)
;;;401    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
00000c  f8dda020          LDR      r10,[sp,#0x20]
;;;402      register int l = min_bits;
000010  4655              MOV      r5,r10
;;;403      register INT32 code;
;;;404    
;;;405      /* HUFF_DECODE has determined that the code is at least min_bits */
;;;406      /* bits long, so fetch that many bits in one swoop. */
;;;407    
;;;408      CHECK_BIT_BUFFER(*state, l, return -1);
000012  42ae              CMP      r6,r5
000014  da0d              BGE      |L4.50|
000016  462b              MOV      r3,r5
000018  4632              MOV      r2,r6
00001a  4641              MOV      r1,r8
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       jpeg_fill_bit_buffer
000022  b918              CBNZ     r0,|L4.44|
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L4.40|
;;;409      code = GET_BITS(l);
;;;410    
;;;411      /* Collect the rest of the Huffman code one bit at a time. */
;;;412      /* This is per Figure F.16 in the JPEG spec. */
;;;413    
;;;414      while (code > htbl->maxcode[l]) {
;;;415        code <<= 1;
;;;416        CHECK_BIT_BUFFER(*state, 1, return -1);
;;;417        code |= GET_BITS(1);
;;;418        l++;
;;;419      }
;;;420    
;;;421      /* Unload the local registers */
;;;422      state->get_buffer = get_buffer;
;;;423      state->bits_left = bits_left;
;;;424    
;;;425      /* With garbage input we may reach the sentinel value l = 17. */
;;;426    
;;;427      if (l > 16) {
;;;428        WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
;;;429        return 0;			/* fake a zero as the safest result */
;;;430      }
;;;431    
;;;432      return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
;;;433    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L4.44|
00002c  f8d48008          LDR      r8,[r4,#8]            ;408
000030  68e6              LDR      r6,[r4,#0xc]          ;408
                  |L4.50|
000032  1b71              SUBS     r1,r6,r5              ;409
000034  460e              MOV      r6,r1                 ;409
000036  fa48f001          ASR      r0,r8,r1              ;409
00003a  2101              MOVS     r1,#1                 ;409
00003c  40a9              LSLS     r1,r1,r5              ;409
00003e  1e49              SUBS     r1,r1,#1              ;409
000040  ea000701          AND      r7,r0,r1              ;409
000044  e017              B        |L4.118|
                  |L4.70|
000046  007f              LSLS     r7,r7,#1              ;415
000048  2e01              CMP      r6,#1                 ;416
00004a  da0c              BGE      |L4.102|
00004c  2301              MOVS     r3,#1                 ;416
00004e  4632              MOV      r2,r6                 ;416
000050  4641              MOV      r1,r8                 ;416
000052  4620              MOV      r0,r4                 ;416
000054  f7fffffe          BL       jpeg_fill_bit_buffer
000058  b910              CBNZ     r0,|L4.96|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;416
00005e  e7e3              B        |L4.40|
                  |L4.96|
000060  f8d48008          LDR      r8,[r4,#8]            ;416
000064  68e6              LDR      r6,[r4,#0xc]          ;416
                  |L4.102|
000066  1e70              SUBS     r0,r6,#1              ;417
000068  4606              MOV      r6,r0                 ;417
00006a  fa48f000          ASR      r0,r8,r0              ;417
00006e  f0000001          AND      r0,r0,#1              ;417
000072  4307              ORRS     r7,r7,r0              ;417
000074  1c6d              ADDS     r5,r5,#1              ;418
                  |L4.118|
000076  f8590025          LDR      r0,[r9,r5,LSL #2]     ;414
00007a  42b8              CMP      r0,r7                 ;414
00007c  dbe3              BLT      |L4.70|
00007e  f8c48008          STR      r8,[r4,#8]            ;422
000082  60e6              STR      r6,[r4,#0xc]          ;423
000084  2d10              CMP      r5,#0x10              ;427
000086  dd0b              BLE      |L4.160|
000088  2076              MOVS     r0,#0x76              ;428
00008a  6921              LDR      r1,[r4,#0x10]         ;428
00008c  6809              LDR      r1,[r1,#0]            ;428
00008e  6148              STR      r0,[r1,#0x14]         ;428
000090  6920              LDR      r0,[r4,#0x10]         ;428
000092  6801              LDR      r1,[r0,#0]            ;428
000094  684a              LDR      r2,[r1,#4]            ;428
000096  f04f31ff          MOV      r1,#0xffffffff        ;428
00009a  4790              BLX      r2                    ;428
00009c  2000              MOVS     r0,#0                 ;429
00009e  e7c3              B        |L4.40|
                  |L4.160|
0000a0  f8d9008c          LDR      r0,[r9,#0x8c]         ;432
0000a4  3011              ADDS     r0,r0,#0x11           ;432
0000a6  f1090148          ADD      r1,r9,#0x48           ;432
0000aa  f8511025          LDR      r1,[r1,r5,LSL #2]     ;432
0000ae  4439              ADD      r1,r1,r7              ;432
0000b0  5c40              LDRB     r0,[r0,r1]            ;432
0000b2  e7b9              B        |L4.40|
;;;434    
                          ENDP


                          AREA ||i.jpeg_make_d_derived_tbl||, CODE, READONLY, ALIGN=2

                  jpeg_make_d_derived_tbl PROC
;;;148    GLOBAL(void)
;;;149    jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;150    			 d_derived_tbl ** pdtbl)
;;;151    {
000004  f2ad5d1c          SUB      sp,sp,#0x51c
000008  4605              MOV      r5,r0
00000a  4692              MOV      r10,r2
;;;152      JHUFF_TBL *htbl;
;;;153      d_derived_tbl *dtbl;
;;;154      int p, i, l, si, numsymbols;
;;;155      int lookbits, ctr;
;;;156      char huffsize[257];
;;;157      unsigned int huffcode[257];
;;;158      unsigned int code;
;;;159    
;;;160      /* Note that huffsize[] and huffcode[] are filled in code-length order,
;;;161       * paralleling the order of the symbols themselves in htbl->huffval[].
;;;162       */
;;;163    
;;;164      /* Find the input Huffman table */
;;;165      if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
00000c  f1ba0f00          CMP      r10,#0
000010  db02              BLT      |L5.24|
000012  f1ba0f04          CMP      r10,#4
000016  db09              BLT      |L5.44|
                  |L5.24|
;;;166        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
000018  2032              MOVS     r0,#0x32
00001a  6829              LDR      r1,[r5,#0]
00001c  6148              STR      r0,[r1,#0x14]
00001e  6828              LDR      r0,[r5,#0]
000020  f8c0a018          STR      r10,[r0,#0x18]
000024  6828              LDR      r0,[r5,#0]
000026  6801              LDR      r1,[r0,#0]
000028  4628              MOV      r0,r5
00002a  4788              BLX      r1
                  |L5.44|
;;;167      htbl =
00002c  f8dd0520          LDR      r0,[sp,#0x520]
000030  b120              CBZ      r0,|L5.60|
;;;168        isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
000032  f10500b4          ADD      r0,r5,#0xb4
000036  f850002a          LDR      r0,[r0,r10,LSL #2]
00003a  e003              B        |L5.68|
                  |L5.60|
00003c  f10500c4          ADD      r0,r5,#0xc4
000040  f850002a          LDR      r0,[r0,r10,LSL #2]
                  |L5.68|
000044  4680              MOV      r8,r0
;;;169      if (htbl == NULL)
000046  f1b80f00          CMP      r8,#0
00004a  d109              BNE      |L5.96|
;;;170        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
00004c  2032              MOVS     r0,#0x32
00004e  6829              LDR      r1,[r5,#0]
000050  6148              STR      r0,[r1,#0x14]
000052  6828              LDR      r0,[r5,#0]
000054  f8c0a018          STR      r10,[r0,#0x18]
000058  6828              LDR      r0,[r5,#0]
00005a  6801              LDR      r1,[r0,#0]
00005c  4628              MOV      r0,r5
00005e  4788              BLX      r1
                  |L5.96|
;;;171    
;;;172      /* Allocate a workspace if we haven't already done so. */
;;;173      if (*pdtbl == NULL)
000060  f8dd0528          LDR      r0,[sp,#0x528]
000064  6800              LDR      r0,[r0,#0]
000066  b948              CBNZ     r0,|L5.124|
;;;174        *pdtbl = (d_derived_tbl *)
000068  6868              LDR      r0,[r5,#4]
00006a  f44f62b2          MOV      r2,#0x590
00006e  2101              MOVS     r1,#1
000070  6803              LDR      r3,[r0,#0]
000072  4628              MOV      r0,r5
000074  4798              BLX      r3
000076  f8dd1528          LDR      r1,[sp,#0x528]
00007a  6008              STR      r0,[r1,#0]
                  |L5.124|
;;;175          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;176    				  SIZEOF(d_derived_tbl));
;;;177      dtbl = *pdtbl;
00007c  f8dd0528          LDR      r0,[sp,#0x528]
000080  6807              LDR      r7,[r0,#0]
;;;178      dtbl->pub = htbl;		/* fill in back link */
000082  f8c7808c          STR      r8,[r7,#0x8c]
;;;179      
;;;180      /* Figure C.1: make table of Huffman code length for each symbol */
;;;181    
;;;182      p = 0;
000086  2600              MOVS     r6,#0
;;;183      for (l = 1; l <= 16; l++) {
000088  2401              MOVS     r4,#1
00008a  e01c              B        |L5.198|
                  |L5.140|
;;;184        i = (int) htbl->bits[l];
00008c  f8189004          LDRB     r9,[r8,r4]
;;;185        if (i < 0 || p + i > 256)	/* protect against table overrun */
000090  f1b90f00          CMP      r9,#0
000094  db04              BLT      |L5.160|
000096  eb060009          ADD      r0,r6,r9
00009a  f5b07f80          CMP      r0,#0x100
00009e  dd06              BLE      |L5.174|
                  |L5.160|
;;;186          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
0000a0  2008              MOVS     r0,#8
0000a2  6829              LDR      r1,[r5,#0]
0000a4  6148              STR      r0,[r1,#0x14]
0000a6  6828              LDR      r0,[r5,#0]
0000a8  6801              LDR      r1,[r0,#0]
0000aa  4628              MOV      r0,r5
0000ac  4788              BLX      r1
                  |L5.174|
;;;187        while (i--)
0000ae  e004              B        |L5.186|
                  |L5.176|
;;;188          huffsize[p++] = (char) l;
0000b0  4630              MOV      r0,r6
0000b2  1c76              ADDS     r6,r6,#1
0000b4  f50d6181          ADD      r1,sp,#0x408
0000b8  540c              STRB     r4,[r1,r0]
                  |L5.186|
0000ba  ea5f0009          MOVS     r0,r9                 ;187
0000be  f1a90901          SUB      r9,r9,#1              ;187
0000c2  d1f5              BNE      |L5.176|
0000c4  1c64              ADDS     r4,r4,#1              ;183
                  |L5.198|
0000c6  2c10              CMP      r4,#0x10              ;183
0000c8  dde0              BLE      |L5.140|
;;;189      }
;;;190      huffsize[p] = 0;
0000ca  2000              MOVS     r0,#0
0000cc  f50d6181          ADD      r1,sp,#0x408
0000d0  5588              STRB     r0,[r1,r6]
;;;191      numsymbols = p;
0000d2  f8cd6514          STR      r6,[sp,#0x514]
;;;192      
;;;193      /* Figure C.2: generate the codes themselves */
;;;194      /* We also validate that the counts represent a legal Huffman code tree. */
;;;195      
;;;196      code = 0;
0000d6  4683              MOV      r11,r0
;;;197      si = huffsize[0];
0000d8  f89d0408          LDRB     r0,[sp,#0x408]
0000dc  f8cd0518          STR      r0,[sp,#0x518]
;;;198      p = 0;
0000e0  2600              MOVS     r6,#0
;;;199      while (huffsize[p]) {
0000e2  e022              B        |L5.298|
                  |L5.228|
;;;200        while (((int) huffsize[p]) == si) {
0000e4  e006              B        |L5.244|
                  |L5.230|
;;;201          huffcode[p++] = code;
0000e6  4630              MOV      r0,r6
0000e8  1c76              ADDS     r6,r6,#1
0000ea  a901              ADD      r1,sp,#4
0000ec  f841b020          STR      r11,[r1,r0,LSL #2]
;;;202          code++;
0000f0  f10b0b01          ADD      r11,r11,#1
                  |L5.244|
0000f4  f50d6081          ADD      r0,sp,#0x408          ;200
0000f8  5d81              LDRB     r1,[r0,r6]            ;200
0000fa  f8dd0518          LDR      r0,[sp,#0x518]        ;200
0000fe  4281              CMP      r1,r0                 ;200
000100  d0f1              BEQ      |L5.230|
;;;203        }
;;;204        /* code is now 1 more than the last code used for codelength si; but
;;;205         * it must still fit in si bits, since no code is allowed to be all ones.
;;;206         */
;;;207        if (((INT32) code) >= (((INT32) 1) << si))
000102  2101              MOVS     r1,#1
000104  f8dd0518          LDR      r0,[sp,#0x518]
000108  4081              LSLS     r1,r1,r0
00010a  4559              CMP      r1,r11
00010c  dc06              BGT      |L5.284|
;;;208          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
00010e  2008              MOVS     r0,#8
000110  6829              LDR      r1,[r5,#0]
000112  6148              STR      r0,[r1,#0x14]
000114  6828              LDR      r0,[r5,#0]
000116  6801              LDR      r1,[r0,#0]
000118  4628              MOV      r0,r5
00011a  4788              BLX      r1
                  |L5.284|
;;;209        code <<= 1;
00011c  ea4f0b4b          LSL      r11,r11,#1
;;;210        si++;
000120  f8dd0518          LDR      r0,[sp,#0x518]
000124  1c40              ADDS     r0,r0,#1
000126  f8cd0518          STR      r0,[sp,#0x518]
                  |L5.298|
00012a  f50d6081          ADD      r0,sp,#0x408          ;199
00012e  5d80              LDRB     r0,[r0,r6]            ;199
000130  2800              CMP      r0,#0                 ;199
000132  d1d7              BNE      |L5.228|
;;;211      }
;;;212    
;;;213      /* Figure F.15: generate decoding tables for bit-sequential decoding */
;;;214    
;;;215      p = 0;
000134  2600              MOVS     r6,#0
;;;216      for (l = 1; l <= 16; l++) {
000136  2401              MOVS     r4,#1
000138  e019              B        |L5.366|
                  |L5.314|
;;;217        if (htbl->bits[l]) {
00013a  f8180004          LDRB     r0,[r8,r4]
00013e  b188              CBZ      r0,|L5.356|
;;;218          /* valoffset[l] = huffval[] index of 1st symbol of code length l,
;;;219           * minus the minimum code of length l
;;;220           */
;;;221          dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
000140  a801              ADD      r0,sp,#4
000142  f8500026          LDR      r0,[r0,r6,LSL #2]
000146  1a31              SUBS     r1,r6,r0
000148  f1070048          ADD      r0,r7,#0x48
00014c  f8401024          STR      r1,[r0,r4,LSL #2]
;;;222          p += htbl->bits[l];
000150  f8180004          LDRB     r0,[r8,r4]
000154  4406              ADD      r6,r6,r0
;;;223          dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
000156  1e70              SUBS     r0,r6,#1
000158  a901              ADD      r1,sp,#4
00015a  f8510020          LDR      r0,[r1,r0,LSL #2]
00015e  f8470024          STR      r0,[r7,r4,LSL #2]
000162  e003              B        |L5.364|
                  |L5.356|
;;;224        } else {
;;;225          dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
000164  f04f30ff          MOV      r0,#0xffffffff
000168  f8470024          STR      r0,[r7,r4,LSL #2]
                  |L5.364|
00016c  1c64              ADDS     r4,r4,#1              ;216
                  |L5.366|
00016e  2c10              CMP      r4,#0x10              ;216
000170  dde3              BLE      |L5.314|
;;;226        }
;;;227      }
;;;228      dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
000172  4832              LDR      r0,|L5.572|
000174  6478              STR      r0,[r7,#0x44]
;;;229    
;;;230      /* Compute lookahead tables to speed up decoding.
;;;231       * First we set all the table entries to 0, indicating "too long";
;;;232       * then we iterate through the Huffman codes that are short enough and
;;;233       * fill in all the entries that correspond to bit sequences starting
;;;234       * with that code.
;;;235       */
;;;236    
;;;237      MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
000176  f44f6180          MOV      r1,#0x400
00017a  f1070090          ADD      r0,r7,#0x90
00017e  f7fffffe          BL       __aeabi_memclr4
;;;238    
;;;239      p = 0;
000182  2600              MOVS     r6,#0
;;;240      for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
000184  2401              MOVS     r4,#1
000186  e035              B        |L5.500|
                  |L5.392|
;;;241        for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
000188  f04f0901          MOV      r9,#1
00018c  e02d              B        |L5.490|
                  |L5.398|
;;;242          /* l = current code's length, p = its index in huffcode[] & huffval[]. */
;;;243          /* Generate left-justified code followed by all possible bit sequences */
;;;244          lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
00018e  a801              ADD      r0,sp,#4
000190  f8500026          LDR      r0,[r0,r6,LSL #2]
000194  f1c40108          RSB      r1,r4,#8
000198  4088              LSLS     r0,r0,r1
00019a  f8cd0510          STR      r0,[sp,#0x510]
;;;245          for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
00019e  f1c40108          RSB      r1,r4,#8
0001a2  2001              MOVS     r0,#1
0001a4  4088              LSLS     r0,r0,r1
0001a6  f8cd050c          STR      r0,[sp,#0x50c]
0001aa  e017              B        |L5.476|
                  |L5.428|
;;;246    	dtbl->look_nbits[lookbits] = l;
0001ac  f1070090          ADD      r0,r7,#0x90
0001b0  f8dd1510          LDR      r1,[sp,#0x510]
0001b4  f8404021          STR      r4,[r0,r1,LSL #2]
;;;247    	dtbl->look_sym[lookbits] = htbl->huffval[p];
0001b8  f1080011          ADD      r0,r8,#0x11
0001bc  5d82              LDRB     r2,[r0,r6]
0001be  f5076092          ADD      r0,r7,#0x490
0001c2  f8dd1510          LDR      r1,[sp,#0x510]
0001c6  5442              STRB     r2,[r0,r1]
;;;248    	lookbits++;
0001c8  f8dd0510          LDR      r0,[sp,#0x510]
0001cc  1c40              ADDS     r0,r0,#1
0001ce  f8cd0510          STR      r0,[sp,#0x510]
0001d2  f8dd050c          LDR      r0,[sp,#0x50c]        ;245
0001d6  1e40              SUBS     r0,r0,#1              ;245
0001d8  f8cd050c          STR      r0,[sp,#0x50c]        ;245
                  |L5.476|
0001dc  f8dd050c          LDR      r0,[sp,#0x50c]        ;245
0001e0  2800              CMP      r0,#0                 ;245
0001e2  dce3              BGT      |L5.428|
0001e4  f1090901          ADD      r9,r9,#1              ;241
0001e8  1c76              ADDS     r6,r6,#1              ;241
                  |L5.490|
0001ea  f8180004          LDRB     r0,[r8,r4]            ;241
0001ee  4548              CMP      r0,r9                 ;241
0001f0  dacd              BGE      |L5.398|
0001f2  1c64              ADDS     r4,r4,#1              ;240
                  |L5.500|
0001f4  2c08              CMP      r4,#8                 ;240
0001f6  ddc7              BLE      |L5.392|
;;;249          }
;;;250        }
;;;251      }
;;;252    
;;;253      /* Validate symbols as being reasonable.
;;;254       * For AC tables, we make no check, but accept all byte values 0..255.
;;;255       * For DC tables, we require the symbols to be in range 0..15.
;;;256       * (Tighter bounds could be applied depending on the data depth and mode,
;;;257       * but this is sufficient to ensure safe decoding.)
;;;258       */
;;;259      if (isDC) {
0001f8  f8dd0520          LDR      r0,[sp,#0x520]
0001fc  b1d0              CBZ      r0,|L5.564|
;;;260        for (i = 0; i < numsymbols; i++) {
0001fe  f04f0900          MOV      r9,#0
000202  e013              B        |L5.556|
                  |L5.516|
;;;261          int sym = htbl->huffval[i];
000204  f1080011          ADD      r0,r8,#0x11
000208  f8100009          LDRB     r0,[r0,r9]
00020c  9000              STR      r0,[sp,#0]
;;;262          if (sym < 0 || sym > 15)
00020e  9800              LDR      r0,[sp,#0]
000210  2800              CMP      r0,#0
000212  db02              BLT      |L5.538|
000214  9800              LDR      r0,[sp,#0]
000216  280f              CMP      r0,#0xf
000218  dd06              BLE      |L5.552|
                  |L5.538|
;;;263    	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
00021a  2008              MOVS     r0,#8
00021c  6829              LDR      r1,[r5,#0]
00021e  6148              STR      r0,[r1,#0x14]
000220  6828              LDR      r0,[r5,#0]
000222  6801              LDR      r1,[r0,#0]
000224  4628              MOV      r0,r5
000226  4788              BLX      r1
                  |L5.552|
000228  f1090901          ADD      r9,r9,#1              ;260
                  |L5.556|
00022c  f8dd0514          LDR      r0,[sp,#0x514]        ;260
000230  4581              CMP      r9,r0                 ;260
000232  dbe7              BLT      |L5.516|
                  |L5.564|
;;;264        }
;;;265      }
;;;266    }
000234  f20d5d2c          ADD      sp,sp,#0x52c
000238  e8bd8ff0          POP      {r4-r11,pc}
;;;267    
                          ENDP

                  |L5.572|
                          DCD      0x000fffff

                          AREA ||i.process_restart||, CODE, READONLY, ALIGN=1

                  process_restart PROC
;;;467    LOCAL(boolean)
;;;468    process_restart (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;469    {
000002  4604              MOV      r4,r0
;;;470      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
000004  f8d451bc          LDR      r5,[r4,#0x1bc]
;;;471      int ci;
;;;472    
;;;473      /* Throw away any unused bits remaining in bit buffer; */
;;;474      /* include any full bytes in next_marker's count of discarded bytes */
;;;475      cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
000008  6928              LDR      r0,[r5,#0x10]
00000a  17c1              ASRS     r1,r0,#31
00000c  eb007151          ADD      r1,r0,r1,LSR #29
000010  f8d421b8          LDR      r2,[r4,#0x1b8]
000014  6992              LDR      r2,[r2,#0x18]
000016  eb0201e1          ADD      r1,r2,r1,ASR #3
00001a  f8d421b8          LDR      r2,[r4,#0x1b8]
00001e  6191              STR      r1,[r2,#0x18]
;;;476      entropy->bitstate.bits_left = 0;
000020  2100              MOVS     r1,#0
000022  6129              STR      r1,[r5,#0x10]
;;;477    
;;;478      /* Advance past the RSTn marker */
;;;479      if (! (*cinfo->marker->read_restart_marker) (cinfo))
000024  f8d401b8          LDR      r0,[r4,#0x1b8]
000028  6881              LDR      r1,[r0,#8]
00002a  4620              MOV      r0,r4
00002c  4788              BLX      r1
00002e  b908              CBNZ     r0,|L6.52|
;;;480        return FALSE;
000030  2000              MOVS     r0,#0
                  |L6.50|
;;;481    
;;;482      /* Re-initialize DC predictions to 0 */
;;;483      for (ci = 0; ci < cinfo->comps_in_scan; ci++)
;;;484        entropy->saved.last_dc_val[ci] = 0;
;;;485    
;;;486      /* Reset restart counter */
;;;487      entropy->restarts_to_go = cinfo->restart_interval;
;;;488    
;;;489      /* Reset out-of-data flag, unless read_restart_marker left us smack up
;;;490       * against a marker.  In that case we will end up treating the next data
;;;491       * segment as empty, and we can avoid producing bogus output pixels by
;;;492       * leaving the flag set.
;;;493       */
;;;494      if (cinfo->unread_marker == 0)
;;;495        entropy->pub.insufficient_data = FALSE;
;;;496    
;;;497      return TRUE;
;;;498    }
000032  bd70              POP      {r4-r6,pc}
                  |L6.52|
000034  2600              MOVS     r6,#0                 ;483
000036  e005              B        |L6.68|
                  |L6.56|
000038  2100              MOVS     r1,#0                 ;484
00003a  f1050014          ADD      r0,r5,#0x14           ;484
00003e  f8401026          STR      r1,[r0,r6,LSL #2]     ;484
000042  1c76              ADDS     r6,r6,#1              ;483
                  |L6.68|
000044  f8d40148          LDR      r0,[r4,#0x148]        ;483
000048  42b0              CMP      r0,r6                 ;483
00004a  dcf5              BGT      |L6.56|
00004c  f8d40114          LDR      r0,[r4,#0x114]        ;487
000050  6268              STR      r0,[r5,#0x24]         ;487
000052  f8d401a0          LDR      r0,[r4,#0x1a0]        ;494
000056  b908              CBNZ     r0,|L6.92|
000058  2000              MOVS     r0,#0                 ;495
00005a  60a8              STR      r0,[r5,#8]            ;495
                  |L6.92|
00005c  2001              MOVS     r0,#1                 ;497
00005e  e7e8              B        |L6.50|
;;;499    
                          ENDP


                          AREA ||i.start_pass_huff_decoder||, CODE, READONLY, ALIGN=1

                  start_pass_huff_decoder PROC
;;;85     METHODDEF(void)
;;;86     start_pass_huff_decoder (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;87     {
000004  4605              MOV      r5,r0
;;;88       huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
000006  f8d541bc          LDR      r4,[r5,#0x1bc]
;;;89       int ci, blkn, dctbl, actbl;
;;;90       jpeg_component_info * compptr;
;;;91     
;;;92       /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
;;;93        * This ought to be an error condition, but we make it a warning because
;;;94        * there are some baseline files out there with all zeroes in these bytes.
;;;95        */
;;;96       if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
00000a  f8d50190          LDR      r0,[r5,#0x190]
00000e  b948              CBNZ     r0,|L7.36|
000010  f8d50194          LDR      r0,[r5,#0x194]
000014  283f              CMP      r0,#0x3f
000016  d105              BNE      |L7.36|
;;;97           cinfo->Ah != 0 || cinfo->Al != 0)
000018  f8d50198          LDR      r0,[r5,#0x198]
00001c  b910              CBNZ     r0,|L7.36|
00001e  f8d5019c          LDR      r0,[r5,#0x19c]
000022  b140              CBZ      r0,|L7.54|
                  |L7.36|
;;;98         WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
000024  207a              MOVS     r0,#0x7a
000026  6829              LDR      r1,[r5,#0]
000028  6148              STR      r0,[r1,#0x14]
00002a  6828              LDR      r0,[r5,#0]
00002c  f04f31ff          MOV      r1,#0xffffffff
000030  6842              LDR      r2,[r0,#4]
000032  4628              MOV      r0,r5
000034  4790              BLX      r2
                  |L7.54|
;;;99     
;;;100      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000036  f04f0800          MOV      r8,#0
00003a  e020              B        |L7.126|
                  |L7.60|
;;;101        compptr = cinfo->cur_comp_info[ci];
00003c  f50570a6          ADD      r0,r5,#0x14c
000040  f8507028          LDR      r7,[r0,r8,LSL #2]
;;;102        dctbl = compptr->dc_tbl_no;
000044  f8d79014          LDR      r9,[r7,#0x14]
;;;103        actbl = compptr->ac_tbl_no;
000048  f8d7a018          LDR      r10,[r7,#0x18]
;;;104        /* Compute derived values for Huffman tables */
;;;105        /* We may do this more than once for a table, but it's not expensive */
;;;106        jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
00004c  f1040028          ADD      r0,r4,#0x28
000050  eb000389          ADD      r3,r0,r9,LSL #2
000054  464a              MOV      r2,r9
000056  2101              MOVS     r1,#1
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;107    			    & entropy->dc_derived_tbls[dctbl]);
;;;108        jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
00005e  f1040038          ADD      r0,r4,#0x38
000062  eb00038a          ADD      r3,r0,r10,LSL #2
000066  4652              MOV      r2,r10
000068  2100              MOVS     r1,#0
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;109    			    & entropy->ac_derived_tbls[actbl]);
;;;110        /* Initialize DC predictions to 0 */
;;;111        entropy->saved.last_dc_val[ci] = 0;
000070  2100              MOVS     r1,#0
000072  f1040014          ADD      r0,r4,#0x14
000076  f8401028          STR      r1,[r0,r8,LSL #2]
00007a  f1080801          ADD      r8,r8,#1              ;100
                  |L7.126|
00007e  f8d50148          LDR      r0,[r5,#0x148]        ;100
000082  4540              CMP      r0,r8                 ;100
000084  dcda              BGT      |L7.60|
;;;112      }
;;;113    
;;;114      /* Precalculate decoding info for each block in an MCU of this scan */
;;;115      for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
000086  2600              MOVS     r6,#0
000088  e02f              B        |L7.234|
                  |L7.138|
;;;116        ci = cinfo->MCU_membership[blkn];
00008a  f50570b4          ADD      r0,r5,#0x168
00008e  f8508026          LDR      r8,[r0,r6,LSL #2]
;;;117        compptr = cinfo->cur_comp_info[ci];
000092  381c              SUBS     r0,r0,#0x1c
000094  f8507028          LDR      r7,[r0,r8,LSL #2]
;;;118        /* Precalculate which table to use for each block */
;;;119        entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
000098  f1040028          ADD      r0,r4,#0x28
00009c  6979              LDR      r1,[r7,#0x14]
00009e  f8501021          LDR      r1,[r0,r1,LSL #2]
0000a2  3020              ADDS     r0,r0,#0x20
0000a4  f8401026          STR      r1,[r0,r6,LSL #2]
;;;120        entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
0000a8  3810              SUBS     r0,r0,#0x10
0000aa  69b9              LDR      r1,[r7,#0x18]
0000ac  f8501021          LDR      r1,[r0,r1,LSL #2]
0000b0  3038              ADDS     r0,r0,#0x38
0000b2  f8401026          STR      r1,[r0,r6,LSL #2]
;;;121        /* Decide whether we really care about the coefficient values */
;;;122        if (compptr->component_needed) {
0000b6  6b38              LDR      r0,[r7,#0x30]
0000b8  b170              CBZ      r0,|L7.216|
;;;123          entropy->dc_needed[blkn] = TRUE;
0000ba  2101              MOVS     r1,#1
0000bc  f1040098          ADD      r0,r4,#0x98
0000c0  f8401026          STR      r1,[r0,r6,LSL #2]
;;;124          /* we don't need the ACs if producing a 1/8th-size image */
;;;125          entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
0000c4  6a78              LDR      r0,[r7,#0x24]
0000c6  2801              CMP      r0,#1
0000c8  dd00              BLE      |L7.204|
0000ca  e000              B        |L7.206|
                  |L7.204|
0000cc  2100              MOVS     r1,#0
                  |L7.206|
0000ce  f10400c0          ADD      r0,r4,#0xc0
0000d2  f8401026          STR      r1,[r0,r6,LSL #2]
0000d6  e007              B        |L7.232|
                  |L7.216|
;;;126        } else {
;;;127          entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
0000d8  2100              MOVS     r1,#0
0000da  f10400c0          ADD      r0,r4,#0xc0
0000de  f8401026          STR      r1,[r0,r6,LSL #2]
0000e2  3828              SUBS     r0,r0,#0x28
0000e4  f8401026          STR      r1,[r0,r6,LSL #2]
                  |L7.232|
0000e8  1c76              ADDS     r6,r6,#1              ;115
                  |L7.234|
0000ea  f8d50164          LDR      r0,[r5,#0x164]        ;115
0000ee  42b0              CMP      r0,r6                 ;115
0000f0  dccb              BGT      |L7.138|
;;;128        }
;;;129      }
;;;130    
;;;131      /* Initialize bitread state variables */
;;;132      entropy->bitstate.bits_left = 0;
0000f2  2100              MOVS     r1,#0
0000f4  6121              STR      r1,[r4,#0x10]
;;;133      entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
0000f6  2000              MOVS     r0,#0
0000f8  60e0              STR      r0,[r4,#0xc]
;;;134      entropy->pub.insufficient_data = FALSE;
0000fa  60a0              STR      r0,[r4,#8]
;;;135    
;;;136      /* Initialize restart counter */
;;;137      entropy->restarts_to_go = cinfo->restart_interval;
0000fc  f8d50114          LDR      r0,[r5,#0x114]
000100  6260              STR      r0,[r4,#0x24]
;;;138    }
000102  e8bd87f0          POP      {r4-r10,pc}
;;;139    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  extend_test
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000020
                          DCD      0x00000040
                          DCD      0x00000080
                          DCD      0x00000100
                          DCD      0x00000200
                          DCD      0x00000400
                          DCD      0x00000800
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00004000
                  extend_offset
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xfffffffd
                          DCD      0xfffffff9
                          DCD      0xfffffff1
                          DCD      0xffffffe1
                          DCD      0xffffffc1
                          DCD      0xffffff81
                          DCD      0xffffff01
                          DCD      0xfffffe01
                          DCD      0xfffffc01
                          DCD      0xfffff801
                          DCD      0xfffff001
                          DCD      0xffffe001
                          DCD      0xffffc001
                          DCD      0xffff8001
