; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\os_tmr.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\os_tmr.crf ..\..\uCOS-II\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;107    #if OS_TMR_EN > 0u
;;;108    OS_TMR  *OSTmrCreate (INT32U           dly,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;109                          INT32U           period,
;;;110                          INT8U            opt,
;;;111                          OS_TMR_CALLBACK  callback,
;;;112                          void            *callback_arg,
;;;113                          INT8U           *pname,
;;;114                          INT8U           *perr)
;;;115    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddba0a          LDRD     r11,r10,[sp,#0x28]
000010  9d0c              LDR      r5,[sp,#0x30]
;;;116        OS_TMR   *ptmr;
;;;117    
;;;118    
;;;119    #ifdef OS_SAFETY_CRITICAL
;;;120        if (perr == (INT8U *)0) {
;;;121            OS_SAFETY_CRITICAL_EXCEPTION();
;;;122            return ((OS_TMR *)0);
;;;123        }
;;;124    #endif
;;;125    
;;;126    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;127        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;128            OS_SAFETY_CRITICAL_EXCEPTION();
;;;129            return ((OS_TMR *)0);
;;;130        }
;;;131    #endif
;;;132    
;;;133    #if OS_ARG_CHK_EN > 0u
;;;134        switch (opt) {                                          /* Validate arguments                                     */
;;;135            case OS_TMR_OPT_PERIODIC:
;;;136                 if (period == 0u) {
;;;137                     *perr = OS_ERR_TMR_INVALID_PERIOD;
;;;138                     return ((OS_TMR *)0);
;;;139                 }
;;;140                 break;
;;;141    
;;;142            case OS_TMR_OPT_ONE_SHOT:
;;;143                 if (dly == 0u) {
;;;144                     *perr = OS_ERR_TMR_INVALID_DLY;
;;;145                     return ((OS_TMR *)0);
;;;146                 }
;;;147                 break;
;;;148    
;;;149            default:
;;;150                 *perr = OS_ERR_TMR_INVALID_OPT;
;;;151                 return ((OS_TMR *)0);
;;;152        }
;;;153    #endif
;;;154        if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
000012  4816              LDR      r0,|L1.108|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b120              CBZ      r0,|L1.34|
;;;155            *perr  = OS_ERR_TMR_ISR;
000018  208b              MOVS     r0,#0x8b
00001a  7028              STRB     r0,[r5,#0]
;;;156            return ((OS_TMR *)0);
00001c  2000              MOVS     r0,#0
                  |L1.30|
;;;157        }
;;;158        OSSchedLock();
;;;159        ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
;;;160        if (ptmr == (OS_TMR *)0) {
;;;161            OSSchedUnlock();
;;;162            *perr = OS_ERR_TMR_NON_AVAIL;
;;;163            return ((OS_TMR *)0);
;;;164        }
;;;165        ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
;;;166        ptmr->OSTmrDly         = dly;
;;;167        ptmr->OSTmrPeriod      = period;
;;;168        ptmr->OSTmrOpt         = opt;
;;;169        ptmr->OSTmrCallback    = callback;
;;;170        ptmr->OSTmrCallbackArg = callback_arg;
;;;171    #if OS_TMR_CFG_NAME_EN > 0u
;;;172        if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
;;;173            ptmr->OSTmrName    = (INT8U *)(void *)"?";
;;;174        } else {
;;;175            ptmr->OSTmrName    = pname;
;;;176        }
;;;177    #endif
;;;178        OSSchedUnlock();
;;;179        *perr = OS_ERR_NONE;
;;;180        return (ptmr);
;;;181    }
00001e  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.34|
000022  f7fffffe          BL       OSSchedLock
000026  f7fffffe          BL       OSTmr_Alloc
00002a  4604              MOV      r4,r0                 ;159
00002c  b92c              CBNZ     r4,|L1.58|
00002e  f7fffffe          BL       OSSchedUnlock
000032  2086              MOVS     r0,#0x86              ;162
000034  7028              STRB     r0,[r5,#0]            ;162
000036  2000              MOVS     r0,#0                 ;163
000038  e7f1              B        |L1.30|
                  |L1.58|
00003a  2001              MOVS     r0,#1                 ;165
00003c  f8840025          STRB     r0,[r4,#0x25]         ;165
000040  61a6              STR      r6,[r4,#0x18]         ;166
000042  61e7              STR      r7,[r4,#0x1c]         ;167
000044  f8848024          STRB     r8,[r4,#0x24]         ;168
000048  f8c49004          STR      r9,[r4,#4]            ;169
00004c  f8c4b008          STR      r11,[r4,#8]           ;170
000050  f1ba0f00          CMP      r10,#0                ;172
000054  d102              BNE      |L1.92|
000056  a006              ADR      r0,|L1.112|
000058  6220              STR      r0,[r4,#0x20]         ;173
00005a  e001              B        |L1.96|
                  |L1.92|
00005c  f8c4a020          STR      r10,[r4,#0x20]        ;175
                  |L1.96|
000060  f7fffffe          BL       OSSchedUnlock
000064  2000              MOVS     r0,#0                 ;179
000066  7028              STRB     r0,[r5,#0]            ;179
000068  4620              MOV      r0,r4                 ;180
00006a  e7d8              B        |L1.30|
;;;182    #endif
                          ENDP

                  |L1.108|
                          DCD      OSIntNesting
                  |L1.112|
000070  3f00              DCB      "?",0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.OSTmrDel||, CODE, READONLY, ALIGN=2

                  OSTmrDel PROC
;;;206    #if OS_TMR_EN > 0u
;;;207    BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;208                       INT8U   *perr)
;;;209    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;210    #ifdef OS_SAFETY_CRITICAL
;;;211        if (perr == (INT8U *)0) {
;;;212            OS_SAFETY_CRITICAL_EXCEPTION();
;;;213            return (OS_FALSE);
;;;214        }
;;;215    #endif
;;;216    
;;;217    #if OS_ARG_CHK_EN > 0u
;;;218        if (ptmr == (OS_TMR *)0) {
;;;219            *perr = OS_ERR_TMR_INVALID;
;;;220            return (OS_FALSE);
;;;221        }
;;;222    #endif
;;;223        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000006  7828              LDRB     r0,[r5,#0]
000008  2864              CMP      r0,#0x64
00000a  d003              BEQ      |L2.20|
;;;224            *perr = OS_ERR_TMR_INVALID_TYPE;
00000c  2089              MOVS     r0,#0x89
00000e  7020              STRB     r0,[r4,#0]
;;;225            return (OS_FALSE);
000010  2000              MOVS     r0,#0
                  |L2.18|
;;;226        }
;;;227        if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
;;;228            *perr  = OS_ERR_TMR_ISR;
;;;229            return (OS_FALSE);
;;;230        }
;;;231        OSSchedLock();
;;;232        switch (ptmr->OSTmrState) {
;;;233            case OS_TMR_STATE_RUNNING:
;;;234                 OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
;;;235                 OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;236                 OSSchedUnlock();
;;;237                 *perr = OS_ERR_NONE;
;;;238                 return (OS_TRUE);
;;;239    
;;;240            case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;241            case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;242                 OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
;;;243                 OSSchedUnlock();
;;;244                 *perr = OS_ERR_NONE;
;;;245                 return (OS_TRUE);
;;;246    
;;;247            case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;248                 OSSchedUnlock();
;;;249                 *perr = OS_ERR_TMR_INACTIVE;
;;;250                 return (OS_FALSE);
;;;251    
;;;252            default:
;;;253                 OSSchedUnlock();
;;;254                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;255                 return (OS_FALSE);
;;;256        }
;;;257    }
000012  bd70              POP      {r4-r6,pc}
                  |L2.20|
000014  4819              LDR      r0,|L2.124|
000016  7800              LDRB     r0,[r0,#0]            ;227  ; OSIntNesting
000018  b118              CBZ      r0,|L2.34|
00001a  208b              MOVS     r0,#0x8b              ;228
00001c  7020              STRB     r0,[r4,#0]            ;228
00001e  2000              MOVS     r0,#0                 ;229
000020  e7f7              B        |L2.18|
                  |L2.34|
000022  f7fffffe          BL       OSSchedLock
000026  f8950025          LDRB     r0,[r5,#0x25]         ;232
00002a  b1d8              CBZ      r0,|L2.100|
00002c  2801              CMP      r0,#1                 ;232
00002e  d00f              BEQ      |L2.80|
000030  2802              CMP      r0,#2                 ;232
000032  d00e              BEQ      |L2.82|
000034  2803              CMP      r0,#3                 ;232
000036  d11b              BNE      |L2.112|
000038  4628              MOV      r0,r5                 ;234
00003a  f7fffffe          BL       OSTmr_Unlink
00003e  4628              MOV      r0,r5                 ;235
000040  f7fffffe          BL       OSTmr_Free
000044  f7fffffe          BL       OSSchedUnlock
000048  2000              MOVS     r0,#0                 ;237
00004a  7020              STRB     r0,[r4,#0]            ;237
00004c  2001              MOVS     r0,#1                 ;238
00004e  e7e0              B        |L2.18|
                  |L2.80|
000050  bf00              NOP                            ;241
                  |L2.82|
000052  4628              MOV      r0,r5                 ;242
000054  f7fffffe          BL       OSTmr_Free
000058  f7fffffe          BL       OSSchedUnlock
00005c  2000              MOVS     r0,#0                 ;244
00005e  7020              STRB     r0,[r4,#0]            ;244
000060  2001              MOVS     r0,#1                 ;245
000062  e7d6              B        |L2.18|
                  |L2.100|
000064  f7fffffe          BL       OSSchedUnlock
000068  2087              MOVS     r0,#0x87              ;249
00006a  7020              STRB     r0,[r4,#0]            ;249
00006c  2000              MOVS     r0,#0                 ;250
00006e  e7d0              B        |L2.18|
                  |L2.112|
000070  f7fffffe          BL       OSSchedUnlock
000074  208d              MOVS     r0,#0x8d              ;254
000076  7020              STRB     r0,[r4,#0]            ;254
000078  2000              MOVS     r0,#0                 ;255
00007a  e7ca              B        |L2.18|
;;;258    #endif
                          ENDP

                  |L2.124|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrNameGet||, CODE, READONLY, ALIGN=2

                  OSTmrNameGet PROC
;;;284    #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
;;;285    INT8U  OSTmrNameGet (OS_TMR   *ptmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;286                         INT8U   **pdest,
;;;287                         INT8U    *perr)
;;;288    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;289        INT8U  len;
;;;290    
;;;291    
;;;292    #ifdef OS_SAFETY_CRITICAL
;;;293        if (perr == (INT8U *)0) {
;;;294            OS_SAFETY_CRITICAL_EXCEPTION();
;;;295            return (0u);
;;;296        }
;;;297    #endif
;;;298    
;;;299    #if OS_ARG_CHK_EN > 0u
;;;300        if (pdest == (INT8U **)0) {
;;;301            *perr = OS_ERR_TMR_INVALID_DEST;
;;;302            return (0u);
;;;303        }
;;;304        if (ptmr == (OS_TMR *)0) {
;;;305            *perr = OS_ERR_TMR_INVALID;
;;;306            return (0u);
;;;307        }
;;;308    #endif
;;;309        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00000a  7828              LDRB     r0,[r5,#0]
00000c  2864              CMP      r0,#0x64
00000e  d004              BEQ      |L3.26|
;;;310            *perr = OS_ERR_TMR_INVALID_TYPE;
000010  2089              MOVS     r0,#0x89
000012  7020              STRB     r0,[r4,#0]
;;;311            return (0u);
000014  2000              MOVS     r0,#0
                  |L3.22|
;;;312        }
;;;313        if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
;;;314            *perr = OS_ERR_NAME_GET_ISR;
;;;315            return (0u);
;;;316        }
;;;317        OSSchedLock();
;;;318        switch (ptmr->OSTmrState) {
;;;319            case OS_TMR_STATE_RUNNING:
;;;320            case OS_TMR_STATE_STOPPED:
;;;321            case OS_TMR_STATE_COMPLETED:
;;;322                 *pdest = ptmr->OSTmrName;
;;;323                 len    = OS_StrLen(*pdest);
;;;324                 OSSchedUnlock();
;;;325                 *perr = OS_ERR_NONE;
;;;326                 return (len);
;;;327    
;;;328            case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
;;;329                 OSSchedUnlock();
;;;330                 *perr = OS_ERR_TMR_INACTIVE;
;;;331                 return (0u);
;;;332    
;;;333            default:
;;;334                 OSSchedUnlock();
;;;335                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;336                 return (0u);
;;;337        }
;;;338    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L3.26|
00001a  4816              LDR      r0,|L3.116|
00001c  7800              LDRB     r0,[r0,#0]            ;313  ; OSIntNesting
00001e  b118              CBZ      r0,|L3.40|
000020  2011              MOVS     r0,#0x11              ;314
000022  7020              STRB     r0,[r4,#0]            ;314
000024  2000              MOVS     r0,#0                 ;315
000026  e7f6              B        |L3.22|
                  |L3.40|
000028  f7fffffe          BL       OSSchedLock
00002c  f8950025          LDRB     r0,[r5,#0x25]         ;318
000030  b198              CBZ      r0,|L3.90|
000032  2801              CMP      r0,#1                 ;318
000034  d004              BEQ      |L3.64|
000036  2802              CMP      r0,#2                 ;318
000038  d003              BEQ      |L3.66|
00003a  2803              CMP      r0,#3                 ;318
00003c  d113              BNE      |L3.102|
00003e  bf00              NOP                            ;320
                  |L3.64|
000040  bf00              NOP                            ;321
                  |L3.66|
000042  6a28              LDR      r0,[r5,#0x20]         ;322
000044  6030              STR      r0,[r6,#0]            ;322
000046  6830              LDR      r0,[r6,#0]            ;323
000048  f7fffffe          BL       OS_StrLen
00004c  4607              MOV      r7,r0                 ;323
00004e  f7fffffe          BL       OSSchedUnlock
000052  2000              MOVS     r0,#0                 ;325
000054  7020              STRB     r0,[r4,#0]            ;325
000056  4638              MOV      r0,r7                 ;326
000058  e7dd              B        |L3.22|
                  |L3.90|
00005a  f7fffffe          BL       OSSchedUnlock
00005e  2087              MOVS     r0,#0x87              ;330
000060  7020              STRB     r0,[r4,#0]            ;330
000062  2000              MOVS     r0,#0                 ;331
000064  e7d7              B        |L3.22|
                  |L3.102|
000066  f7fffffe          BL       OSSchedUnlock
00006a  208d              MOVS     r0,#0x8d              ;335
00006c  7020              STRB     r0,[r4,#0]            ;335
00006e  2000              MOVS     r0,#0                 ;336
000070  e7d1              B        |L3.22|
;;;339    #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;364    #if OS_TMR_EN > 0u
;;;365    INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;366                            INT8U   *perr)
;;;367    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;368        INT32U  remain;
;;;369    
;;;370    
;;;371    #ifdef OS_SAFETY_CRITICAL
;;;372        if (perr == (INT8U *)0) {
;;;373            OS_SAFETY_CRITICAL_EXCEPTION();
;;;374            return (0u);
;;;375        }
;;;376    #endif
;;;377    
;;;378    #if OS_ARG_CHK_EN > 0u
;;;379        if (ptmr == (OS_TMR *)0) {
;;;380            *perr = OS_ERR_TMR_INVALID;
;;;381            return (0u);
;;;382        }
;;;383    #endif
;;;384        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000006  7820              LDRB     r0,[r4,#0]
000008  2864              CMP      r0,#0x64
00000a  d003              BEQ      |L4.20|
;;;385            *perr = OS_ERR_TMR_INVALID_TYPE;
00000c  2089              MOVS     r0,#0x89
00000e  7028              STRB     r0,[r5,#0]
;;;386            return (0u);
000010  2000              MOVS     r0,#0
                  |L4.18|
;;;387        }
;;;388        if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
;;;389            *perr = OS_ERR_TMR_ISR;
;;;390            return (0u);
;;;391        }
;;;392        OSSchedLock();
;;;393        switch (ptmr->OSTmrState) {
;;;394            case OS_TMR_STATE_RUNNING:
;;;395                 remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
;;;396                 OSSchedUnlock();
;;;397                 *perr  = OS_ERR_NONE;
;;;398                 return (remain);
;;;399    
;;;400            case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
;;;401                 switch (ptmr->OSTmrOpt) {
;;;402                     case OS_TMR_OPT_PERIODIC:
;;;403                          if (ptmr->OSTmrDly == 0u) {
;;;404                              remain = ptmr->OSTmrPeriod;
;;;405                          } else {
;;;406                              remain = ptmr->OSTmrDly;
;;;407                          }
;;;408                          OSSchedUnlock();
;;;409                          *perr  = OS_ERR_NONE;
;;;410                          break;
;;;411    
;;;412                     case OS_TMR_OPT_ONE_SHOT:
;;;413                     default:
;;;414                          remain = ptmr->OSTmrDly;
;;;415                          OSSchedUnlock();
;;;416                          *perr  = OS_ERR_NONE;
;;;417                          break;
;;;418                 }
;;;419                 return (remain);
;;;420    
;;;421            case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
;;;422                 OSSchedUnlock();
;;;423                 *perr = OS_ERR_NONE;
;;;424                 return (0u);
;;;425    
;;;426            case OS_TMR_STATE_UNUSED:
;;;427                 OSSchedUnlock();
;;;428                 *perr = OS_ERR_TMR_INACTIVE;
;;;429                 return (0u);
;;;430    
;;;431            default:
;;;432                 OSSchedUnlock();
;;;433                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;434                 return (0u);
;;;435        }
;;;436    }
000012  bd70              POP      {r4-r6,pc}
                  |L4.20|
000014  4823              LDR      r0,|L4.164|
000016  7800              LDRB     r0,[r0,#0]            ;388  ; OSIntNesting
000018  b118              CBZ      r0,|L4.34|
00001a  208b              MOVS     r0,#0x8b              ;389
00001c  7028              STRB     r0,[r5,#0]            ;389
00001e  2000              MOVS     r0,#0                 ;390
000020  e7f7              B        |L4.18|
                  |L4.34|
000022  f7fffffe          BL       OSSchedLock
000026  f8940025          LDRB     r0,[r4,#0x25]         ;393
00002a  b370              CBZ      r0,|L4.138|
00002c  2801              CMP      r0,#1                 ;393
00002e  d00d              BEQ      |L4.76|
000030  2802              CMP      r0,#2                 ;393
000032  d025              BEQ      |L4.128|
000034  2803              CMP      r0,#3                 ;393
000036  d12f              BNE      |L4.152|
000038  491b              LDR      r1,|L4.168|
00003a  6960              LDR      r0,[r4,#0x14]         ;395
00003c  6809              LDR      r1,[r1,#0]            ;395  ; OSTmrTime
00003e  1a46              SUBS     r6,r0,r1              ;395
000040  f7fffffe          BL       OSSchedUnlock
000044  2000              MOVS     r0,#0                 ;397
000046  7028              STRB     r0,[r5,#0]            ;397
000048  4630              MOV      r0,r6                 ;398
00004a  e7e2              B        |L4.18|
                  |L4.76|
00004c  f8940024          LDRB     r0,[r4,#0x24]         ;401
000050  2801              CMP      r0,#1                 ;401
000052  d00c              BEQ      |L4.110|
000054  2802              CMP      r0,#2                 ;401
000056  d109              BNE      |L4.108|
000058  69a0              LDR      r0,[r4,#0x18]         ;403
00005a  b908              CBNZ     r0,|L4.96|
00005c  69e6              LDR      r6,[r4,#0x1c]         ;404
00005e  e000              B        |L4.98|
                  |L4.96|
000060  69a6              LDR      r6,[r4,#0x18]         ;406
                  |L4.98|
000062  f7fffffe          BL       OSSchedUnlock
000066  2000              MOVS     r0,#0                 ;409
000068  7028              STRB     r0,[r5,#0]            ;409
00006a  e006              B        |L4.122|
                  |L4.108|
00006c  bf00              NOP                            ;412
                  |L4.110|
00006e  69a6              LDR      r6,[r4,#0x18]         ;414
000070  f7fffffe          BL       OSSchedUnlock
000074  2000              MOVS     r0,#0                 ;416
000076  7028              STRB     r0,[r5,#0]            ;416
000078  bf00              NOP                            ;417
                  |L4.122|
00007a  bf00              NOP                            ;410
00007c  4630              MOV      r0,r6                 ;419
00007e  e7c8              B        |L4.18|
                  |L4.128|
000080  f7fffffe          BL       OSSchedUnlock
000084  2000              MOVS     r0,#0                 ;423
000086  7028              STRB     r0,[r5,#0]            ;423
000088  e7c3              B        |L4.18|
                  |L4.138|
00008a  e7ff              B        |L4.140|
                  |L4.140|
00008c  f7fffffe          BL       OSSchedUnlock
000090  2087              MOVS     r0,#0x87              ;428
000092  7028              STRB     r0,[r5,#0]            ;428
000094  2000              MOVS     r0,#0                 ;429
000096  e7bc              B        |L4.18|
                  |L4.152|
000098  f7fffffe          BL       OSSchedUnlock
00009c  208d              MOVS     r0,#0x8d              ;433
00009e  7028              STRB     r0,[r5,#0]            ;433
0000a0  2000              MOVS     r0,#0                 ;434
0000a2  e7b6              B        |L4.18|
;;;437    #endif
                          ENDP

                  |L4.164|
                          DCD      OSIntNesting
                  |L4.168|
                          DCD      OSTmrTime

                          AREA ||i.OSTmrSignal||, CODE, READONLY, ALIGN=2

                  OSTmrSignal PROC
;;;728    #if OS_TMR_EN > 0u
;;;729    INT8U  OSTmrSignal (void)
000000  b510              PUSH     {r4,lr}
;;;730    {
;;;731        INT8U  err;
;;;732    
;;;733    
;;;734        err = OSSemPost(OSTmrSemSignal);
000002  4803              LDR      r0,|L5.16|
000004  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
000006  f7fffffe          BL       OSSemPost
00000a  4604              MOV      r4,r0
;;;735        return (err);
00000c  4620              MOV      r0,r4
;;;736    }
00000e  bd10              POP      {r4,pc}
;;;737    #endif
                          ENDP

                  |L5.16|
                          DCD      OSTmrSemSignal

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;534    #if OS_TMR_EN > 0u
;;;535    BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;536                         INT8U    *perr)
;;;537    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;538    #ifdef OS_SAFETY_CRITICAL
;;;539        if (perr == (INT8U *)0) {
;;;540            OS_SAFETY_CRITICAL_EXCEPTION();
;;;541            return (OS_FALSE);
;;;542        }
;;;543    #endif
;;;544    
;;;545    #if OS_ARG_CHK_EN > 0u
;;;546        if (ptmr == (OS_TMR *)0) {
;;;547            *perr = OS_ERR_TMR_INVALID;
;;;548            return (OS_FALSE);
;;;549        }
;;;550    #endif
;;;551        if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000006  7828              LDRB     r0,[r5,#0]
000008  2864              CMP      r0,#0x64
00000a  d003              BEQ      |L6.20|
;;;552            *perr = OS_ERR_TMR_INVALID_TYPE;
00000c  2089              MOVS     r0,#0x89
00000e  7020              STRB     r0,[r4,#0]
;;;553            return (OS_FALSE);
000010  2000              MOVS     r0,#0
                  |L6.18|
;;;554        }
;;;555        if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
;;;556            *perr  = OS_ERR_TMR_ISR;
;;;557            return (OS_FALSE);
;;;558        }
;;;559        OSSchedLock();
;;;560        switch (ptmr->OSTmrState) {
;;;561            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;562                 OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
;;;563                 OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;564                 OSSchedUnlock();
;;;565                 *perr = OS_ERR_NONE;
;;;566                 return (OS_TRUE);
;;;567    
;;;568            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;569            case OS_TMR_STATE_COMPLETED:
;;;570                 OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
;;;571                 OSSchedUnlock();
;;;572                 *perr = OS_ERR_NONE;
;;;573                 return (OS_TRUE);
;;;574    
;;;575            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;576                 OSSchedUnlock();
;;;577                 *perr = OS_ERR_TMR_INACTIVE;
;;;578                 return (OS_FALSE);
;;;579    
;;;580            default:
;;;581                 OSSchedUnlock();
;;;582                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;583                 return (OS_FALSE);
;;;584        }
;;;585    }
000012  bd70              POP      {r4-r6,pc}
                  |L6.20|
000014  481a              LDR      r0,|L6.128|
000016  7800              LDRB     r0,[r0,#0]            ;555  ; OSIntNesting
000018  b118              CBZ      r0,|L6.34|
00001a  208b              MOVS     r0,#0x8b              ;556
00001c  7020              STRB     r0,[r4,#0]            ;556
00001e  2000              MOVS     r0,#0                 ;557
000020  e7f7              B        |L6.18|
                  |L6.34|
000022  f7fffffe          BL       OSSchedLock
000026  f8950025          LDRB     r0,[r5,#0x25]         ;560
00002a  b1e8              CBZ      r0,|L6.104|
00002c  2801              CMP      r0,#1                 ;560
00002e  d010              BEQ      |L6.82|
000030  2802              CMP      r0,#2                 ;560
000032  d00f              BEQ      |L6.84|
000034  2803              CMP      r0,#3                 ;560
000036  d11d              BNE      |L6.116|
000038  4628              MOV      r0,r5                 ;562
00003a  f7fffffe          BL       OSTmr_Unlink
00003e  2100              MOVS     r1,#0                 ;563
000040  4628              MOV      r0,r5                 ;563
000042  f7fffffe          BL       OSTmr_Link
000046  f7fffffe          BL       OSSchedUnlock
00004a  2000              MOVS     r0,#0                 ;565
00004c  7020              STRB     r0,[r4,#0]            ;565
00004e  2001              MOVS     r0,#1                 ;566
000050  e7df              B        |L6.18|
                  |L6.82|
000052  bf00              NOP                            ;569
                  |L6.84|
000054  2100              MOVS     r1,#0                 ;570
000056  4628              MOV      r0,r5                 ;570
000058  f7fffffe          BL       OSTmr_Link
00005c  f7fffffe          BL       OSSchedUnlock
000060  2000              MOVS     r0,#0                 ;572
000062  7020              STRB     r0,[r4,#0]            ;572
000064  2001              MOVS     r0,#1                 ;573
000066  e7d4              B        |L6.18|
                  |L6.104|
000068  f7fffffe          BL       OSSchedUnlock
00006c  2087              MOVS     r0,#0x87              ;577
00006e  7020              STRB     r0,[r4,#0]            ;577
000070  2000              MOVS     r0,#0                 ;578
000072  e7ce              B        |L6.18|
                  |L6.116|
000074  f7fffffe          BL       OSSchedUnlock
000078  208d              MOVS     r0,#0x8d              ;582
00007a  7020              STRB     r0,[r4,#0]            ;582
00007c  2000              MOVS     r0,#0                 ;583
00007e  e7c8              B        |L6.18|
;;;586    #endif
                          ENDP

                  |L6.128|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;465    #if OS_TMR_EN > 0u
;;;466    INT8U  OSTmrStateGet (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;467                          INT8U   *perr)
;;;468    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;469        INT8U  state;
;;;470    
;;;471    
;;;472    #ifdef OS_SAFETY_CRITICAL
;;;473        if (perr == (INT8U *)0) {
;;;474            OS_SAFETY_CRITICAL_EXCEPTION();
;;;475            return (0u);
;;;476        }
;;;477    #endif
;;;478    
;;;479    #if OS_ARG_CHK_EN > 0u
;;;480        if (ptmr == (OS_TMR *)0) {
;;;481            *perr = OS_ERR_TMR_INVALID;
;;;482            return (0u);
;;;483        }
;;;484    #endif
;;;485        if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
000006  7828              LDRB     r0,[r5,#0]
000008  2864              CMP      r0,#0x64
00000a  d003              BEQ      |L7.20|
;;;486            *perr = OS_ERR_TMR_INVALID_TYPE;
00000c  2089              MOVS     r0,#0x89
00000e  7020              STRB     r0,[r4,#0]
;;;487            return (0u);
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;488        }
;;;489        if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
;;;490            *perr = OS_ERR_TMR_ISR;
;;;491            return (0u);
;;;492        }
;;;493        OSSchedLock();
;;;494        state = ptmr->OSTmrState;
;;;495        switch (state) {
;;;496            case OS_TMR_STATE_UNUSED:
;;;497            case OS_TMR_STATE_STOPPED:
;;;498            case OS_TMR_STATE_COMPLETED:
;;;499            case OS_TMR_STATE_RUNNING:
;;;500                 *perr = OS_ERR_NONE;
;;;501                 break;
;;;502    
;;;503            default:
;;;504                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;505                 break;
;;;506        }
;;;507        OSSchedUnlock();
;;;508        return (state);
;;;509    }
000012  bd70              POP      {r4-r6,pc}
                  |L7.20|
000014  4810              LDR      r0,|L7.88|
000016  7800              LDRB     r0,[r0,#0]            ;489  ; OSIntNesting
000018  b118              CBZ      r0,|L7.34|
00001a  208b              MOVS     r0,#0x8b              ;490
00001c  7020              STRB     r0,[r4,#0]            ;490
00001e  2000              MOVS     r0,#0                 ;491
000020  e7f7              B        |L7.18|
                  |L7.34|
000022  f7fffffe          BL       OSSchedLock
000026  f8956025          LDRB     r6,[r5,#0x25]         ;494
00002a  b136              CBZ      r6,|L7.58|
00002c  2e01              CMP      r6,#1                 ;495
00002e  d005              BEQ      |L7.60|
000030  2e02              CMP      r6,#2                 ;495
000032  d004              BEQ      |L7.62|
000034  2e03              CMP      r6,#3                 ;495
000036  d106              BNE      |L7.70|
000038  e002              B        |L7.64|
                  |L7.58|
00003a  bf00              NOP                            ;497
                  |L7.60|
00003c  bf00              NOP                            ;498
                  |L7.62|
00003e  bf00              NOP                            ;499
                  |L7.64|
000040  2000              MOVS     r0,#0                 ;500
000042  7020              STRB     r0,[r4,#0]            ;500
000044  e002              B        |L7.76|
                  |L7.70|
000046  208d              MOVS     r0,#0x8d              ;504
000048  7020              STRB     r0,[r4,#0]            ;504
00004a  bf00              NOP                            ;505
                  |L7.76|
00004c  bf00              NOP                            ;501
00004e  f7fffffe          BL       OSSchedUnlock
000052  4630              MOV      r0,r6                 ;508
000054  e7dd              B        |L7.18|
;;;510    #endif
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      OSIntNesting

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;625    #if OS_TMR_EN > 0u
;;;626    BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;627                        INT8U    opt,
;;;628                        void    *callback_arg,
;;;629                        INT8U   *perr)
;;;630    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;631        OS_TMR_CALLBACK  pfnct;
;;;632    
;;;633    
;;;634    #ifdef OS_SAFETY_CRITICAL
;;;635        if (perr == (INT8U *)0) {
;;;636            OS_SAFETY_CRITICAL_EXCEPTION();
;;;637            return (OS_FALSE);
;;;638        }
;;;639    #endif
;;;640    
;;;641    #if OS_ARG_CHK_EN > 0u
;;;642        if (ptmr == (OS_TMR *)0) {
;;;643            *perr = OS_ERR_TMR_INVALID;
;;;644            return (OS_FALSE);
;;;645        }
;;;646    #endif
;;;647        if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2864              CMP      r0,#0x64
000010  d004              BEQ      |L8.28|
;;;648            *perr = OS_ERR_TMR_INVALID_TYPE;
000012  2089              MOVS     r0,#0x89
000014  7020              STRB     r0,[r4,#0]
;;;649            return (OS_FALSE);
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;650        }
;;;651        if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
;;;652            *perr  = OS_ERR_TMR_ISR;
;;;653            return (OS_FALSE);
;;;654        }
;;;655        OSSchedLock();
;;;656        switch (ptmr->OSTmrState) {
;;;657            case OS_TMR_STATE_RUNNING:
;;;658                 OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
;;;659                 *perr = OS_ERR_NONE;
;;;660                 switch (opt) {
;;;661                     case OS_TMR_OPT_CALLBACK:
;;;662                          pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;663                          if (pfnct != (OS_TMR_CALLBACK)0) {
;;;664                              (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
;;;665                          } else {
;;;666                              *perr = OS_ERR_TMR_NO_CALLBACK;
;;;667                          }
;;;668                          break;
;;;669    
;;;670                     case OS_TMR_OPT_CALLBACK_ARG:
;;;671                          pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
;;;672                          if (pfnct != (OS_TMR_CALLBACK)0) {
;;;673                              (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
;;;674                          } else {
;;;675                              *perr = OS_ERR_TMR_NO_CALLBACK;
;;;676                          }
;;;677                          break;
;;;678    
;;;679                     case OS_TMR_OPT_NONE:
;;;680                          break;
;;;681    
;;;682                     default:
;;;683                         *perr = OS_ERR_TMR_INVALID_OPT;
;;;684                         break;
;;;685                 }
;;;686                 OSSchedUnlock();
;;;687                 return (OS_TRUE);
;;;688    
;;;689            case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
;;;690            case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
;;;691                 OSSchedUnlock();
;;;692                 *perr = OS_ERR_TMR_STOPPED;
;;;693                 return (OS_TRUE);
;;;694    
;;;695            case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
;;;696                 OSSchedUnlock();
;;;697                 *perr = OS_ERR_TMR_INACTIVE;
;;;698                 return (OS_FALSE);
;;;699    
;;;700            default:
;;;701                 OSSchedUnlock();
;;;702                 *perr = OS_ERR_TMR_INVALID_STATE;
;;;703                 return (OS_FALSE);
;;;704        }
;;;705    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L8.28|
00001c  4825              LDR      r0,|L8.180|
00001e  7800              LDRB     r0,[r0,#0]            ;651  ; OSIntNesting
000020  b118              CBZ      r0,|L8.42|
000022  208b              MOVS     r0,#0x8b              ;652
000024  7020              STRB     r0,[r4,#0]            ;652
000026  2000              MOVS     r0,#0                 ;653
000028  e7f6              B        |L8.24|
                  |L8.42|
00002a  f7fffffe          BL       OSSchedLock
00002e  f8950025          LDRB     r0,[r5,#0x25]         ;656
000032  2800              CMP      r0,#0                 ;656
000034  d032              BEQ      |L8.156|
000036  2801              CMP      r0,#1                 ;656
000038  d02a              BEQ      |L8.144|
00003a  2802              CMP      r0,#2                 ;656
00003c  d027              BEQ      |L8.142|
00003e  2803              CMP      r0,#3                 ;656
000040  d132              BNE      |L8.168|
000042  4628              MOV      r0,r5                 ;658
000044  f7fffffe          BL       OSTmr_Unlink
000048  2000              MOVS     r0,#0                 ;659
00004a  7020              STRB     r0,[r4,#0]            ;659
00004c  b1b7              CBZ      r7,|L8.124|
00004e  2f03              CMP      r7,#3                 ;660
000050  d002              BEQ      |L8.88|
000052  2f04              CMP      r7,#4                 ;660
000054  d113              BNE      |L8.126|
000056  e008              B        |L8.106|
                  |L8.88|
000058  686e              LDR      r6,[r5,#4]            ;662
00005a  b11e              CBZ      r6,|L8.100|
00005c  4628              MOV      r0,r5                 ;664
00005e  68a9              LDR      r1,[r5,#8]            ;664
000060  47b0              BLX      r6                    ;664
000062  e001              B        |L8.104|
                  |L8.100|
000064  208f              MOVS     r0,#0x8f              ;666
000066  7020              STRB     r0,[r4,#0]            ;666
                  |L8.104|
000068  e00c              B        |L8.132|
                  |L8.106|
00006a  686e              LDR      r6,[r5,#4]            ;671
00006c  b11e              CBZ      r6,|L8.118|
00006e  4641              MOV      r1,r8                 ;673
000070  4628              MOV      r0,r5                 ;673
000072  47b0              BLX      r6                    ;673
000074  e001              B        |L8.122|
                  |L8.118|
000076  208f              MOVS     r0,#0x8f              ;675
000078  7020              STRB     r0,[r4,#0]            ;675
                  |L8.122|
00007a  e003              B        |L8.132|
                  |L8.124|
00007c  e002              B        |L8.132|
                  |L8.126|
00007e  2084              MOVS     r0,#0x84              ;683
000080  7020              STRB     r0,[r4,#0]            ;683
000082  bf00              NOP                            ;684
                  |L8.132|
000084  bf00              NOP                            ;668
000086  f7fffffe          BL       OSSchedUnlock
00008a  2001              MOVS     r0,#1                 ;687
00008c  e7c4              B        |L8.24|
                  |L8.142|
00008e  bf00              NOP                            ;690
                  |L8.144|
000090  f7fffffe          BL       OSSchedUnlock
000094  208e              MOVS     r0,#0x8e              ;692
000096  7020              STRB     r0,[r4,#0]            ;692
000098  2001              MOVS     r0,#1                 ;693
00009a  e7bd              B        |L8.24|
                  |L8.156|
00009c  f7fffffe          BL       OSSchedUnlock
0000a0  2087              MOVS     r0,#0x87              ;697
0000a2  7020              STRB     r0,[r4,#0]            ;697
0000a4  2000              MOVS     r0,#0                 ;698
0000a6  e7b7              B        |L8.24|
                  |L8.168|
0000a8  f7fffffe          BL       OSSchedUnlock
0000ac  208d              MOVS     r0,#0x8d              ;702
0000ae  7020              STRB     r0,[r4,#0]            ;702
0000b0  2000              MOVS     r0,#0                 ;703
0000b2  e7b1              B        |L8.24|
;;;706    #endif
                          ENDP

                  |L8.180|
                          DCD      OSIntNesting

                          AREA ||i.OSTmr_Alloc||, CODE, READONLY, ALIGN=2

                  OSTmr_Alloc PROC
;;;752    #if OS_TMR_EN > 0u
;;;753    static  OS_TMR  *OSTmr_Alloc (void)
000000  480c              LDR      r0,|L9.52|
;;;754    {
;;;755        OS_TMR *ptmr;
;;;756    
;;;757    
;;;758        if (OSTmrFreeList == (OS_TMR *)0) {
000002  6800              LDR      r0,[r0,#0]  ; OSTmrFreeList
000004  b908              CBNZ     r0,|L9.10|
;;;759            return ((OS_TMR *)0);
000006  2000              MOVS     r0,#0
                  |L9.8|
;;;760        }
;;;761        ptmr            = (OS_TMR *)OSTmrFreeList;
;;;762        OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
;;;763        ptmr->OSTmrNext = (OS_TCB *)0;
;;;764        ptmr->OSTmrPrev = (OS_TCB *)0;
;;;765        OSTmrUsed++;
;;;766        OSTmrFree--;
;;;767        return (ptmr);
;;;768    }
000008  4770              BX       lr
                  |L9.10|
00000a  480a              LDR      r0,|L9.52|
00000c  6801              LDR      r1,[r0,#0]            ;761  ; OSTmrFreeList
00000e  4a09              LDR      r2,|L9.52|
000010  68c8              LDR      r0,[r1,#0xc]          ;762
000012  6010              STR      r0,[r2,#0]            ;762  ; OSTmrFreeList
000014  2000              MOVS     r0,#0                 ;763
000016  60c8              STR      r0,[r1,#0xc]          ;763
000018  6108              STR      r0,[r1,#0x10]         ;764
00001a  4807              LDR      r0,|L9.56|
00001c  8800              LDRH     r0,[r0,#0]            ;765  ; OSTmrUsed
00001e  1c40              ADDS     r0,r0,#1              ;765
000020  4a05              LDR      r2,|L9.56|
000022  8010              STRH     r0,[r2,#0]            ;765
000024  4805              LDR      r0,|L9.60|
000026  8800              LDRH     r0,[r0,#0]            ;766  ; OSTmrFree
000028  1e40              SUBS     r0,r0,#1              ;766
00002a  4a04              LDR      r2,|L9.60|
00002c  8010              STRH     r0,[r2,#0]            ;766
00002e  4608              MOV      r0,r1                 ;767
000030  e7ea              B        |L9.8|
;;;769    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      OSTmrFreeList
                  |L9.56|
                          DCD      OSTmrUsed
                  |L9.60|
                          DCD      OSTmrFree

                          AREA ||i.OSTmr_Free||, CODE, READONLY, ALIGN=2

                  OSTmr_Free PROC
;;;784    #if OS_TMR_EN > 0u
;;;785    static  void  OSTmr_Free (OS_TMR *ptmr)
000000  2100              MOVS     r1,#0
;;;786    {
;;;787        ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
000002  f8801025          STRB     r1,[r0,#0x25]
;;;788        ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
000006  f8801024          STRB     r1,[r0,#0x24]
;;;789        ptmr->OSTmrPeriod      = 0u;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;790        ptmr->OSTmrMatch       = 0u;
00000c  6141              STR      r1,[r0,#0x14]
;;;791        ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
00000e  6041              STR      r1,[r0,#4]
;;;792        ptmr->OSTmrCallbackArg = (void *)0;
000010  6081              STR      r1,[r0,#8]
;;;793    #if OS_TMR_CFG_NAME_EN > 0u
;;;794        ptmr->OSTmrName        = (INT8U *)(void *)"?";
000012  a10a              ADR      r1,|L10.60|
000014  6201              STR      r1,[r0,#0x20]
;;;795    #endif
;;;796    
;;;797        ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
000016  2100              MOVS     r1,#0
000018  6101              STR      r1,[r0,#0x10]
;;;798        ptmr->OSTmrNext        = OSTmrFreeList;
00001a  4909              LDR      r1,|L10.64|
00001c  6809              LDR      r1,[r1,#0]  ; OSTmrFreeList
00001e  60c1              STR      r1,[r0,#0xc]
;;;799        OSTmrFreeList          = ptmr;
000020  4907              LDR      r1,|L10.64|
000022  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;800    
;;;801        OSTmrUsed--;                                       /* Update timer object statistics                              */
000024  4907              LDR      r1,|L10.68|
000026  8809              LDRH     r1,[r1,#0]  ; OSTmrUsed
000028  1e49              SUBS     r1,r1,#1
00002a  4a06              LDR      r2,|L10.68|
00002c  8011              STRH     r1,[r2,#0]
;;;802        OSTmrFree++;
00002e  4906              LDR      r1,|L10.72|
000030  8809              LDRH     r1,[r1,#0]  ; OSTmrFree
000032  1c49              ADDS     r1,r1,#1
000034  4a04              LDR      r2,|L10.72|
000036  8011              STRH     r1,[r2,#0]
;;;803    }
000038  4770              BX       lr
;;;804    #endif
                          ENDP

00003a  0000              DCW      0x0000
                  |L10.60|
00003c  3f00              DCB      "?",0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L10.64|
                          DCD      OSTmrFreeList
                  |L10.68|
                          DCD      OSTmrUsed
                  |L10.72|
                          DCD      OSTmrFree

                          AREA ||i.OSTmr_Init||, CODE, READONLY, ALIGN=2

                  OSTmr_Init PROC
;;;820    #if OS_TMR_EN > 0u
;;;821    void  OSTmr_Init (void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;822    {
;;;823    #if OS_EVENT_NAME_EN > 0u
;;;824        INT8U    err;
;;;825    #endif
;;;826        INT16U   ix;
;;;827        INT16U   ix_next;
;;;828        OS_TMR  *ptmr1;
;;;829        OS_TMR  *ptmr2;
;;;830    
;;;831    
;;;832        OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
000002  f44f7120          MOV      r1,#0x280
000006  4828              LDR      r0,|L11.168|
000008  f7fffffe          BL       OS_MemClr
;;;833        OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00000c  2140              MOVS     r1,#0x40
00000e  4827              LDR      r0,|L11.172|
000010  f7fffffe          BL       OS_MemClr
;;;834    
;;;835        for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
000014  2500              MOVS     r5,#0
000016  e014              B        |L11.66|
                  |L11.24|
;;;836            ix_next = ix + 1u;
000018  1c68              ADDS     r0,r5,#1
00001a  b286              UXTH     r6,r0
;;;837            ptmr1 = &OSTmrTbl[ix];
00001c  eb050085          ADD      r0,r5,r5,LSL #2
000020  4921              LDR      r1,|L11.168|
000022  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;838            ptmr2 = &OSTmrTbl[ix_next];
000026  eb060086          ADD      r0,r6,r6,LSL #2
00002a  eb0107c0          ADD      r7,r1,r0,LSL #3
;;;839            ptmr1->OSTmrType    = OS_TMR_TYPE;
00002e  2064              MOVS     r0,#0x64
000030  7020              STRB     r0,[r4,#0]
;;;840            ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000032  2000              MOVS     r0,#0
000034  f8840025          STRB     r0,[r4,#0x25]
;;;841            ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
000038  60e7              STR      r7,[r4,#0xc]
;;;842    #if OS_TMR_CFG_NAME_EN > 0u
;;;843            ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00003a  a01d              ADR      r0,|L11.176|
00003c  6220              STR      r0,[r4,#0x20]
00003e  1c68              ADDS     r0,r5,#1              ;835
000040  b285              UXTH     r5,r0                 ;835
                  |L11.66|
000042  2d0f              CMP      r5,#0xf               ;835
000044  d3e8              BCC      |L11.24|
;;;844    #endif
;;;845        }
;;;846        ptmr1               = &OSTmrTbl[ix];
000046  eb050085          ADD      r0,r5,r5,LSL #2
00004a  4917              LDR      r1,|L11.168|
00004c  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;847        ptmr1->OSTmrType    = OS_TMR_TYPE;
000050  2064              MOVS     r0,#0x64
000052  7020              STRB     r0,[r4,#0]
;;;848        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
000054  2000              MOVS     r0,#0
000056  f8840025          STRB     r0,[r4,#0x25]
;;;849        ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00005a  60e0              STR      r0,[r4,#0xc]
;;;850    #if OS_TMR_CFG_NAME_EN > 0u
;;;851        ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005c  a014              ADR      r0,|L11.176|
00005e  6220              STR      r0,[r4,#0x20]
;;;852    #endif
;;;853        OSTmrTime           = 0u;
000060  2000              MOVS     r0,#0
000062  4914              LDR      r1,|L11.180|
000064  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;854        OSTmrUsed           = 0u;
000066  4914              LDR      r1,|L11.184|
000068  8008              STRH     r0,[r1,#0]
;;;855        OSTmrFree           = OS_TMR_CFG_MAX;
00006a  2010              MOVS     r0,#0x10
00006c  4913              LDR      r1,|L11.188|
00006e  8008              STRH     r0,[r1,#0]
;;;856        OSTmrFreeList       = &OSTmrTbl[0];
000070  480d              LDR      r0,|L11.168|
000072  4913              LDR      r1,|L11.192|
000074  6008              STR      r0,[r1,#0]  ; OSTmrFreeList
;;;857        OSTmrSem            = OSSemCreate(1u);
000076  2001              MOVS     r0,#1
000078  f7fffffe          BL       OSSemCreate
00007c  4911              LDR      r1,|L11.196|
00007e  6008              STR      r0,[r1,#0]  ; OSTmrSem
;;;858        OSTmrSemSignal      = OSSemCreate(0u);
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       OSSemCreate
000086  4910              LDR      r1,|L11.200|
000088  6008              STR      r0,[r1,#0]  ; OSTmrSemSignal
;;;859    
;;;860    #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
;;;861        OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
00008a  466a              MOV      r2,sp
00008c  a10f              ADR      r1,|L11.204|
00008e  480d              LDR      r0,|L11.196|
000090  6800              LDR      r0,[r0,#0]  ; OSTmrSem
000092  f7fffffe          BL       OSEventNameSet
;;;862        OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
000096  466a              MOV      r2,sp
000098  a111              ADR      r1,|L11.224|
00009a  480b              LDR      r0,|L11.200|
00009c  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
00009e  f7fffffe          BL       OSEventNameSet
;;;863    #endif
;;;864    
;;;865        OSTmr_InitTask();
0000a2  f7fffffe          BL       OSTmr_InitTask
;;;866    }
0000a6  bdf8              POP      {r3-r7,pc}
;;;867    #endif
                          ENDP

                  |L11.168|
                          DCD      OSTmrTbl
                  |L11.172|
                          DCD      OSTmrWheelTbl
                  |L11.176|
0000b0  3f00              DCB      "?",0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L11.180|
                          DCD      OSTmrTime
                  |L11.184|
                          DCD      OSTmrUsed
                  |L11.188|
                          DCD      OSTmrFree
                  |L11.192|
                          DCD      OSTmrFreeList
                  |L11.196|
                          DCD      OSTmrSem
                  |L11.200|
                          DCD      OSTmrSemSignal
                  |L11.204|
0000cc  75432f4f          DCB      "uC/OS-II TmrLock",0
0000d0  532d4949
0000d4  20546d72
0000d8  4c6f636b
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L11.224|
0000e0  75432f4f          DCB      "uC/OS-II TmrSignal",0
0000e4  532d4949
0000e8  20546d72
0000ec  5369676e
0000f0  616c00  
0000f3  00                DCB      0

                          AREA ||i.OSTmr_InitTask||, CODE, READONLY, ALIGN=2

                  OSTmr_InitTask PROC
;;;881    #if OS_TMR_EN > 0u
;;;882    static  void  OSTmr_InitTask (void)
000000  b500              PUSH     {lr}
;;;883    {
000002  b087              SUB      sp,sp,#0x1c
;;;884    #if OS_TASK_NAME_EN > 0u
;;;885        INT8U  err;
;;;886    #endif
;;;887    
;;;888    
;;;889    #if OS_TASK_CREATE_EXT_EN > 0u
;;;890        #if OS_STK_GROWTH == 1u
;;;891        (void)OSTaskCreateExt(OSTmr_Task,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L12.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fd          MOV      r0,#0xfffd
000018  231d              MOVS     r3,#0x1d
00001a  4a07              LDR      r2,|L12.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L12.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;892                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;893                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
;;;894                              OS_TASK_TMR_PRIO,
;;;895                              OS_TASK_TMR_ID,
;;;896                              &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
;;;897                              OS_TASK_TMR_STK_SIZE,
;;;898                              (void *)0,                                       /* No TCB extension                        */
;;;899                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;900        #else
;;;901        (void)OSTaskCreateExt(OSTmr_Task,
;;;902                              (void *)0,                                       /* No arguments passed to OSTmrTask()      */
;;;903                              &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
;;;904                              OS_TASK_TMR_PRIO,
;;;905                              OS_TASK_TMR_ID,
;;;906                              &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
;;;907                              OS_TASK_TMR_STK_SIZE,
;;;908                              (void *)0,                                       /* No TCB extension                        */
;;;909                              OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
;;;910        #endif
;;;911    #else
;;;912        #if OS_STK_GROWTH == 1u
;;;913        (void)OSTaskCreate(OSTmr_Task,
;;;914                           (void *)0,
;;;915                           &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
;;;916                           OS_TASK_TMR_PRIO);
;;;917        #else
;;;918        (void)OSTaskCreate(OSTmr_Task,
;;;919                           (void *)0,
;;;920                           &OSTmrTaskStk[0],
;;;921                           OS_TASK_TMR_PRIO);
;;;922        #endif
;;;923    #endif
;;;924    
;;;925    #if OS_TASK_NAME_EN > 0u
;;;926        OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L12.64|
000028  201d              MOVS     r0,#0x1d
00002a  f7fffffe          BL       OSTaskNameSet
;;;927    #endif
;;;928    }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;929    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      OSTmrTaskStk
                  |L12.56|
                          DCD      OSTmrTaskStk+0x1fc
                  |L12.60|
                          DCD      OSTmr_Task
                  |L12.64|
000040  75432f4f          DCB      "uC/OS-II Tmr",0
000044  532d4949
000048  20546d72
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OSTmr_Link||, CODE, READONLY, ALIGN=2

                  OSTmr_Link PROC
;;;949    #if OS_TMR_EN > 0u
;;;950    static  void  OSTmr_Link (OS_TMR  *ptmr,
000000  b570              PUSH     {r4-r6,lr}
;;;951                              INT8U    type)
;;;952    {
000002  460b              MOV      r3,r1
;;;953        OS_TMR       *ptmr1;
;;;954        OS_TMR_WHEEL *pspoke;
;;;955        INT16U        spoke;
;;;956    
;;;957    
;;;958        ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
000004  2503              MOVS     r5,#3
000006  f8805025          STRB     r5,[r0,#0x25]
;;;959        if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
00000a  2b01              CMP      r3,#1
00000c  d105              BNE      |L13.26|
;;;960            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00000e  4e15              LDR      r6,|L13.100|
000010  69c5              LDR      r5,[r0,#0x1c]
000012  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000014  4435              ADD      r5,r5,r6
000016  6145              STR      r5,[r0,#0x14]
000018  e00c              B        |L13.52|
                  |L13.26|
;;;961        } else {
;;;962            if (ptmr->OSTmrDly == 0u) {
00001a  6985              LDR      r5,[r0,#0x18]
00001c  b92d              CBNZ     r5,|L13.42|
;;;963                ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00001e  4e11              LDR      r6,|L13.100|
000020  69c5              LDR      r5,[r0,#0x1c]
000022  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000024  4435              ADD      r5,r5,r6
000026  6145              STR      r5,[r0,#0x14]
000028  e004              B        |L13.52|
                  |L13.42|
;;;964            } else {
;;;965                ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
00002a  4e0e              LDR      r6,|L13.100|
00002c  6985              LDR      r5,[r0,#0x18]
00002e  6836              LDR      r6,[r6,#0]  ; OSTmrTime
000030  4435              ADD      r5,r5,r6
000032  6145              STR      r5,[r0,#0x14]
                  |L13.52|
;;;966            }
;;;967        }
;;;968        spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000034  7d05              LDRB     r5,[r0,#0x14]
000036  f0050407          AND      r4,r5,#7
;;;969        pspoke = &OSTmrWheelTbl[spoke];
00003a  4d0b              LDR      r5,|L13.104|
00003c  eb0501c4          ADD      r1,r5,r4,LSL #3
;;;970    
;;;971        if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
000040  680d              LDR      r5,[r1,#0]
000042  b92d              CBNZ     r5,|L13.80|
;;;972            pspoke->OSTmrFirst   = ptmr;
000044  6008              STR      r0,[r1,#0]
;;;973            ptmr->OSTmrNext      = (OS_TMR *)0;
000046  2500              MOVS     r5,#0
000048  60c5              STR      r5,[r0,#0xc]
;;;974            pspoke->OSTmrEntries = 1u;
00004a  2501              MOVS     r5,#1
00004c  808d              STRH     r5,[r1,#4]
00004e  e006              B        |L13.94|
                  |L13.80|
;;;975        } else {
;;;976            ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
000050  680a              LDR      r2,[r1,#0]
;;;977            pspoke->OSTmrFirst   = ptmr;
000052  6008              STR      r0,[r1,#0]
;;;978            ptmr->OSTmrNext      = (void *)ptmr1;
000054  60c2              STR      r2,[r0,#0xc]
;;;979            ptmr1->OSTmrPrev     = (void *)ptmr;
000056  6110              STR      r0,[r2,#0x10]
;;;980            pspoke->OSTmrEntries++;
000058  888d              LDRH     r5,[r1,#4]
00005a  1c6d              ADDS     r5,r5,#1
00005c  808d              STRH     r5,[r1,#4]
                  |L13.94|
;;;981        }
;;;982        ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
00005e  2500              MOVS     r5,#0
000060  6105              STR      r5,[r0,#0x10]
;;;983    }
000062  bd70              POP      {r4-r6,pc}
;;;984    #endif
                          ENDP

                  |L13.100|
                          DCD      OSTmrTime
                  |L13.104|
                          DCD      OSTmrWheelTbl

                          AREA ||i.OSTmr_Task||, CODE, READONLY, ALIGN=2

                  OSTmr_Task PROC
;;;1045   #if OS_TMR_EN > 0u
;;;1046   static  void  OSTmr_Task (void *p_arg)
000000  b508              PUSH     {r3,lr}
;;;1047   {
;;;1048       INT8U            err;
;;;1049       OS_TMR          *ptmr;
;;;1050       OS_TMR          *ptmr_next;
;;;1051       OS_TMR_CALLBACK  pfnct;
;;;1052       OS_TMR_WHEEL    *pspoke;
;;;1053       INT16U           spoke;
;;;1054   
;;;1055   
;;;1056       p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
000002  bf00              NOP      
;;;1057       for (;;) {
000004  bf00              NOP      
                  |L14.6|
;;;1058           OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  481a              LDR      r0,|L14.116|
00000c  6800              LDR      r0,[r0,#0]  ; OSTmrSemSignal
00000e  f7fffffe          BL       OSSemPend
;;;1059           OSSchedLock();
000012  f7fffffe          BL       OSSchedLock
;;;1060           OSTmrTime++;                                             /* Increment the current time                        */
000016  4818              LDR      r0,|L14.120|
000018  6800              LDR      r0,[r0,#0]  ; OSTmrTime
00001a  1c40              ADDS     r0,r0,#1
00001c  4916              LDR      r1,|L14.120|
00001e  6008              STR      r0,[r1,#0]  ; OSTmrTime
;;;1061           spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
000020  4608              MOV      r0,r1
000022  7800              LDRB     r0,[r0,#0]  ; OSTmrTime
000024  f0000807          AND      r8,r0,#7
;;;1062           pspoke = &OSTmrWheelTbl[spoke];
000028  4814              LDR      r0,|L14.124|
00002a  eb0007c8          ADD      r7,r0,r8,LSL #3
;;;1063           ptmr   = pspoke->OSTmrFirst;
00002e  683c              LDR      r4,[r7,#0]
;;;1064           while (ptmr != (OS_TMR *)0) {
000030  e01a              B        |L14.104|
                  |L14.50|
;;;1065               ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
000032  68e6              LDR      r6,[r4,#0xc]
;;;1066                                                                    /* ... timer could get unlinked from the wheel.      */
;;;1067               if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
000034  4910              LDR      r1,|L14.120|
000036  6960              LDR      r0,[r4,#0x14]
000038  6809              LDR      r1,[r1,#0]  ; OSTmrTime
00003a  4288              CMP      r0,r1
00003c  d113              BNE      |L14.102|
;;;1068                   OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OSTmr_Unlink
;;;1069                   if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
000044  f8940024          LDRB     r0,[r4,#0x24]
000048  2802              CMP      r0,#2
00004a  d104              BNE      |L14.86|
;;;1070                       OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       OSTmr_Link
000054  e002              B        |L14.92|
                  |L14.86|
;;;1071                   } else {
;;;1072                       ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
000056  2002              MOVS     r0,#2
000058  f8840025          STRB     r0,[r4,#0x25]
                  |L14.92|
;;;1073                   }
;;;1074                   pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00005c  6865              LDR      r5,[r4,#4]
;;;1075                   if (pfnct != (OS_TMR_CALLBACK)0) {
00005e  b115              CBZ      r5,|L14.102|
;;;1076                       (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
000060  4620              MOV      r0,r4
000062  68a1              LDR      r1,[r4,#8]
000064  47a8              BLX      r5
                  |L14.102|
;;;1077                   }
;;;1078               }
;;;1079               ptmr = ptmr_next;
000066  4634              MOV      r4,r6
                  |L14.104|
000068  2c00              CMP      r4,#0                 ;1064
00006a  d1e2              BNE      |L14.50|
;;;1080           }
;;;1081           OSSchedUnlock();
00006c  f7fffffe          BL       OSSchedUnlock
000070  e7c9              B        |L14.6|
;;;1082       }
;;;1083   }
;;;1084   #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      OSTmrSemSignal
                  |L14.120|
                          DCD      OSTmrTime
                  |L14.124|
                          DCD      OSTmrWheelTbl

                          AREA ||i.OSTmr_Unlink||, CODE, READONLY, ALIGN=2

                  OSTmr_Unlink PROC
;;;999    #if OS_TMR_EN > 0u
;;;1000   static  void  OSTmr_Unlink (OS_TMR *ptmr)
000000  b530              PUSH     {r4,r5,lr}
;;;1001   {
;;;1002       OS_TMR        *ptmr1;
;;;1003       OS_TMR        *ptmr2;
;;;1004       OS_TMR_WHEEL  *pspoke;
;;;1005       INT16U         spoke;
;;;1006   
;;;1007   
;;;1008       spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000002  7d05              LDRB     r5,[r0,#0x14]
000004  f0050407          AND      r4,r5,#7
;;;1009       pspoke = &OSTmrWheelTbl[spoke];
000008  4d0d              LDR      r5,|L15.64|
00000a  eb0503c4          ADD      r3,r5,r4,LSL #3
;;;1010   
;;;1011       if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
00000e  681d              LDR      r5,[r3,#0]
000010  4285              CMP      r5,r0
000012  d105              BNE      |L15.32|
;;;1012           ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
000014  68c1              LDR      r1,[r0,#0xc]
;;;1013           pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
000016  6019              STR      r1,[r3,#0]
;;;1014           if (ptmr1 != (OS_TMR *)0) {
000018  b139              CBZ      r1,|L15.42|
;;;1015               ptmr1->OSTmrPrev = (void *)0;
00001a  2500              MOVS     r5,#0
00001c  610d              STR      r5,[r1,#0x10]
00001e  e004              B        |L15.42|
                  |L15.32|
;;;1016           }
;;;1017       } else {
;;;1018           ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
000020  6901              LDR      r1,[r0,#0x10]
;;;1019           ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
000022  68c2              LDR      r2,[r0,#0xc]
;;;1020           ptmr1->OSTmrNext = ptmr2;
000024  60ca              STR      r2,[r1,#0xc]
;;;1021           if (ptmr2 != (OS_TMR *)0) {
000026  b102              CBZ      r2,|L15.42|
;;;1022               ptmr2->OSTmrPrev = (void *)ptmr1;
000028  6111              STR      r1,[r2,#0x10]
                  |L15.42|
;;;1023           }
;;;1024       }
;;;1025       ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00002a  2501              MOVS     r5,#1
00002c  f8805025          STRB     r5,[r0,#0x25]
;;;1026       ptmr->OSTmrNext  = (void *)0;
000030  2500              MOVS     r5,#0
000032  60c5              STR      r5,[r0,#0xc]
;;;1027       ptmr->OSTmrPrev  = (void *)0;
000034  6105              STR      r5,[r0,#0x10]
;;;1028       pspoke->OSTmrEntries--;
000036  889d              LDRH     r5,[r3,#4]
000038  1e6d              SUBS     r5,r5,#1
00003a  809d              STRH     r5,[r3,#4]
;;;1029   }
00003c  bd30              POP      {r4,r5,pc}
;;;1030   #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      OSTmrWheelTbl
