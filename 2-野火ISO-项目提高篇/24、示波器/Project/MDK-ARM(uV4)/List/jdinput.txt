; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdinput.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdinput.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\jdinput.crf ..\..\uCGUI\JPEG\jdinput.c]
                          THUMB

                          AREA ||i.consume_markers||, CODE, READONLY, ALIGN=1

                  consume_markers PROC
;;;287    METHODDEF(int)
;;;288    consume_markers (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;289    {
000002  4604              MOV      r4,r0
;;;290      my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
000004  f8d451b4          LDR      r5,[r4,#0x1b4]
;;;291      int val;
;;;292    
;;;293      if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
000008  6968              LDR      r0,[r5,#0x14]
00000a  b108              CBZ      r0,|L1.16|
;;;294        return JPEG_REACHED_EOI;
00000c  2002              MOVS     r0,#2
                  |L1.14|
;;;295    
;;;296      val = (*cinfo->marker->read_markers) (cinfo);
;;;297    
;;;298      switch (val) {
;;;299      case JPEG_REACHED_SOS:	/* Found SOS */
;;;300        if (inputctl->inheaders) {	/* 1st SOS */
;;;301          initial_setup(cinfo);
;;;302          inputctl->inheaders = FALSE;
;;;303          /* Note: start_input_pass must be called by jdmaster.c
;;;304           * before any more input can be consumed.  jdapimin.c is
;;;305           * responsible for enforcing this sequencing.
;;;306           */
;;;307        } else {			/* 2nd or later SOS marker */
;;;308          if (! inputctl->pub.has_multiple_scans)
;;;309    	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
;;;310          start_input_pass(cinfo);
;;;311        }
;;;312        break;
;;;313      case JPEG_REACHED_EOI:	/* Found EOI */
;;;314        inputctl->pub.eoi_reached = TRUE;
;;;315        if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
;;;316          if (cinfo->marker->saw_SOF)
;;;317    	ERREXIT(cinfo, JERR_SOF_NO_SOS);
;;;318        } else {
;;;319          /* Prevent infinite loop in coef ctlr's decompress_data routine
;;;320           * if user set output_scan_number larger than number of scans.
;;;321           */
;;;322          if (cinfo->output_scan_number > cinfo->input_scan_number)
;;;323    	cinfo->output_scan_number = cinfo->input_scan_number;
;;;324        }
;;;325        break;
;;;326      case JPEG_SUSPENDED:
;;;327        break;
;;;328      }
;;;329    
;;;330      return val;
;;;331    }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f8d401b8          LDR      r0,[r4,#0x1b8]        ;296
000014  6841              LDR      r1,[r0,#4]            ;296
000016  4620              MOV      r0,r4                 ;296
000018  4788              BLX      r1                    ;296
00001a  4606              MOV      r6,r0                 ;296
00001c  b3a6              CBZ      r6,|L1.136|
00001e  2e01              CMP      r6,#1                 ;298
000020  d002              BEQ      |L1.40|
000022  2e02              CMP      r6,#2                 ;298
000024  d132              BNE      |L1.140|
000026  e014              B        |L1.82|
                  |L1.40|
000028  69a8              LDR      r0,[r5,#0x18]         ;300
00002a  b128              CBZ      r0,|L1.56|
00002c  4620              MOV      r0,r4                 ;301
00002e  f7fffffe          BL       initial_setup
000032  2000              MOVS     r0,#0                 ;302
000034  61a8              STR      r0,[r5,#0x18]         ;302
000036  e00b              B        |L1.80|
                  |L1.56|
000038  6928              LDR      r0,[r5,#0x10]         ;308
00003a  b930              CBNZ     r0,|L1.74|
00003c  2023              MOVS     r0,#0x23              ;309
00003e  6821              LDR      r1,[r4,#0]            ;309
000040  6148              STR      r0,[r1,#0x14]         ;309
000042  6820              LDR      r0,[r4,#0]            ;309
000044  6801              LDR      r1,[r0,#0]            ;309
000046  4620              MOV      r0,r4                 ;309
000048  4788              BLX      r1                    ;309
                  |L1.74|
00004a  4620              MOV      r0,r4                 ;310
00004c  f7fffffe          BL       start_input_pass
                  |L1.80|
000050  e01c              B        |L1.140|
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;314
000054  6168              STR      r0,[r5,#0x14]         ;314
000056  69a8              LDR      r0,[r5,#0x18]         ;315
000058  b158              CBZ      r0,|L1.114|
00005a  f8d401b8          LDR      r0,[r4,#0x1b8]        ;316
00005e  6900              LDR      r0,[r0,#0x10]         ;316
000060  b188              CBZ      r0,|L1.134|
000062  203b              MOVS     r0,#0x3b              ;317
000064  6821              LDR      r1,[r4,#0]            ;317
000066  6148              STR      r0,[r1,#0x14]         ;317
000068  6820              LDR      r0,[r4,#0]            ;317
00006a  6801              LDR      r1,[r0,#0]            ;317
00006c  4620              MOV      r0,r4                 ;317
00006e  4788              BLX      r1                    ;317
000070  e009              B        |L1.134|
                  |L1.114|
000072  f8d41090          LDR      r1,[r4,#0x90]         ;322
000076  f8d40098          LDR      r0,[r4,#0x98]         ;322
00007a  4288              CMP      r0,r1                 ;322
00007c  dd03              BLE      |L1.134|
00007e  f8d40090          LDR      r0,[r4,#0x90]         ;323
000082  f8c40098          STR      r0,[r4,#0x98]         ;323
                  |L1.134|
000086  e001              B        |L1.140|
                  |L1.136|
000088  e7ff              B        |L1.138|
                  |L1.138|
00008a  bf00              NOP                            ;327
                  |L1.140|
00008c  bf00              NOP                            ;312
00008e  4630              MOV      r0,r6                 ;330
000090  e7bd              B        |L1.14|
;;;332    
                          ENDP


                          AREA ||i.finish_input_pass||, CODE, READONLY, ALIGN=2

                  finish_input_pass PROC
;;;270    METHODDEF(void)
;;;271    finish_input_pass (j_decompress_ptr cinfo)
000000  4902              LDR      r1,|L2.12|
;;;272    {
;;;273      cinfo->inputctl->consume_input = consume_markers;
000002  f8d021b4          LDR      r2,[r0,#0x1b4]
000006  6011              STR      r1,[r2,#0]
;;;274    }
000008  4770              BX       lr
;;;275    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      consume_markers

                          AREA ||i.initial_setup||, CODE, READONLY, ALIGN=1

                  initial_setup PROC
;;;38     LOCAL(void)
;;;39     initial_setup (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;40     /* Called once, when first SOS marker is reached */
;;;41     {
000002  4604              MOV      r4,r0
;;;42       int ci;
;;;43       jpeg_component_info *compptr;
;;;44     
;;;45       /* Make sure image isn't bigger than I can handle */
;;;46       if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
000004  f64f71dc          MOV      r1,#0xffdc
000008  6a20              LDR      r0,[r4,#0x20]
00000a  4288              CMP      r0,r1
00000c  dc02              BGT      |L3.20|
;;;47           (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  4288              CMP      r0,r1
000012  dd0a              BLE      |L3.42|
                  |L3.20|
;;;48         ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
000014  2029              MOVS     r0,#0x29
000016  6821              LDR      r1,[r4,#0]
000018  6148              STR      r0,[r1,#0x14]
00001a  f64f70dc          MOV      r0,#0xffdc
00001e  6821              LDR      r1,[r4,#0]
000020  6188              STR      r0,[r1,#0x18]
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  4620              MOV      r0,r4
000028  4788              BLX      r1
                  |L3.42|
;;;49     
;;;50       /* For now, precision must match compiled-in value... */
;;;51       if (cinfo->data_precision != BITS_IN_JSAMPLE)
00002a  f8d400d4          LDR      r0,[r4,#0xd4]
00002e  2808              CMP      r0,#8
000030  d00a              BEQ      |L3.72|
;;;52         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
000032  200f              MOVS     r0,#0xf
000034  6821              LDR      r1,[r4,#0]
000036  6148              STR      r0,[r1,#0x14]
000038  6821              LDR      r1,[r4,#0]
00003a  f8d400d4          LDR      r0,[r4,#0xd4]
00003e  6188              STR      r0,[r1,#0x18]
000040  6820              LDR      r0,[r4,#0]
000042  6801              LDR      r1,[r0,#0]
000044  4620              MOV      r0,r4
000046  4788              BLX      r1
                  |L3.72|
;;;53     
;;;54       /* Check that number of components won't exceed internal array sizes */
;;;55       if (cinfo->num_components > MAX_COMPONENTS)
000048  6a60              LDR      r0,[r4,#0x24]
00004a  2804              CMP      r0,#4
00004c  dd0c              BLE      |L3.104|
;;;56         ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
00004e  201a              MOVS     r0,#0x1a
000050  6821              LDR      r1,[r4,#0]
000052  6148              STR      r0,[r1,#0x14]
000054  6821              LDR      r1,[r4,#0]
000056  6a60              LDR      r0,[r4,#0x24]
000058  6188              STR      r0,[r1,#0x18]
00005a  2104              MOVS     r1,#4
00005c  6820              LDR      r0,[r4,#0]
00005e  61c1              STR      r1,[r0,#0x1c]
000060  6820              LDR      r0,[r4,#0]
000062  6801              LDR      r1,[r0,#0]
000064  4620              MOV      r0,r4
000066  4788              BLX      r1
                  |L3.104|
;;;57     	     MAX_COMPONENTS);
;;;58     
;;;59       /* Compute maximum sampling factors; check factor validity */
;;;60       cinfo->max_h_samp_factor = 1;
000068  2001              MOVS     r0,#1
00006a  f10404d8          ADD      r4,r4,#0xd8
00006e  65e0              STR      r0,[r4,#0x5c]
;;;61       cinfo->max_v_samp_factor = 1;
000070  6620              STR      r0,[r4,#0x60]
;;;62       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000072  f04f0600          MOV      r6,#0
000076  f85459d8          LDR      r5,[r4],#-0xd8
00007a  e02a              B        |L3.210|
                  |L3.124|
;;;63            ci++, compptr++) {
;;;64         if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
00007c  68a8              LDR      r0,[r5,#8]
00007e  2800              CMP      r0,#0
000080  dd08              BLE      |L3.148|
000082  68a8              LDR      r0,[r5,#8]
000084  2804              CMP      r0,#4
000086  dc05              BGT      |L3.148|
;;;65     	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
000088  68e8              LDR      r0,[r5,#0xc]
00008a  2800              CMP      r0,#0
00008c  dd02              BLE      |L3.148|
00008e  68e8              LDR      r0,[r5,#0xc]
000090  2804              CMP      r0,#4
000092  dd06              BLE      |L3.162|
                  |L3.148|
;;;66           ERREXIT(cinfo, JERR_BAD_SAMPLING);
000094  2012              MOVS     r0,#0x12
000096  6821              LDR      r1,[r4,#0]
000098  6148              STR      r0,[r1,#0x14]
00009a  6820              LDR      r0,[r4,#0]
00009c  6801              LDR      r1,[r0,#0]
00009e  4620              MOV      r0,r4
0000a0  4788              BLX      r1
                  |L3.162|
;;;67         cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
0000a2  f8d40134          LDR      r0,[r4,#0x134]
0000a6  68a9              LDR      r1,[r5,#8]
0000a8  4288              CMP      r0,r1
0000aa  dd02              BLE      |L3.178|
0000ac  f8d40134          LDR      r0,[r4,#0x134]
0000b0  e000              B        |L3.180|
                  |L3.178|
0000b2  68a8              LDR      r0,[r5,#8]
                  |L3.180|
0000b4  f8c40134          STR      r0,[r4,#0x134]
;;;68     				   compptr->h_samp_factor);
;;;69         cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
0000b8  f8d40138          LDR      r0,[r4,#0x138]
0000bc  68e9              LDR      r1,[r5,#0xc]
0000be  4288              CMP      r0,r1
0000c0  dd02              BLE      |L3.200|
0000c2  f8d40138          LDR      r0,[r4,#0x138]
0000c6  e000              B        |L3.202|
                  |L3.200|
0000c8  68e8              LDR      r0,[r5,#0xc]
                  |L3.202|
0000ca  f8c40138          STR      r0,[r4,#0x138]
0000ce  1c76              ADDS     r6,r6,#1              ;63
0000d0  3554              ADDS     r5,r5,#0x54           ;63
                  |L3.210|
0000d2  6a60              LDR      r0,[r4,#0x24]         ;62
0000d4  42b0              CMP      r0,r6                 ;62
0000d6  dcd1              BGT      |L3.124|
;;;70     				   compptr->v_samp_factor);
;;;71       }
;;;72     
;;;73       /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
;;;74        * In the full decompressor, this will be overridden by jdmaster.c;
;;;75        * but in the transcoder, jdmaster.c is not used, so we must do it here.
;;;76        */
;;;77       cinfo->min_DCT_scaled_size = DCTSIZE;
0000d8  2008              MOVS     r0,#8
0000da  f8c4013c          STR      r0,[r4,#0x13c]
;;;78     
;;;79       /* Compute dimensions of components */
;;;80       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
0000de  2600              MOVS     r6,#0
0000e0  f8d450d8          LDR      r5,[r4,#0xd8]
0000e4  e02d              B        |L3.322|
                  |L3.230|
;;;81            ci++, compptr++) {
;;;82         compptr->DCT_scaled_size = DCTSIZE;
0000e6  2008              MOVS     r0,#8
0000e8  6268              STR      r0,[r5,#0x24]
;;;83         /* Size in DCT blocks */
;;;84         compptr->width_in_blocks = (JDIMENSION)
0000ea  69e2              LDR      r2,[r4,#0x1c]
0000ec  68ab              LDR      r3,[r5,#8]
0000ee  fb02f003          MUL      r0,r2,r3
0000f2  f8d42134          LDR      r2,[r4,#0x134]
0000f6  00d1              LSLS     r1,r2,#3
0000f8  f7fffffe          BL       jdiv_round_up
0000fc  61e8              STR      r0,[r5,#0x1c]
;;;85           jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
;;;86     		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;87         compptr->height_in_blocks = (JDIMENSION)
0000fe  6a22              LDR      r2,[r4,#0x20]
000100  68eb              LDR      r3,[r5,#0xc]
000102  fb02f003          MUL      r0,r2,r3
000106  f8d42138          LDR      r2,[r4,#0x138]
00010a  00d1              LSLS     r1,r2,#3
00010c  f7fffffe          BL       jdiv_round_up
000110  6228              STR      r0,[r5,#0x20]
;;;88           jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
;;;89     		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;90         /* downsampled_width and downsampled_height will also be overridden by
;;;91          * jdmaster.c if we are doing full decompression.  The transcoder library
;;;92          * doesn't use these values, but the calling application might.
;;;93          */
;;;94         /* Size in samples */
;;;95         compptr->downsampled_width = (JDIMENSION)
000112  69e2              LDR      r2,[r4,#0x1c]
000114  68ab              LDR      r3,[r5,#8]
000116  fb02f003          MUL      r0,r2,r3
00011a  f8d41134          LDR      r1,[r4,#0x134]
00011e  f7fffffe          BL       jdiv_round_up
000122  62a8              STR      r0,[r5,#0x28]
;;;96           jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
;;;97     		    (long) cinfo->max_h_samp_factor);
;;;98         compptr->downsampled_height = (JDIMENSION)
000124  6a22              LDR      r2,[r4,#0x20]
000126  68eb              LDR      r3,[r5,#0xc]
000128  fb02f003          MUL      r0,r2,r3
00012c  f8d41138          LDR      r1,[r4,#0x138]
000130  f7fffffe          BL       jdiv_round_up
000134  62e8              STR      r0,[r5,#0x2c]
;;;99           jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
;;;100    		    (long) cinfo->max_v_samp_factor);
;;;101        /* Mark component needed, until color conversion says otherwise */
;;;102        compptr->component_needed = TRUE;
000136  2001              MOVS     r0,#1
000138  6328              STR      r0,[r5,#0x30]
;;;103        /* Mark no quantization table yet saved for component */
;;;104        compptr->quant_table = NULL;
00013a  2000              MOVS     r0,#0
00013c  64e8              STR      r0,[r5,#0x4c]
00013e  1c76              ADDS     r6,r6,#1              ;81
000140  3554              ADDS     r5,r5,#0x54           ;81
                  |L3.322|
000142  6a60              LDR      r0,[r4,#0x24]         ;80
000144  42b0              CMP      r0,r6                 ;80
000146  dcce              BGT      |L3.230|
;;;105      }
;;;106    
;;;107      /* Compute number of fully interleaved MCU rows. */
;;;108      cinfo->total_iMCU_rows = (JDIMENSION)
000148  f8d42138          LDR      r2,[r4,#0x138]
00014c  00d1              LSLS     r1,r2,#3
00014e  6a20              LDR      r0,[r4,#0x20]
000150  f7fffffe          BL       jdiv_round_up
000154  f8c40140          STR      r0,[r4,#0x140]
;;;109        jdiv_round_up((long) cinfo->image_height,
;;;110    		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
;;;111    
;;;112      /* Decide whether file contains multiple scans */
;;;113      if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
000158  6a61              LDR      r1,[r4,#0x24]
00015a  f8d40148          LDR      r0,[r4,#0x148]
00015e  4288              CMP      r0,r1
000160  db02              BLT      |L3.360|
000162  f8d400dc          LDR      r0,[r4,#0xdc]
000166  b120              CBZ      r0,|L3.370|
                  |L3.360|
;;;114        cinfo->inputctl->has_multiple_scans = TRUE;
000168  2001              MOVS     r0,#1
00016a  f8d411b4          LDR      r1,[r4,#0x1b4]
00016e  6108              STR      r0,[r1,#0x10]
000170  e003              B        |L3.378|
                  |L3.370|
;;;115      else
;;;116        cinfo->inputctl->has_multiple_scans = FALSE;
000172  2000              MOVS     r0,#0
000174  f8d411b4          LDR      r1,[r4,#0x1b4]
000178  6108              STR      r0,[r1,#0x10]
                  |L3.378|
;;;117    }
00017a  bd70              POP      {r4-r6,pc}
;;;118    
                          ENDP


                          AREA ||i.jinit_input_controller||, CODE, READONLY, ALIGN=2

                  jinit_input_controller PROC
;;;360    GLOBAL(void)
;;;361    jinit_input_controller (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;362    {
000002  4605              MOV      r5,r0
;;;363      my_inputctl_ptr inputctl;
;;;364    
;;;365      /* Create subobject in permanent pool */
;;;366      inputctl = (my_inputctl_ptr)
000004  6868              LDR      r0,[r5,#4]
000006  221c              MOVS     r2,#0x1c
000008  2100              MOVS     r1,#0
00000a  6803              LDR      r3,[r0,#0]
00000c  4628              MOV      r0,r5
00000e  4798              BLX      r3
000010  4604              MOV      r4,r0
;;;367        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
;;;368    				SIZEOF(my_input_controller));
;;;369      cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
000012  f8c541b4          STR      r4,[r5,#0x1b4]
;;;370      /* Initialize method pointers */
;;;371      inputctl->pub.consume_input = consume_markers;
000016  4807              LDR      r0,|L4.52|
000018  6020              STR      r0,[r4,#0]
;;;372      inputctl->pub.reset_input_controller = reset_input_controller;
00001a  4807              LDR      r0,|L4.56|
00001c  6060              STR      r0,[r4,#4]
;;;373      inputctl->pub.start_input_pass = start_input_pass;
00001e  4807              LDR      r0,|L4.60|
000020  60a0              STR      r0,[r4,#8]
;;;374      inputctl->pub.finish_input_pass = finish_input_pass;
000022  4807              LDR      r0,|L4.64|
000024  60e0              STR      r0,[r4,#0xc]
;;;375      /* Initialize state: can't use reset_input_controller since we don't
;;;376       * want to try to reset other modules yet.
;;;377       */
;;;378      inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
000026  2000              MOVS     r0,#0
000028  6120              STR      r0,[r4,#0x10]
;;;379      inputctl->pub.eoi_reached = FALSE;
00002a  6160              STR      r0,[r4,#0x14]
;;;380      inputctl->inheaders = TRUE;
00002c  2001              MOVS     r0,#1
00002e  61a0              STR      r0,[r4,#0x18]
;;;381    }
000030  bd70              POP      {r4-r6,pc}
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      consume_markers
                  |L4.56|
                          DCD      reset_input_controller
                  |L4.60|
                          DCD      start_input_pass
                  |L4.64|
                          DCD      finish_input_pass

                          AREA ||i.latch_quant_tables||, CODE, READONLY, ALIGN=1

                  latch_quant_tables PROC
;;;219    LOCAL(void)
;;;220    latch_quant_tables (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;221    {
000004  4604              MOV      r4,r0
;;;222      int ci, qtblno;
;;;223      jpeg_component_info *compptr;
;;;224      JQUANT_TBL * qtbl;
;;;225    
;;;226      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000006  2700              MOVS     r7,#0
000008  e02c              B        |L5.100|
                  |L5.10|
;;;227        compptr = cinfo->cur_comp_info[ci];
00000a  f50470a6          ADD      r0,r4,#0x14c
00000e  f8506027          LDR      r6,[r0,r7,LSL #2]
;;;228        /* No work if we already saved Q-table for this component */
;;;229        if (compptr->quant_table != NULL)
000012  6cf0              LDR      r0,[r6,#0x4c]
000014  b100              CBZ      r0,|L5.24|
;;;230          continue;
000016  e024              B        |L5.98|
                  |L5.24|
;;;231        /* Make sure specified quantization table is present */
;;;232        qtblno = compptr->quant_tbl_no;
000018  6935              LDR      r5,[r6,#0x10]
;;;233        if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
00001a  2d00              CMP      r5,#0
00001c  db06              BLT      |L5.44|
00001e  2d04              CMP      r5,#4
000020  da04              BGE      |L5.44|
;;;234    	cinfo->quant_tbl_ptrs[qtblno] == NULL)
000022  f10400a4          ADD      r0,r4,#0xa4
000026  f8500025          LDR      r0,[r0,r5,LSL #2]
00002a  b940              CBNZ     r0,|L5.62|
                  |L5.44|
;;;235          ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
00002c  2034              MOVS     r0,#0x34
00002e  6821              LDR      r1,[r4,#0]
000030  6148              STR      r0,[r1,#0x14]
000032  6820              LDR      r0,[r4,#0]
000034  6185              STR      r5,[r0,#0x18]
000036  6820              LDR      r0,[r4,#0]
000038  6801              LDR      r1,[r0,#0]
00003a  4620              MOV      r0,r4
00003c  4788              BLX      r1
                  |L5.62|
;;;236        /* OK, save away the quantization table */
;;;237        qtbl = (JQUANT_TBL *)
00003e  6860              LDR      r0,[r4,#4]
000040  2284              MOVS     r2,#0x84
000042  2101              MOVS     r1,#1
000044  6803              LDR      r3,[r0,#0]
000046  4620              MOV      r0,r4
000048  4798              BLX      r3
00004a  4680              MOV      r8,r0
;;;238          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;239    				  SIZEOF(JQUANT_TBL));
;;;240        MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
00004c  f10400a4          ADD      r0,r4,#0xa4
000050  f8501025          LDR      r1,[r0,r5,LSL #2]
000054  2284              MOVS     r2,#0x84
000056  4640              MOV      r0,r8
000058  f7fffffe          BL       __aeabi_memcpy4
;;;241        compptr->quant_table = qtbl;
00005c  f8c6804c          STR      r8,[r6,#0x4c]
000060  bf00              NOP                            ;230
                  |L5.98|
000062  1c7f              ADDS     r7,r7,#1              ;226
                  |L5.100|
000064  f8d40148          LDR      r0,[r4,#0x148]        ;226
000068  42b8              CMP      r0,r7                 ;226
00006a  dcce              BGT      |L5.10|
;;;242      }
;;;243    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;244    
                          ENDP


                          AREA ||i.per_scan_setup||, CODE, READONLY, ALIGN=1

                  per_scan_setup PROC
;;;120    LOCAL(void)
;;;121    per_scan_setup (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;122    /* Do computations that are needed before processing a JPEG scan */
;;;123    /* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
;;;124    {
000004  4605              MOV      r5,r0
;;;125      int ci, mcublks, tmp;
;;;126      jpeg_component_info *compptr;
;;;127      
;;;128      if (cinfo->comps_in_scan == 1) {
000006  f8d50148          LDR      r0,[r5,#0x148]
00000a  2801              CMP      r0,#1
00000c  d11f              BNE      |L6.78|
;;;129        
;;;130        /* Noninterleaved (single-component) scan */
;;;131        compptr = cinfo->cur_comp_info[0];
00000e  f8d5414c          LDR      r4,[r5,#0x14c]
;;;132        
;;;133        /* Overall image size in MCUs */
;;;134        cinfo->MCUs_per_row = compptr->width_in_blocks;
000012  69e0              LDR      r0,[r4,#0x1c]
000014  f8c5015c          STR      r0,[r5,#0x15c]
;;;135        cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
000018  6a20              LDR      r0,[r4,#0x20]
00001a  f8c50160          STR      r0,[r5,#0x160]
;;;136        
;;;137        /* For noninterleaved scan, always one block per MCU */
;;;138        compptr->MCU_width = 1;
00001e  2001              MOVS     r0,#1
000020  6360              STR      r0,[r4,#0x34]
;;;139        compptr->MCU_height = 1;
000022  63a0              STR      r0,[r4,#0x38]
;;;140        compptr->MCU_blocks = 1;
000024  63e0              STR      r0,[r4,#0x3c]
;;;141        compptr->MCU_sample_width = compptr->DCT_scaled_size;
000026  6a60              LDR      r0,[r4,#0x24]
000028  6420              STR      r0,[r4,#0x40]
;;;142        compptr->last_col_width = 1;
00002a  2001              MOVS     r0,#1
00002c  6460              STR      r0,[r4,#0x44]
;;;143        /* For noninterleaved scans, it is convenient to define last_row_height
;;;144         * as the number of block rows present in the last iMCU row.
;;;145         */
;;;146        tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
00002e  68e1              LDR      r1,[r4,#0xc]
000030  6a20              LDR      r0,[r4,#0x20]
000032  fbb0f2f1          UDIV     r2,r0,r1
000036  fb010612          MLS      r6,r1,r2,r0
;;;147        if (tmp == 0) tmp = compptr->v_samp_factor;
00003a  b906              CBNZ     r6,|L6.62|
00003c  68e6              LDR      r6,[r4,#0xc]
                  |L6.62|
;;;148        compptr->last_row_height = tmp;
00003e  64a6              STR      r6,[r4,#0x48]
;;;149        
;;;150        /* Prepare array describing MCU composition */
;;;151        cinfo->blocks_in_MCU = 1;
000040  2001              MOVS     r0,#1
000042  f8c50164          STR      r0,[r5,#0x164]
;;;152        cinfo->MCU_membership[0] = 0;
000046  2000              MOVS     r0,#0
000048  f8c50168          STR      r0,[r5,#0x168]
00004c  e070              B        |L6.304|
                  |L6.78|
;;;153        
;;;154      } else {
;;;155        
;;;156        /* Interleaved (multi-component) scan */
;;;157        if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
00004e  f8d50148          LDR      r0,[r5,#0x148]
000052  2800              CMP      r0,#0
000054  dd03              BLE      |L6.94|
000056  f8d50148          LDR      r0,[r5,#0x148]
00005a  2804              CMP      r0,#4
00005c  dd0d              BLE      |L6.122|
                  |L6.94|
;;;158          ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
00005e  201a              MOVS     r0,#0x1a
000060  6829              LDR      r1,[r5,#0]
000062  6148              STR      r0,[r1,#0x14]
000064  6829              LDR      r1,[r5,#0]
000066  f8d50148          LDR      r0,[r5,#0x148]
00006a  6188              STR      r0,[r1,#0x18]
00006c  2104              MOVS     r1,#4
00006e  6828              LDR      r0,[r5,#0]
000070  61c1              STR      r1,[r0,#0x1c]
000072  6828              LDR      r0,[r5,#0]
000074  6801              LDR      r1,[r0,#0]
000076  4628              MOV      r0,r5
000078  4788              BLX      r1
                  |L6.122|
;;;159    	       MAX_COMPS_IN_SCAN);
;;;160        
;;;161        /* Overall image size in MCUs */
;;;162        cinfo->MCUs_per_row = (JDIMENSION)
00007a  f10505e8          ADD      r5,r5,#0xe8
00007e  6cea              LDR      r2,[r5,#0x4c]
000080  ea4f01c2          LSL      r1,r2,#3
000084  f8550ccc          LDR      r0,[r5,#-0xcc]
000088  f7fffffe          BL       jdiv_round_up
00008c  6768              STR      r0,[r5,#0x74]
;;;163          jdiv_round_up((long) cinfo->image_width,
;;;164    		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
;;;165        cinfo->MCU_rows_in_scan = (JDIMENSION)
00008e  6d2a              LDR      r2,[r5,#0x50]
000090  00d1              LSLS     r1,r2,#3
000092  f8550cc8          LDR      r0,[r5,#-0xc8]
000096  f7fffffe          BL       jdiv_round_up
00009a  67a8              STR      r0,[r5,#0x78]
;;;166          jdiv_round_up((long) cinfo->image_height,
;;;167    		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
;;;168        
;;;169        cinfo->blocks_in_MCU = 0;
00009c  2000              MOVS     r0,#0
00009e  67e8              STR      r0,[r5,#0x7c]
0000a0  f1a505e8          SUB      r5,r5,#0xe8
;;;170        
;;;171        for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
0000a4  4607              MOV      r7,r0
0000a6  e03f              B        |L6.296|
                  |L6.168|
;;;172          compptr = cinfo->cur_comp_info[ci];
0000a8  f50570a6          ADD      r0,r5,#0x14c
0000ac  f8504027          LDR      r4,[r0,r7,LSL #2]
;;;173          /* Sampling factors give # of blocks of component in each MCU */
;;;174          compptr->MCU_width = compptr->h_samp_factor;
0000b0  68a0              LDR      r0,[r4,#8]
0000b2  6360              STR      r0,[r4,#0x34]
;;;175          compptr->MCU_height = compptr->v_samp_factor;
0000b4  68e0              LDR      r0,[r4,#0xc]
0000b6  63a0              STR      r0,[r4,#0x38]
;;;176          compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
0000b8  e9d4010d          LDRD     r0,r1,[r4,#0x34]
0000bc  4348              MULS     r0,r1,r0
0000be  63e0              STR      r0,[r4,#0x3c]
;;;177          compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
0000c0  6a61              LDR      r1,[r4,#0x24]
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  4348              MULS     r0,r1,r0
0000c6  6420              STR      r0,[r4,#0x40]
;;;178          /* Figure number of non-dummy blocks in last MCU column & row */
;;;179          tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
0000c8  6b61              LDR      r1,[r4,#0x34]
0000ca  69e0              LDR      r0,[r4,#0x1c]
0000cc  fbb0f2f1          UDIV     r2,r0,r1
0000d0  fb010612          MLS      r6,r1,r2,r0
;;;180          if (tmp == 0) tmp = compptr->MCU_width;
0000d4  b906              CBNZ     r6,|L6.216|
0000d6  6b66              LDR      r6,[r4,#0x34]
                  |L6.216|
;;;181          compptr->last_col_width = tmp;
0000d8  6466              STR      r6,[r4,#0x44]
;;;182          tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
0000da  6ba1              LDR      r1,[r4,#0x38]
0000dc  6a20              LDR      r0,[r4,#0x20]
0000de  fbb0f2f1          UDIV     r2,r0,r1
0000e2  fb010612          MLS      r6,r1,r2,r0
;;;183          if (tmp == 0) tmp = compptr->MCU_height;
0000e6  b906              CBNZ     r6,|L6.234|
0000e8  6ba6              LDR      r6,[r4,#0x38]
                  |L6.234|
;;;184          compptr->last_row_height = tmp;
0000ea  64a6              STR      r6,[r4,#0x48]
;;;185          /* Prepare array describing MCU composition */
;;;186          mcublks = compptr->MCU_blocks;
0000ec  f8d4803c          LDR      r8,[r4,#0x3c]
;;;187          if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
0000f0  f8d50164          LDR      r0,[r5,#0x164]
0000f4  4440              ADD      r0,r0,r8
0000f6  280a              CMP      r0,#0xa
0000f8  dd06              BLE      |L6.264|
;;;188    	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
0000fa  200d              MOVS     r0,#0xd
0000fc  6829              LDR      r1,[r5,#0]
0000fe  6148              STR      r0,[r1,#0x14]
000100  6828              LDR      r0,[r5,#0]
000102  6801              LDR      r1,[r0,#0]
000104  4628              MOV      r0,r5
000106  4788              BLX      r1
                  |L6.264|
;;;189          while (mcublks-- > 0) {
000108  e008              B        |L6.284|
                  |L6.266|
;;;190    	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
00010a  f8d51164          LDR      r1,[r5,#0x164]
00010e  1c48              ADDS     r0,r1,#1
000110  f8c50164          STR      r0,[r5,#0x164]
000114  f50570b4          ADD      r0,r5,#0x168
000118  f8407021          STR      r7,[r0,r1,LSL #2]
                  |L6.284|
00011c  f1b80000          SUBS     r0,r8,#0              ;189
000120  f1a80801          SUB      r8,r8,#1              ;189
000124  dcf1              BGT      |L6.266|
000126  1c7f              ADDS     r7,r7,#1              ;171
                  |L6.296|
000128  f8d50148          LDR      r0,[r5,#0x148]        ;171
00012c  42b8              CMP      r0,r7                 ;171
00012e  dcbb              BGT      |L6.168|
                  |L6.304|
;;;191          }
;;;192        }
;;;193        
;;;194      }
;;;195    }
000130  e8bd81f0          POP      {r4-r8,pc}
;;;196    
                          ENDP


                          AREA ||i.reset_input_controller||, CODE, READONLY, ALIGN=2

                  reset_input_controller PROC
;;;338    METHODDEF(void)
;;;339    reset_input_controller (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;340    {
000002  4604              MOV      r4,r0
;;;341      my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
000004  f8d451b4          LDR      r5,[r4,#0x1b4]
;;;342    
;;;343      inputctl->pub.consume_input = consume_markers;
000008  4809              LDR      r0,|L7.48|
00000a  6028              STR      r0,[r5,#0]
;;;344      inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
00000c  2000              MOVS     r0,#0
00000e  6128              STR      r0,[r5,#0x10]
;;;345      inputctl->pub.eoi_reached = FALSE;
000010  6168              STR      r0,[r5,#0x14]
;;;346      inputctl->inheaders = TRUE;
000012  2001              MOVS     r0,#1
000014  61a8              STR      r0,[r5,#0x18]
;;;347      /* Reset other modules */
;;;348      (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
000016  6820              LDR      r0,[r4,#0]
000018  6901              LDR      r1,[r0,#0x10]
00001a  4620              MOV      r0,r4
00001c  4788              BLX      r1
;;;349      (*cinfo->marker->reset_marker_reader) (cinfo);
00001e  f8d401b8          LDR      r0,[r4,#0x1b8]
000022  6801              LDR      r1,[r0,#0]
000024  4620              MOV      r0,r4
000026  4788              BLX      r1
;;;350      /* Reset progression state -- would be cleaner if entropy decoder did this */
;;;351      cinfo->coef_bits = NULL;
000028  2000              MOVS     r0,#0
00002a  f8c400a0          STR      r0,[r4,#0xa0]
;;;352    }
00002e  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

                  |L7.48|
                          DCD      consume_markers

                          AREA ||i.start_input_pass||, CODE, READONLY, ALIGN=1

                  start_input_pass PROC
;;;253    METHODDEF(void)
;;;254    start_input_pass (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;255    {
000002  4604              MOV      r4,r0
;;;256      per_scan_setup(cinfo);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       per_scan_setup
;;;257      latch_quant_tables(cinfo);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       latch_quant_tables
;;;258      (*cinfo->entropy->start_pass) (cinfo);
000010  f8d401bc          LDR      r0,[r4,#0x1bc]
000014  6801              LDR      r1,[r0,#0]
000016  4620              MOV      r0,r4
000018  4788              BLX      r1
;;;259      (*cinfo->coef->start_input_pass) (cinfo);
00001a  f8d401ac          LDR      r0,[r4,#0x1ac]
00001e  6801              LDR      r1,[r0,#0]
000020  4620              MOV      r0,r4
000022  4788              BLX      r1
;;;260      cinfo->inputctl->consume_input = cinfo->coef->consume_data;
000024  f8d401ac          LDR      r0,[r4,#0x1ac]
000028  6840              LDR      r0,[r0,#4]
00002a  f8d411b4          LDR      r1,[r4,#0x1b4]
00002e  6008              STR      r0,[r1,#0]
;;;261    }
000030  bd10              POP      {r4,pc}
;;;262    
                          ENDP

