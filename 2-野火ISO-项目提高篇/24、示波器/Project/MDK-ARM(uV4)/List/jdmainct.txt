; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdmainct.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdmainct.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\jdmainct.crf ..\..\uCGUI\JPEG\jdmainct.c]
                          THUMB

                          AREA ||i.alloc_funny_pointers||, CODE, READONLY, ALIGN=1

                  alloc_funny_pointers PROC
;;;156    LOCAL(void)
;;;157    alloc_funny_pointers (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;158    /* Allocate space for the funny pointer lists.
;;;159     * This is done only once, not once per pass.
;;;160     */
;;;161    {
000004  4604              MOV      r4,r0
;;;162      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000006  f8d451a8          LDR      r5,[r4,#0x1a8]
;;;163      int ci, rgroup;
;;;164      int M = cinfo->min_DCT_scaled_size;
00000a  f8d4a13c          LDR      r10,[r4,#0x13c]
;;;165      jpeg_component_info *compptr;
;;;166      JSAMPARRAY xbuf;
;;;167    
;;;168      /* Get top-level space for component array pointers.
;;;169       * We alloc both arrays with one call to save a few cycles.
;;;170       */
;;;171      pMain->xbuffer[0] = (JSAMPIMAGE)
00000e  6a60              LDR      r0,[r4,#0x24]
000010  00c2              LSLS     r2,r0,#3
000012  6860              LDR      r0,[r4,#4]
000014  2101              MOVS     r1,#1
000016  6803              LDR      r3,[r0,#0]
000018  4620              MOV      r0,r4
00001a  4798              BLX      r3
00001c  6228              STR      r0,[r5,#0x20]
;;;172        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;173    				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
;;;174      pMain->xbuffer[1] = pMain->xbuffer[0] + cinfo->num_components;
00001e  6a28              LDR      r0,[r5,#0x20]
000020  6a61              LDR      r1,[r4,#0x24]
000022  eb000181          ADD      r1,r0,r1,LSL #2
000026  6269              STR      r1,[r5,#0x24]
;;;175    
;;;176      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000028  2600              MOVS     r6,#0
00002a  f8d490d8          LDR      r9,[r4,#0xd8]
00002e  e022              B        |L1.118|
                  |L1.48|
;;;177           ci++, compptr++) {
;;;178        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000030  f8d91024          LDR      r1,[r9,#0x24]
000034  f8d9000c          LDR      r0,[r9,#0xc]
000038  4348              MULS     r0,r1,r0
00003a  f8d4113c          LDR      r1,[r4,#0x13c]
00003e  fb90f7f1          SDIV     r7,r0,r1
;;;179          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;180        /* Get space for pointer lists --- M+4 row groups in each list.
;;;181         * We alloc both pointer lists with one call to save a few cycles.
;;;182         */
;;;183        xbuf = (JSAMPARRAY)
000042  f10a0004          ADD      r0,r10,#4
000046  4378              MULS     r0,r7,r0
000048  00c2              LSLS     r2,r0,#3
00004a  6860              LDR      r0,[r4,#4]
00004c  2101              MOVS     r1,#1
00004e  6803              LDR      r3,[r0,#0]
000050  4620              MOV      r0,r4
000052  4798              BLX      r3
000054  4680              MOV      r8,r0
;;;184          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;185    				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
;;;186        xbuf += rgroup;		/* want one row group at negative offsets */
000056  eb080887          ADD      r8,r8,r7,LSL #2
;;;187        pMain->xbuffer[0][ci] = xbuf;
00005a  6a28              LDR      r0,[r5,#0x20]
00005c  f8408026          STR      r8,[r0,r6,LSL #2]
;;;188        xbuf += rgroup * (M + 4);
000060  f10a0004          ADD      r0,r10,#4
000064  4378              MULS     r0,r7,r0
000066  eb080880          ADD      r8,r8,r0,LSL #2
;;;189        pMain->xbuffer[1][ci] = xbuf;
00006a  6a68              LDR      r0,[r5,#0x24]
00006c  f8408026          STR      r8,[r0,r6,LSL #2]
000070  1c76              ADDS     r6,r6,#1              ;177
000072  f1090954          ADD      r9,r9,#0x54           ;177
                  |L1.118|
000076  6a60              LDR      r0,[r4,#0x24]         ;176
000078  42b0              CMP      r0,r6                 ;176
00007a  dcd9              BGT      |L1.48|
;;;190      }
;;;191    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;192    
                          ENDP


                          AREA ||i.jinit_d_main_controller||, CODE, READONLY, ALIGN=2

                  jinit_d_main_controller PROC
;;;475    GLOBAL(void)
;;;476    jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;477    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;478      my_main_ptr pMain;
;;;479      int ci, rgroup, ngroups;
;;;480      jpeg_component_info *compptr;
;;;481    
;;;482      pMain = (my_main_ptr)
000008  6860              LDR      r0,[r4,#4]
00000a  2238              MOVS     r2,#0x38
00000c  2101              MOVS     r1,#1
00000e  6803              LDR      r3,[r0,#0]
000010  4620              MOV      r0,r4
000012  4798              BLX      r3
000014  4607              MOV      r7,r0
;;;483        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;484    				SIZEOF(my_main_controller));
;;;485      cinfo->main = (struct jpeg_d_main_controller *) pMain;
000016  f8c471a8          STR      r7,[r4,#0x1a8]
;;;486      pMain->pub.start_pass = start_pass_main;
00001a  4823              LDR      r0,|L2.168|
00001c  6038              STR      r0,[r7,#0]
;;;487    
;;;488      if (need_full_buffer)		/* shouldn't happen */
00001e  f1b90f00          CMP      r9,#0
000022  d006              BEQ      |L2.50|
;;;489        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000024  2004              MOVS     r0,#4
000026  6821              LDR      r1,[r4,#0]
000028  6148              STR      r0,[r1,#0x14]
00002a  6820              LDR      r0,[r4,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  4620              MOV      r0,r4
000030  4788              BLX      r1
                  |L2.50|
;;;490    
;;;491      /* Allocate the workspace.
;;;492       * ngroups is the number of row groups we need.
;;;493       */
;;;494      if (cinfo->upsample->need_context_rows) {
000032  f8d401c4          LDR      r0,[r4,#0x1c4]
000036  6880              LDR      r0,[r0,#8]
000038  b190              CBZ      r0,|L2.96|
;;;495        if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
00003a  f8d4013c          LDR      r0,[r4,#0x13c]
00003e  2802              CMP      r0,#2
000040  da06              BGE      |L2.80|
;;;496          ERREXIT(cinfo, JERR_NOTIMPL);
000042  202f              MOVS     r0,#0x2f
000044  6821              LDR      r1,[r4,#0]
000046  6148              STR      r0,[r1,#0x14]
000048  6820              LDR      r0,[r4,#0]
00004a  6801              LDR      r1,[r0,#0]
00004c  4620              MOV      r0,r4
00004e  4788              BLX      r1
                  |L2.80|
;;;497        alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       alloc_funny_pointers
;;;498        ngroups = cinfo->min_DCT_scaled_size + 2;
000056  f8d4013c          LDR      r0,[r4,#0x13c]
00005a  f1000802          ADD      r8,r0,#2
00005e  e001              B        |L2.100|
                  |L2.96|
;;;499      } else {
;;;500        ngroups = cinfo->min_DCT_scaled_size;
000060  f8d4813c          LDR      r8,[r4,#0x13c]
                  |L2.100|
;;;501      }
;;;502    
;;;503      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000064  2600              MOVS     r6,#0
000066  f8d450d8          LDR      r5,[r4,#0xd8]
00006a  e018              B        |L2.158|
                  |L2.108|
;;;504           ci++, compptr++) {
;;;505        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
00006c  6a69              LDR      r1,[r5,#0x24]
00006e  68e8              LDR      r0,[r5,#0xc]
000070  4348              MULS     r0,r1,r0
000072  f8d4113c          LDR      r1,[r4,#0x13c]
000076  fb90faf1          SDIV     r10,r0,r1
;;;506          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;507        pMain->buffer[ci] = (*cinfo->mem->alloc_sarray)
00007a  6a69              LDR      r1,[r5,#0x24]
00007c  69e8              LDR      r0,[r5,#0x1c]
00007e  fb00f201          MUL      r2,r0,r1
000082  fb0af308          MUL      r3,r10,r8
000086  6860              LDR      r0,[r4,#4]
000088  2101              MOVS     r1,#1
00008a  f8d0c008          LDR      r12,[r0,#8]
00008e  4620              MOV      r0,r4
000090  47e0              BLX      r12
000092  f1070108          ADD      r1,r7,#8
000096  f8410026          STR      r0,[r1,r6,LSL #2]
00009a  1c76              ADDS     r6,r6,#1              ;504
00009c  3554              ADDS     r5,r5,#0x54           ;504
                  |L2.158|
00009e  6a60              LDR      r0,[r4,#0x24]         ;503
0000a0  42b0              CMP      r0,r6                 ;503
0000a2  dce3              BGT      |L2.108|
;;;508    			((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;509    			 compptr->width_in_blocks * compptr->DCT_scaled_size,
;;;510    			 (JDIMENSION) (rgroup * ngroups));
;;;511      }
;;;512    }
0000a4  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  |L2.168|
                          DCD      start_pass_main

                          AREA ||i.make_funny_pointers||, CODE, READONLY, ALIGN=1

                  make_funny_pointers PROC
;;;194    LOCAL(void)
;;;195    make_funny_pointers (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;196    /* Create the funny pointer lists discussed in the comments above.
;;;197     * The actual workspace is already allocated (in pMain->buffer),
;;;198     * and the space for the pointer lists is allocated too.
;;;199     * This routine just fills in the curiously ordered lists.
;;;200     * This will be repeated at the beginning of each pass.
;;;201     */
;;;202    {
000004  4602              MOV      r2,r0
;;;203      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000006  f8d2c1a8          LDR      r12,[r2,#0x1a8]
;;;204      int ci, i, rgroup;
;;;205      int M = cinfo->min_DCT_scaled_size;
00000a  f8d2413c          LDR      r4,[r2,#0x13c]
;;;206      jpeg_component_info *compptr;
;;;207      JSAMPARRAY buf, xbuf0, xbuf1;
;;;208    
;;;209      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00000e  2300              MOVS     r3,#0
000010  f8d280d8          LDR      r8,[r2,#0xd8]
000014  e04c              B        |L3.176|
                  |L3.22|
;;;210           ci++, compptr++) {
;;;211        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000016  f8d8a024          LDR      r10,[r8,#0x24]
00001a  f8d8900c          LDR      r9,[r8,#0xc]
00001e  fb09f90a          MUL      r9,r9,r10
000022  f8d2a13c          LDR      r10,[r2,#0x13c]
000026  fb99f1fa          SDIV     r1,r9,r10
;;;212          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;213        xbuf0 = pMain->xbuffer[0][ci];
00002a  f8dc9020          LDR      r9,[r12,#0x20]
00002e  f8596023          LDR      r6,[r9,r3,LSL #2]
;;;214        xbuf1 = pMain->xbuffer[1][ci];
000032  f8dc9024          LDR      r9,[r12,#0x24]
000036  f8597023          LDR      r7,[r9,r3,LSL #2]
;;;215        /* First copy the workspace pointers as-is */
;;;216        buf = pMain->buffer[ci];
00003a  f10c0908          ADD      r9,r12,#8
00003e  f8595023          LDR      r5,[r9,r3,LSL #2]
;;;217        for (i = 0; i < rgroup * (M + 2); i++) {
000042  2000              MOVS     r0,#0
000044  e006              B        |L3.84|
                  |L3.70|
;;;218          xbuf0[i] = xbuf1[i] = buf[i];
000046  f8559020          LDR      r9,[r5,r0,LSL #2]
00004a  f8479020          STR      r9,[r7,r0,LSL #2]
00004e  f8469020          STR      r9,[r6,r0,LSL #2]
000052  1c40              ADDS     r0,r0,#1              ;217
                  |L3.84|
000054  f1040902          ADD      r9,r4,#2              ;217
000058  fb01f909          MUL      r9,r1,r9              ;217
00005c  4581              CMP      r9,r0                 ;217
00005e  dcf2              BGT      |L3.70|
;;;219        }
;;;220        /* In the second list, put the last four row groups in swapped order */
;;;221        for (i = 0; i < rgroup * 2; i++) {
000060  2000              MOVS     r0,#0
000062  e014              B        |L3.142|
                  |L3.100|
;;;222          xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
000064  fb010904          MLA      r9,r1,r4,r0
000068  f855a029          LDR      r10,[r5,r9,LSL #2]
00006c  f1a40902          SUB      r9,r4,#2
000070  fb010909          MLA      r9,r1,r9,r0
000074  f847a029          STR      r10,[r7,r9,LSL #2]
;;;223          xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
000078  f1a40902          SUB      r9,r4,#2
00007c  fb010909          MLA      r9,r1,r9,r0
000080  f8559029          LDR      r9,[r5,r9,LSL #2]
000084  fb010a04          MLA      r10,r1,r4,r0
000088  f847902a          STR      r9,[r7,r10,LSL #2]
00008c  1c40              ADDS     r0,r0,#1              ;221
                  |L3.142|
00008e  ebb00f41          CMP      r0,r1,LSL #1          ;221
000092  dbe7              BLT      |L3.100|
;;;224        }
;;;225        /* The wraparound pointers at top and bottom will be filled later
;;;226         * (see set_wraparound_pointers, below).  Initially we want the "above"
;;;227         * pointers to duplicate the first actual data line.  This only needs
;;;228         * to happen in xbuffer[0].
;;;229         */
;;;230        for (i = 0; i < rgroup; i++) {
000094  2000              MOVS     r0,#0
000096  e006              B        |L3.166|
                  |L3.152|
;;;231          xbuf0[i - rgroup] = xbuf0[0];
000098  eba00a01          SUB      r10,r0,r1
00009c  f8d69000          LDR      r9,[r6,#0]
0000a0  f846902a          STR      r9,[r6,r10,LSL #2]
0000a4  1c40              ADDS     r0,r0,#1              ;230
                  |L3.166|
0000a6  4288              CMP      r0,r1                 ;230
0000a8  dbf6              BLT      |L3.152|
0000aa  1c5b              ADDS     r3,r3,#1              ;210
0000ac  f1080854          ADD      r8,r8,#0x54           ;210
                  |L3.176|
0000b0  f8d29024          LDR      r9,[r2,#0x24]         ;209
0000b4  4599              CMP      r9,r3                 ;209
0000b6  dcae              BGT      |L3.22|
;;;232        }
;;;233      }
;;;234    }
0000b8  e8bd87f0          POP      {r4-r10,pc}
;;;235    
                          ENDP


                          AREA ||i.process_data_context_main||, CODE, READONLY, ALIGN=1

                  process_data_context_main PROC
;;;384    METHODDEF(void)
;;;385    process_data_context_main (j_decompress_ptr cinfo,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;386    			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;387    			   JDIMENSION out_rows_avail)
;;;388    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;389      my_main_ptr pMain = (my_main_ptr) cinfo->main;
00000c  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;390    
;;;391      /* Read input data if we haven't filled the main buffer yet */
;;;392      if (! pMain->buffer_full) {
000010  69a0              LDR      r0,[r4,#0x18]
000012  b988              CBNZ     r0,|L4.56|
;;;393        if (! (*cinfo->coef->decompress_data) (cinfo,
000014  f1040020          ADD      r0,r4,#0x20
000018  6aa3              LDR      r3,[r4,#0x28]
00001a  f8501023          LDR      r1,[r0,r3,LSL #2]
00001e  f8d501ac          LDR      r0,[r5,#0x1ac]
000022  68c2              LDR      r2,[r0,#0xc]
000024  4628              MOV      r0,r5
000026  4790              BLX      r2
000028  b908              CBNZ     r0,|L4.46|
                  |L4.42|
;;;394    					   pMain->xbuffer[pMain->whichptr]))
;;;395          return;			/* suspension forced, can do nothing more */
;;;396        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
;;;397        pMain->iMCU_row_ctr++;	/* count rows received */
;;;398      }
;;;399    
;;;400      /* Postprocessor typically will not swallow all the input data it is handed
;;;401       * in one call (due to filling the output buffer first).  Must be prepared
;;;402       * to exit and restart.  This switch lets us keep track of how far we got.
;;;403       * Note that each case falls through to the next on successful completion.
;;;404       */
;;;405      switch (pMain->context_state) {
;;;406      case CTX_POSTPONED_ROW:
;;;407        /* Call postprocessor using previously set pointers for postponed row */
;;;408        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
;;;409    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;410    			output_buf, out_row_ctr, out_rows_avail);
;;;411        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
;;;412          return;			/* Need to suspend */
;;;413        pMain->context_state = CTX_PREPARE_FOR_IMCU;
;;;414        if (*out_row_ctr >= out_rows_avail)
;;;415          return;			/* Postprocessor exactly filled output buf */
;;;416        /*FALLTHROUGH*/
;;;417      case CTX_PREPARE_FOR_IMCU:
;;;418        /* Prepare to process first M-1 row groups of this iMCU row */
;;;419        pMain->rowgroup_ctr = 0;
;;;420        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
;;;421        /* Check for bottom of image: if so, tweak pointers to "duplicate"
;;;422         * the last sample row, and adjust rowgroups_avail to ignore padding rows.
;;;423         */
;;;424        if (pMain->iMCU_row_ctr == cinfo->total_iMCU_rows)
;;;425          set_bottom_pointers(cinfo);
;;;426        pMain->context_state = CTX_PROCESS_IMCU;
;;;427        /*FALLTHROUGH*/
;;;428      case CTX_PROCESS_IMCU:
;;;429        /* Call postprocessor using previously set pointers */
;;;430        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
;;;431    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;432    			output_buf, out_row_ctr, out_rows_avail);
;;;433        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
;;;434          return;			/* Need to suspend */
;;;435        /* After the first iMCU, change wraparound pointers to normal state */
;;;436        if (pMain->iMCU_row_ctr == 1)
;;;437          set_wraparound_pointers(cinfo);
;;;438        /* Prepare to load new iMCU row using other xbuffer list */
;;;439        pMain->whichptr ^= 1;	/* 0=>1 or 1=>0 */
;;;440        pMain->buffer_full = FALSE;
;;;441        /* Still need to process last row group of this iMCU row, */
;;;442        /* which is saved at index M+1 of the other xbuffer */
;;;443        pMain->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
;;;444        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
;;;445        pMain->context_state = CTX_POSTPONED_ROW;
;;;446      }
;;;447    }
00002a  e8bd83fe          POP      {r1-r9,pc}
                  |L4.46|
00002e  2001              MOVS     r0,#1                 ;396
000030  61a0              STR      r0,[r4,#0x18]         ;396
000032  6b60              LDR      r0,[r4,#0x34]         ;397
000034  1c40              ADDS     r0,r0,#1              ;397
000036  6360              STR      r0,[r4,#0x34]         ;397
                  |L4.56|
000038  6ae0              LDR      r0,[r4,#0x2c]         ;405
00003a  b300              CBZ      r0,|L4.126|
00003c  2801              CMP      r0,#1                 ;405
00003e  d02f              BEQ      |L4.160|
000040  2802              CMP      r0,#2                 ;405
000042  d15a              BNE      |L4.250|
000044  e9cd8600          STRD     r8,r6,[sp,#0]         ;408
000048  9702              STR      r7,[sp,#8]            ;408
00004a  f1040020          ADD      r0,r4,#0x20           ;408
00004e  6aa2              LDR      r2,[r4,#0x28]         ;408
000050  f8501022          LDR      r1,[r0,r2,LSL #2]     ;408
000054  6b23              LDR      r3,[r4,#0x30]         ;408
000056  f8d501b0          LDR      r0,[r5,#0x1b0]        ;408
00005a  f104021c          ADD      r2,r4,#0x1c           ;408
00005e  f8d0c004          LDR      r12,[r0,#4]           ;408
000062  4628              MOV      r0,r5                 ;408
000064  47e0              BLX      r12                   ;408
000066  6b21              LDR      r1,[r4,#0x30]         ;411
000068  69e0              LDR      r0,[r4,#0x1c]         ;411
00006a  4288              CMP      r0,r1                 ;411
00006c  d200              BCS      |L4.112|
00006e  e7dc              B        |L4.42|
                  |L4.112|
000070  2000              MOVS     r0,#0                 ;413
000072  62e0              STR      r0,[r4,#0x2c]         ;413
000074  6830              LDR      r0,[r6,#0]            ;414
000076  42b8              CMP      r0,r7                 ;414
000078  d300              BCC      |L4.124|
00007a  e7d6              B        |L4.42|
                  |L4.124|
00007c  bf00              NOP                            ;417
                  |L4.126|
00007e  2000              MOVS     r0,#0                 ;419
000080  61e0              STR      r0,[r4,#0x1c]         ;419
000082  f8d5013c          LDR      r0,[r5,#0x13c]        ;420
000086  1e40              SUBS     r0,r0,#1              ;420
000088  6320              STR      r0,[r4,#0x30]         ;420
00008a  6b60              LDR      r0,[r4,#0x34]         ;424
00008c  f8d51140          LDR      r1,[r5,#0x140]        ;424
000090  4288              CMP      r0,r1                 ;424
000092  d102              BNE      |L4.154|
000094  4628              MOV      r0,r5                 ;425
000096  f7fffffe          BL       set_bottom_pointers
                  |L4.154|
00009a  2001              MOVS     r0,#1                 ;426
00009c  62e0              STR      r0,[r4,#0x2c]         ;426
00009e  bf00              NOP                            ;428
                  |L4.160|
0000a0  e9cd8600          STRD     r8,r6,[sp,#0]         ;430
0000a4  9702              STR      r7,[sp,#8]            ;430
0000a6  f1040020          ADD      r0,r4,#0x20           ;430
0000aa  6aa2              LDR      r2,[r4,#0x28]         ;430
0000ac  f8501022          LDR      r1,[r0,r2,LSL #2]     ;430
0000b0  6b23              LDR      r3,[r4,#0x30]         ;430
0000b2  f8d501b0          LDR      r0,[r5,#0x1b0]        ;430
0000b6  f104021c          ADD      r2,r4,#0x1c           ;430
0000ba  f8d0c004          LDR      r12,[r0,#4]           ;430
0000be  4628              MOV      r0,r5                 ;430
0000c0  47e0              BLX      r12                   ;430
0000c2  6b21              LDR      r1,[r4,#0x30]         ;433
0000c4  69e0              LDR      r0,[r4,#0x1c]         ;433
0000c6  4288              CMP      r0,r1                 ;433
0000c8  d200              BCS      |L4.204|
0000ca  e7ae              B        |L4.42|
                  |L4.204|
0000cc  6b60              LDR      r0,[r4,#0x34]         ;436
0000ce  2801              CMP      r0,#1                 ;436
0000d0  d102              BNE      |L4.216|
0000d2  4628              MOV      r0,r5                 ;437
0000d4  f7fffffe          BL       set_wraparound_pointers
                  |L4.216|
0000d8  6aa0              LDR      r0,[r4,#0x28]         ;439
0000da  f0800001          EOR      r0,r0,#1              ;439
0000de  62a0              STR      r0,[r4,#0x28]         ;439
0000e0  2000              MOVS     r0,#0                 ;440
0000e2  61a0              STR      r0,[r4,#0x18]         ;440
0000e4  f8d5013c          LDR      r0,[r5,#0x13c]        ;443
0000e8  1c40              ADDS     r0,r0,#1              ;443
0000ea  61e0              STR      r0,[r4,#0x1c]         ;443
0000ec  f8d5013c          LDR      r0,[r5,#0x13c]        ;444
0000f0  1c80              ADDS     r0,r0,#2              ;444
0000f2  6320              STR      r0,[r4,#0x30]         ;444
0000f4  2002              MOVS     r0,#2                 ;445
0000f6  62e0              STR      r0,[r4,#0x2c]         ;445
0000f8  bf00              NOP                            ;405
                  |L4.250|
0000fa  bf00              NOP                            ;405
0000fc  bf00              NOP      
0000fe  e794              B        |L4.42|
;;;448    
                          ENDP


                          AREA ||i.process_data_crank_post||, CODE, READONLY, ALIGN=1

                  process_data_crank_post PROC
;;;458    METHODDEF(void)
;;;459    process_data_crank_post (j_decompress_ptr cinfo,
000000  b5fe              PUSH     {r1-r7,lr}
;;;460    			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;461    			 JDIMENSION out_rows_avail)
;;;462    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;463      (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
00000a  e88d00e0          STM      sp,{r5-r7}
00000e  f8d401b0          LDR      r0,[r4,#0x1b0]
000012  2300              MOVS     r3,#0
000014  461a              MOV      r2,r3
000016  4619              MOV      r1,r3
000018  f8d0c004          LDR      r12,[r0,#4]
00001c  4620              MOV      r0,r4
00001e  47e0              BLX      r12
;;;464    				     (JDIMENSION *) NULL, (JDIMENSION) 0,
;;;465    				     output_buf, out_row_ctr, out_rows_avail);
;;;466    }
000020  bdfe              POP      {r1-r7,pc}
;;;467    
                          ENDP


                          AREA ||i.process_data_simple_main||, CODE, READONLY, ALIGN=1

                  process_data_simple_main PROC
;;;344    METHODDEF(void)
;;;345    process_data_simple_main (j_decompress_ptr cinfo,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;346    			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;347    			  JDIMENSION out_rows_avail)
;;;348    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;349      my_main_ptr pMain = (my_main_ptr) cinfo->main;
00000c  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;350      JDIMENSION rowgroups_avail;
;;;351    
;;;352      /* Read input data if we haven't filled the main buffer yet */
;;;353      if (! pMain->buffer_full) {
000010  69a0              LDR      r0,[r4,#0x18]
000012  b958              CBNZ     r0,|L6.44|
;;;354        if (! (*cinfo->coef->decompress_data) (cinfo, pMain->buffer))
000014  f8d501ac          LDR      r0,[r5,#0x1ac]
000018  f1040108          ADD      r1,r4,#8
00001c  68c2              LDR      r2,[r0,#0xc]
00001e  4628              MOV      r0,r5
000020  4790              BLX      r2
000022  b908              CBNZ     r0,|L6.40|
                  |L6.36|
;;;355          return;			/* suspension forced, can do nothing more */
;;;356        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
;;;357      }
;;;358    
;;;359      /* There are always min_DCT_scaled_size row groups in an iMCU row. */
;;;360      rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
;;;361      /* Note: at the bottom of the image, we may pass extra garbage row groups
;;;362       * to the postprocessor.  The postprocessor has to check for bottom
;;;363       * of image anyway (at row resolution), so no point in us doing it too.
;;;364       */
;;;365    
;;;366      /* Feed the postprocessor */
;;;367      (*cinfo->post->post_process_data) (cinfo, pMain->buffer,
;;;368    				     &pMain->rowgroup_ctr, rowgroups_avail,
;;;369    				     output_buf, out_row_ctr, out_rows_avail);
;;;370    
;;;371      /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
;;;372      if (pMain->rowgroup_ctr >= rowgroups_avail) {
;;;373        pMain->buffer_full = FALSE;
;;;374        pMain->rowgroup_ctr = 0;
;;;375      }
;;;376    }
000024  e8bd83fe          POP      {r1-r9,pc}
                  |L6.40|
000028  2001              MOVS     r0,#1                 ;356
00002a  61a0              STR      r0,[r4,#0x18]         ;356
                  |L6.44|
00002c  f8d5613c          LDR      r6,[r5,#0x13c]        ;360
000030  e88d0380          STM      sp,{r7-r9}            ;367
000034  f8d501b0          LDR      r0,[r5,#0x1b0]        ;367
000038  4633              MOV      r3,r6                 ;367
00003a  f104021c          ADD      r2,r4,#0x1c           ;367
00003e  f1040108          ADD      r1,r4,#8              ;367
000042  f8d0c004          LDR      r12,[r0,#4]           ;367
000046  4628              MOV      r0,r5                 ;367
000048  47e0              BLX      r12                   ;367
00004a  69e0              LDR      r0,[r4,#0x1c]         ;372
00004c  42b0              CMP      r0,r6                 ;372
00004e  d302              BCC      |L6.86|
000050  2000              MOVS     r0,#0                 ;373
000052  61a0              STR      r0,[r4,#0x18]         ;373
000054  61e0              STR      r0,[r4,#0x1c]         ;374
                  |L6.86|
000056  bf00              NOP      
000058  e7e4              B        |L6.36|
;;;377    
                          ENDP


                          AREA ||i.set_bottom_pointers||, CODE, READONLY, ALIGN=1

                  set_bottom_pointers PROC
;;;265    LOCAL(void)
;;;266    set_bottom_pointers (j_decompress_ptr cinfo)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;267    /* Change the pointer lists to duplicate the last sample row at the bottom
;;;268     * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
;;;269     * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
;;;270     */
;;;271    {
;;;272      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000004  f8d071a8          LDR      r7,[r0,#0x1a8]
;;;273      int ci, i, rgroup, iMCUheight, rows_left;
;;;274      jpeg_component_info *compptr;
;;;275      JSAMPARRAY xbuf;
;;;276    
;;;277      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000008  2100              MOVS     r1,#0
00000a  f8d050d8          LDR      r5,[r0,#0xd8]
00000e  e034              B        |L7.122|
                  |L7.16|
;;;278           ci++, compptr++) {
;;;279        /* Count sample rows in one iMCU row and in one row group */
;;;280        iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
000010  f8d59024          LDR      r9,[r5,#0x24]
000014  f8d5800c          LDR      r8,[r5,#0xc]
000018  fb08f309          MUL      r3,r8,r9
;;;281        rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
00001c  f8d0813c          LDR      r8,[r0,#0x13c]
000020  fb93f2f8          SDIV     r2,r3,r8
;;;282        /* Count nondummy sample rows remaining for this component */
;;;283        rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
000024  f8d5802c          LDR      r8,[r5,#0x2c]
000028  fbb8f9f3          UDIV     r9,r8,r3
00002c  fb038419          MLS      r4,r3,r9,r8
;;;284        if (rows_left == 0) rows_left = iMCUheight;
000030  b904              CBNZ     r4,|L7.52|
000032  461c              MOV      r4,r3
                  |L7.52|
;;;285        /* Count nondummy row groups.  Should get same answer for each component,
;;;286         * so we need only do it once.
;;;287         */
;;;288        if (ci == 0) {
000034  b939              CBNZ     r1,|L7.70|
;;;289          pMain->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
000036  f1a40801          SUB      r8,r4,#1
00003a  fb98f8f2          SDIV     r8,r8,r2
00003e  f1080801          ADD      r8,r8,#1
000042  f8c78030          STR      r8,[r7,#0x30]
                  |L7.70|
;;;290        }
;;;291        /* Duplicate the last real sample row rgroup*2 times; this pads out the
;;;292         * last partial rowgroup and ensures at least one full rowgroup of context.
;;;293         */
;;;294        xbuf = pMain->xbuffer[pMain->whichptr][ci];
000046  f1070820          ADD      r8,r7,#0x20
00004a  f8d79028          LDR      r9,[r7,#0x28]
00004e  f8588029          LDR      r8,[r8,r9,LSL #2]
000052  f8586021          LDR      r6,[r8,r1,LSL #2]
;;;295        for (i = 0; i < rgroup * 2; i++) {
000056  f04f0c00          MOV      r12,#0
00005a  e009              B        |L7.112|
                  |L7.92|
;;;296          xbuf[rows_left + i] = xbuf[rows_left-1];
00005c  f1a40801          SUB      r8,r4,#1
000060  f8568028          LDR      r8,[r6,r8,LSL #2]
000064  eb04090c          ADD      r9,r4,r12
000068  f8468029          STR      r8,[r6,r9,LSL #2]
00006c  f10c0c01          ADD      r12,r12,#1            ;295
                  |L7.112|
000070  ebbc0f42          CMP      r12,r2,LSL #1         ;295
000074  dbf2              BLT      |L7.92|
000076  1c49              ADDS     r1,r1,#1              ;278
000078  3554              ADDS     r5,r5,#0x54           ;278
                  |L7.122|
00007a  f8d08024          LDR      r8,[r0,#0x24]         ;277
00007e  4588              CMP      r8,r1                 ;277
000080  dcc6              BGT      |L7.16|
;;;297        }
;;;298      }
;;;299    }
000082  e8bd83f0          POP      {r4-r9,pc}
;;;300    
                          ENDP


                          AREA ||i.set_wraparound_pointers||, CODE, READONLY, ALIGN=1

                  set_wraparound_pointers PROC
;;;237    LOCAL(void)
;;;238    set_wraparound_pointers (j_decompress_ptr cinfo)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;239    /* Set up the "wraparound" pointers at top and bottom of the pointer lists.
;;;240     * This changes the pointer list state from top-of-image to the normal state.
;;;241     */
;;;242    {
000004  4602              MOV      r2,r0
;;;243      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000006  f8d2c1a8          LDR      r12,[r2,#0x1a8]
;;;244      int ci, i, rgroup;
;;;245      int M = cinfo->min_DCT_scaled_size;
00000a  f8d2613c          LDR      r6,[r2,#0x13c]
;;;246      jpeg_component_info *compptr;
;;;247      JSAMPARRAY xbuf0, xbuf1;
;;;248    
;;;249      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00000e  2500              MOVS     r5,#0
000010  f8d270d8          LDR      r7,[r2,#0xd8]
000014  e03c              B        |L8.144|
                  |L8.22|
;;;250           ci++, compptr++) {
;;;251        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000016  f8d79024          LDR      r9,[r7,#0x24]
00001a  f8d7800c          LDR      r8,[r7,#0xc]
00001e  fb08f809          MUL      r8,r8,r9
000022  f8d2913c          LDR      r9,[r2,#0x13c]
000026  fb98f1f9          SDIV     r1,r8,r9
;;;252          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;253        xbuf0 = pMain->xbuffer[0][ci];
00002a  f8dc8020          LDR      r8,[r12,#0x20]
00002e  f8583025          LDR      r3,[r8,r5,LSL #2]
;;;254        xbuf1 = pMain->xbuffer[1][ci];
000032  f8dc8024          LDR      r8,[r12,#0x24]
000036  f8584025          LDR      r4,[r8,r5,LSL #2]
;;;255        for (i = 0; i < rgroup; i++) {
00003a  2000              MOVS     r0,#0
00003c  e024              B        |L8.136|
                  |L8.62|
;;;256          xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
00003e  f1060801          ADD      r8,r6,#1
000042  fb010808          MLA      r8,r1,r8,r0
000046  f8538028          LDR      r8,[r3,r8,LSL #2]
00004a  eba00901          SUB      r9,r0,r1
00004e  f8438029          STR      r8,[r3,r9,LSL #2]
;;;257          xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
000052  f1060801          ADD      r8,r6,#1
000056  fb010808          MLA      r8,r1,r8,r0
00005a  f8548028          LDR      r8,[r4,r8,LSL #2]
00005e  eba00901          SUB      r9,r0,r1
000062  f8448029          STR      r8,[r4,r9,LSL #2]
;;;258          xbuf0[rgroup*(M+2) + i] = xbuf0[i];
000066  f8539020          LDR      r9,[r3,r0,LSL #2]
00006a  f1060802          ADD      r8,r6,#2
00006e  fb010808          MLA      r8,r1,r8,r0
000072  f8439028          STR      r9,[r3,r8,LSL #2]
;;;259          xbuf1[rgroup*(M+2) + i] = xbuf1[i];
000076  f8549020          LDR      r9,[r4,r0,LSL #2]
00007a  f1060802          ADD      r8,r6,#2
00007e  fb010808          MLA      r8,r1,r8,r0
000082  f8449028          STR      r9,[r4,r8,LSL #2]
000086  1c40              ADDS     r0,r0,#1              ;255
                  |L8.136|
000088  4288              CMP      r0,r1                 ;255
00008a  dbd8              BLT      |L8.62|
00008c  1c6d              ADDS     r5,r5,#1              ;250
00008e  3754              ADDS     r7,r7,#0x54           ;250
                  |L8.144|
000090  f8d28024          LDR      r8,[r2,#0x24]         ;249
000094  45a8              CMP      r8,r5                 ;249
000096  dcbe              BGT      |L8.22|
;;;260        }
;;;261      }
;;;262    }
000098  e8bd83f0          POP      {r4-r9,pc}
;;;263    
                          ENDP


                          AREA ||i.start_pass_main||, CODE, READONLY, ALIGN=2

                  start_pass_main PROC
;;;306    METHODDEF(void)
;;;307    start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
000000  b570              PUSH     {r4-r6,lr}
;;;308    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;309      my_main_ptr pMain = (my_main_ptr) cinfo->main;
000006  f8d541a8          LDR      r4,[r5,#0x1a8]
;;;310    
;;;311      switch (pass_mode) {
00000a  b116              CBZ      r6,|L9.18|
00000c  2e02              CMP      r6,#2
00000e  d117              BNE      |L9.64|
000010  e013              B        |L9.58|
                  |L9.18|
;;;312      case JBUF_PASS_THRU:
;;;313        if (cinfo->upsample->need_context_rows) {
000012  f8d501c4          LDR      r0,[r5,#0x1c4]
000016  6880              LDR      r0,[r0,#8]
000018  b148              CBZ      r0,|L9.46|
;;;314          pMain->pub.process_data = process_data_context_main;
00001a  480e              LDR      r0,|L9.84|
00001c  6060              STR      r0,[r4,#4]
;;;315          make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       make_funny_pointers
;;;316          pMain->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
000024  2000              MOVS     r0,#0
000026  62a0              STR      r0,[r4,#0x28]
;;;317          pMain->context_state = CTX_PREPARE_FOR_IMCU;
000028  62e0              STR      r0,[r4,#0x2c]
;;;318          pMain->iMCU_row_ctr = 0;
00002a  6360              STR      r0,[r4,#0x34]
00002c  e001              B        |L9.50|
                  |L9.46|
;;;319        } else {
;;;320          /* Simple case with no context needed */
;;;321          pMain->pub.process_data = process_data_simple_main;
00002e  480a              LDR      r0,|L9.88|
000030  6060              STR      r0,[r4,#4]
                  |L9.50|
;;;322        }
;;;323        pMain->buffer_full = FALSE;	/* Mark buffer empty */
000032  2000              MOVS     r0,#0
000034  61a0              STR      r0,[r4,#0x18]
;;;324        pMain->rowgroup_ctr = 0;
000036  61e0              STR      r0,[r4,#0x1c]
;;;325        break;
000038  e00a              B        |L9.80|
                  |L9.58|
;;;326    #ifdef QUANT_2PASS_SUPPORTED
;;;327      case JBUF_CRANK_DEST:
;;;328        /* For last pass of 2-pass quantization, just crank the postprocessor */
;;;329        pMain->pub.process_data = process_data_crank_post;
00003a  4808              LDR      r0,|L9.92|
00003c  6060              STR      r0,[r4,#4]
;;;330        break;
00003e  e007              B        |L9.80|
                  |L9.64|
;;;331    #endif
;;;332      default:
;;;333        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000040  2004              MOVS     r0,#4
000042  6829              LDR      r1,[r5,#0]
000044  6148              STR      r0,[r1,#0x14]
000046  6828              LDR      r0,[r5,#0]
000048  6801              LDR      r1,[r0,#0]
00004a  4628              MOV      r0,r5
00004c  4788              BLX      r1
;;;334        break;
00004e  bf00              NOP      
                  |L9.80|
000050  bf00              NOP                            ;325
;;;335      }
;;;336    }
000052  bd70              POP      {r4-r6,pc}
;;;337    
                          ENDP

                  |L9.84|
                          DCD      process_data_context_main
                  |L9.88|
                          DCD      process_data_simple_main
                  |L9.92|
                          DCD      process_data_crank_post
