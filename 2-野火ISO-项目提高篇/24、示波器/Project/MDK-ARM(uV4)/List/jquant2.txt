; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jquant2.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jquant2.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\jquant2.crf ..\..\uCGUI\JPEG\jquant2.c]
                          THUMB

                          AREA ||i.compute_color||, CODE, READONLY, ALIGN=1

                  compute_color PROC
;;;499    LOCAL(void)
;;;500    compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;501    /* Compute representative color for a box, put it in colormap[icolor] */
;;;502    {
000004  b088              SUB      sp,sp,#0x20
000006  4603              MOV      r3,r0
000008  4614              MOV      r4,r2
;;;503      /* Current algorithm: mean weighted by pixels (not colors) */
;;;504      /* Note it is important to get the rounding correct! */
;;;505      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000a  f8d3b1cc          LDR      r11,[r3,#0x1cc]
00000e  f8cdb01c          STR      r11,[sp,#0x1c]
;;;506      hist3d histogram = cquantize->histogram;
000012  f8ddb01c          LDR      r11,[sp,#0x1c]
000016  f8dbb018          LDR      r11,[r11,#0x18]
00001a  f8cdb018          STR      r11,[sp,#0x18]
;;;507      histptr histp;
;;;508      int c0,c1,c2;
;;;509      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;510      long count;
;;;511      long total = 0;
00001e  2000              MOVS     r0,#0
;;;512      long c0total = 0;
000020  4684              MOV      r12,r0
;;;513      long c1total = 0;
000022  4680              MOV      r8,r0
;;;514      long c2total = 0;
000024  4681              MOV      r9,r0
;;;515      
;;;516      c0min = boxp->c0min;  c0max = boxp->c0max;
000026  f8d1b000          LDR      r11,[r1,#0]
00002a  f8cdb014          STR      r11,[sp,#0x14]
00002e  f8d1b004          LDR      r11,[r1,#4]
000032  f8cdb010          STR      r11,[sp,#0x10]
;;;517      c1min = boxp->c1min;  c1max = boxp->c1max;
000036  f8d1b008          LDR      r11,[r1,#8]
00003a  f8cdb00c          STR      r11,[sp,#0xc]
00003e  f8d1b00c          LDR      r11,[r1,#0xc]
000042  f8cdb008          STR      r11,[sp,#8]
;;;518      c2min = boxp->c2min;  c2max = boxp->c2max;
000046  f8d1b010          LDR      r11,[r1,#0x10]
00004a  f8cdb004          STR      r11,[sp,#4]
00004e  f8d1b014          LDR      r11,[r1,#0x14]
000052  f8cdb000          STR      r11,[sp,#0]
;;;519      
;;;520      for (c0 = c0min; c0 <= c0max; c0++)
000056  9d05              LDR      r5,[sp,#0x14]
000058  e02e              B        |L1.184|
                  |L1.90|
;;;521        for (c1 = c1min; c1 <= c1max; c1++) {
00005a  9e03              LDR      r6,[sp,#0xc]
00005c  e027              B        |L1.174|
                  |L1.94|
;;;522          histp = & histogram[c0][c1][c2min];
00005e  f8ddb018          LDR      r11,[sp,#0x18]
000062  f85bb025          LDR      r11,[r11,r5,LSL #2]
000066  eb0b1e86          ADD      lr,r11,r6,LSL #6
00006a  f8ddb004          LDR      r11,[sp,#4]
00006e  eb0e0a4b          ADD      r10,lr,r11,LSL #1
;;;523          for (c2 = c2min; c2 <= c2max; c2++) {
000072  9f01              LDR      r7,[sp,#4]
000074  e016              B        |L1.164|
                  |L1.118|
;;;524    	if ((count = *histp++) != 0) {
000076  f83a2b02          LDRH     r2,[r10],#2
00007a  b192              CBZ      r2,|L1.162|
;;;525    	  total += count;
00007c  4410              ADD      r0,r0,r2
;;;526    	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
00007e  f04f0b04          MOV      r11,#4
000082  eb0b0bc5          ADD      r11,r11,r5,LSL #3
000086  fb0bcc02          MLA      r12,r11,r2,r12
;;;527    	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
00008a  f04f0b02          MOV      r11,#2
00008e  eb0b0b86          ADD      r11,r11,r6,LSL #2
000092  fb0b8802          MLA      r8,r11,r2,r8
;;;528    	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
000096  f04f0b04          MOV      r11,#4
00009a  eb0b0bc7          ADD      r11,r11,r7,LSL #3
00009e  fb0b9902          MLA      r9,r11,r2,r9
                  |L1.162|
0000a2  1c7f              ADDS     r7,r7,#1              ;523
                  |L1.164|
0000a4  f8ddb000          LDR      r11,[sp,#0]           ;523
0000a8  455f              CMP      r7,r11                ;523
0000aa  dde4              BLE      |L1.118|
0000ac  1c76              ADDS     r6,r6,#1              ;521
                  |L1.174|
0000ae  f8ddb008          LDR      r11,[sp,#8]           ;521
0000b2  455e              CMP      r6,r11                ;521
0000b4  ddd3              BLE      |L1.94|
0000b6  1c6d              ADDS     r5,r5,#1              ;520
                  |L1.184|
0000b8  f8ddb010          LDR      r11,[sp,#0x10]        ;520
0000bc  455d              CMP      r5,r11                ;520
0000be  ddcc              BLE      |L1.90|
;;;529    	}
;;;530          }
;;;531        }
;;;532      
;;;533      cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
0000c0  eb0c0b60          ADD      r11,r12,r0,ASR #1
0000c4  fb9bfbf0          SDIV     r11,r11,r0
0000c8  f8d3e088          LDR      lr,[r3,#0x88]
0000cc  f8dee000          LDR      lr,[lr,#0]
0000d0  f80eb004          STRB     r11,[lr,r4]
;;;534      cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
0000d4  eb080b60          ADD      r11,r8,r0,ASR #1
0000d8  fb9bfbf0          SDIV     r11,r11,r0
0000dc  f8d3e088          LDR      lr,[r3,#0x88]
0000e0  f8dee004          LDR      lr,[lr,#4]
0000e4  f80eb004          STRB     r11,[lr,r4]
;;;535      cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
0000e8  eb090b60          ADD      r11,r9,r0,ASR #1
0000ec  fb9bfbf0          SDIV     r11,r11,r0
0000f0  f8d3e088          LDR      lr,[r3,#0x88]
0000f4  f8dee008          LDR      lr,[lr,#8]
0000f8  f80eb004          STRB     r11,[lr,r4]
;;;536    }
0000fc  b008              ADD      sp,sp,#0x20
0000fe  e8bd8ff0          POP      {r4-r11,pc}
;;;537    
                          ENDP


                          AREA ||i.fill_inverse_cmap||, CODE, READONLY, ALIGN=1

                  fill_inverse_cmap PROC
;;;855    LOCAL(void)
;;;856    fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;857    /* Fill the inverse-colormap entries in the update box that contains */
;;;858    /* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
;;;859    /* we can fill as many others as we wish.) */
;;;860    {
000004  b0eb              SUB      sp,sp,#0x1ac
000006  4681              MOV      r9,r0
000008  460c              MOV      r4,r1
00000a  4615              MOV      r5,r2
00000c  461e              MOV      r6,r3
;;;861      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000e  f8d901cc          LDR      r0,[r9,#0x1cc]
000012  906a              STR      r0,[sp,#0x1a8]
;;;862      hist3d histogram = cquantize->histogram;
000014  986a              LDR      r0,[sp,#0x1a8]
000016  6980              LDR      r0,[r0,#0x18]
000018  9069              STR      r0,[sp,#0x1a4]
;;;863      int minc0, minc1, minc2;	/* lower left corner of update box */
;;;864      int ic0, ic1, ic2;
;;;865      register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
;;;866      register histptr cachep;	/* pointer into main cache array */
;;;867      /* This array lists the candidate colormap indexes. */
;;;868      JSAMPLE colorlist[MAXNUMCOLORS];
;;;869      int numcolors;		/* number of candidate colors */
;;;870      /* This array holds the actually closest colormap index for each cell. */
;;;871      JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;872    
;;;873      /* Convert cell coordinates to update box ID */
;;;874      c0 >>= BOX_C0_LOG;
00001a  10a4              ASRS     r4,r4,#2
;;;875      c1 >>= BOX_C1_LOG;
00001c  10ed              ASRS     r5,r5,#3
;;;876      c2 >>= BOX_C2_LOG;
00001e  10b6              ASRS     r6,r6,#2
;;;877    
;;;878      /* Compute true coordinates of update box's origin corner.
;;;879       * Actually we compute the coordinates of the center of the corner
;;;880       * histogram cell, which are the lower bounds of the volume we care about.
;;;881       */
;;;882      minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
000020  2004              MOVS     r0,#4
000022  eb001044          ADD      r0,r0,r4,LSL #5
000026  9068              STR      r0,[sp,#0x1a0]
;;;883      minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
000028  2002              MOVS     r0,#2
00002a  eb001045          ADD      r0,r0,r5,LSL #5
00002e  9067              STR      r0,[sp,#0x19c]
;;;884      minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
000030  2004              MOVS     r0,#4
000032  eb001046          ADD      r0,r0,r6,LSL #5
000036  9066              STR      r0,[sp,#0x198]
;;;885      
;;;886      /* Determine which colormap entries are close enough to be candidates
;;;887       * for the nearest entry to some cell in the update box.
;;;888       */
;;;889      numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
000038  a825              ADD      r0,sp,#0x94
00003a  9000              STR      r0,[sp,#0]
00003c  4648              MOV      r0,r9
00003e  9b66              LDR      r3,[sp,#0x198]
000040  9a67              LDR      r2,[sp,#0x19c]
000042  9968              LDR      r1,[sp,#0x1a0]
000044  f7fffffe          BL       find_nearby_colors
000048  9024              STR      r0,[sp,#0x90]
;;;890    
;;;891      /* Determine the actually nearest colors. */
;;;892      find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
00004a  a904              ADD      r1,sp,#0x10
00004c  aa25              ADD      r2,sp,#0x94
00004e  9824              LDR      r0,[sp,#0x90]
000050  e9cd2101          STRD     r2,r1,[sp,#4]
000054  9000              STR      r0,[sp,#0]
000056  4648              MOV      r0,r9
000058  9b66              LDR      r3,[sp,#0x198]
00005a  9a67              LDR      r2,[sp,#0x19c]
00005c  9968              LDR      r1,[sp,#0x1a0]
00005e  f7fffffe          BL       find_best_colors
;;;893    		   bestcolor);
;;;894    
;;;895      /* Save the best color numbers (plus 1) in the main cache array */
;;;896      c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
000062  00a4              LSLS     r4,r4,#2
;;;897      c1 <<= BOX_C1_LOG;
000064  00ed              LSLS     r5,r5,#3
;;;898      c2 <<= BOX_C2_LOG;
000066  00b6              LSLS     r6,r6,#2
;;;899      cptr = bestcolor;
000068  a804              ADD      r0,sp,#0x10
00006a  9065              STR      r0,[sp,#0x194]
;;;900      for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
00006c  2700              MOVS     r7,#0
00006e  e021              B        |L2.180|
                  |L2.112|
;;;901        for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
000070  f04f0800          MOV      r8,#0
000074  e01a              B        |L2.172|
                  |L2.118|
;;;902          cachep = & histogram[c0+ic0][c1+ic1][c2];
000076  19e1              ADDS     r1,r4,r7
000078  9869              LDR      r0,[sp,#0x1a4]
00007a  f8500021          LDR      r0,[r0,r1,LSL #2]
00007e  eb050108          ADD      r1,r5,r8
000082  eb001081          ADD      r0,r0,r1,LSL #6
000086  eb000b46          ADD      r11,r0,r6,LSL #1
;;;903          for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
00008a  f04f0a00          MOV      r10,#0
00008e  e008              B        |L2.162|
                  |L2.144|
;;;904    	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
000090  9865              LDR      r0,[sp,#0x194]
000092  f8101b01          LDRB     r1,[r0],#1
000096  1c49              ADDS     r1,r1,#1
000098  9065              STR      r0,[sp,#0x194]
00009a  f82b1b02          STRH     r1,[r11],#2
00009e  f10a0a01          ADD      r10,r10,#1            ;903
                  |L2.162|
0000a2  f1ba0f04          CMP      r10,#4                ;903
0000a6  dbf3              BLT      |L2.144|
0000a8  f1080801          ADD      r8,r8,#1              ;901
                  |L2.172|
0000ac  f1b80f08          CMP      r8,#8                 ;901
0000b0  dbe1              BLT      |L2.118|
0000b2  1c7f              ADDS     r7,r7,#1              ;900
                  |L2.180|
0000b4  2f04              CMP      r7,#4                 ;900
0000b6  dbdb              BLT      |L2.112|
;;;905          }
;;;906        }
;;;907      }
;;;908    }
0000b8  b06b              ADD      sp,sp,#0x1ac
0000ba  e8bd8ff0          POP      {r4-r11,pc}
;;;909    
                          ENDP


                          AREA ||i.find_best_colors||, CODE, READONLY, ALIGN=1

                  find_best_colors PROC
;;;775    LOCAL(void)
;;;776    find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;777    		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
;;;778    /* Find the closest colormap entry for each cell in the update box,
;;;779     * given the list of candidate colors prepared by find_nearby_colors.
;;;780     * Return the indexes of the closest entries in the bestcolor[] array.
;;;781     * This routine uses Thomas' incremental distance calculation method to
;;;782     * find the distance from a colormap entry to successive cells in the box.
;;;783     */
;;;784    {
000004  f5ad7d05          SUB      sp,sp,#0x214
000008  4604              MOV      r4,r0
;;;785      int ic0, ic1, ic2;
;;;786      int i, icolor;
;;;787      register INT32 * bptr;	/* pointer into bestdist[] array */
;;;788      JSAMPLE * cptr;		/* pointer into bestcolor[] array */
;;;789      INT32 dist0, dist1;		/* initial distance values */
;;;790      register INT32 dist2;		/* current distance in inner loop */
;;;791      INT32 xx0, xx1;		/* distance increments */
;;;792      register INT32 xx2;
;;;793      INT32 inc0, inc1, inc2;	/* initial values for increments */
;;;794      /* This array holds the distance to the nearest-so-far color for each cell */
;;;795      INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;796    
;;;797      /* Initialize best-distance for each cell of the update box */
;;;798      bptr = bestdist;
00000a  466a              MOV      r2,sp
;;;799      for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
00000c  207f              MOVS     r0,#0x7f
00000e  e004              B        |L3.26|
                  |L3.16|
;;;800        *bptr++ = 0x7FFFFFFFL;
000010  f06f4b00          MVN      r11,#0x80000000
000014  f842bb04          STR      r11,[r2],#4
000018  1e40              SUBS     r0,r0,#1              ;799
                  |L3.26|
00001a  2800              CMP      r0,#0                 ;799
00001c  daf8              BGE      |L3.16|
;;;801      
;;;802      /* For each color selected by find_nearby_colors,
;;;803       * compute its distance to the center of each cell in the box.
;;;804       * If that's less than best-so-far, update best distance and color number.
;;;805       */
;;;806      
;;;807      /* Nominal steps between cell centers ("x" in Thomas article) */
;;;808    #define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
;;;809    #define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
;;;810    #define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
;;;811      
;;;812      for (i = 0; i < numcolors; i++) {
00001e  2000              MOVS     r0,#0
000020  e08d              B        |L3.318|
                  |L3.34|
;;;813        icolor = GETJSAMPLE(colorlist[i]);
000022  f8ddb24c          LDR      r11,[sp,#0x24c]
000026  f81b1000          LDRB     r1,[r11,r0]
;;;814        /* Compute (square of) distance from minc0/c1/c2 to this color */
;;;815        inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
00002a  f8d4b088          LDR      r11,[r4,#0x88]
00002e  f8dbb000          LDR      r11,[r11,#0]
000032  f81be001          LDRB     lr,[r11,r1]
000036  f8ddb218          LDR      r11,[sp,#0x218]
00003a  ebab0b0e          SUB      r11,r11,lr
00003e  ea4f064b          LSL      r6,r11,#1
;;;816        dist0 = inc0*inc0;
000042  fb06f506          MUL      r5,r6,r6
;;;817        inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
000046  f8d4b088          LDR      r11,[r4,#0x88]
00004a  f8dbb004          LDR      r11,[r11,#4]
00004e  f81be001          LDRB     lr,[r11,r1]
000052  f8ddb21c          LDR      r11,[sp,#0x21c]
000056  ebab0b0e          SUB      r11,r11,lr
00005a  eb0b074b          ADD      r7,r11,r11,LSL #1
;;;818        dist0 += inc1*inc1;
00005e  fb075507          MLA      r5,r7,r7,r5
;;;819        inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
000062  f8d4b088          LDR      r11,[r4,#0x88]
000066  f8dbb008          LDR      r11,[r11,#8]
00006a  f81be001          LDRB     lr,[r11,r1]
00006e  f8ddb220          LDR      r11,[sp,#0x220]
000072  ebab030e          SUB      r3,r11,lr
;;;820        dist0 += inc2*inc2;
000076  fb035503          MLA      r5,r3,r3,r5
;;;821        /* Form the initial difference increments */
;;;822        inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
00007a  f44f7b80          MOV      r11,#0x100
00007e  eb0b1646          ADD      r6,r11,r6,LSL #5
;;;823        inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
000082  eb070b47          ADD      r11,r7,r7,LSL #1
000086  f04f0e90          MOV      lr,#0x90
00008a  eb0e07cb          ADD      r7,lr,r11,LSL #3
;;;824        inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
00008e  f04f0b40          MOV      r11,#0x40
000092  eb0b1303          ADD      r3,r11,r3,LSL #4
;;;825        /* Now loop over all cells in box, updating distance per Thomas method */
;;;826        bptr = bestdist;
000096  466a              MOV      r2,sp
;;;827        cptr = bestcolor;
000098  f8dda250          LDR      r10,[sp,#0x250]
;;;828        xx0 = inc0;
00009c  9682              STR      r6,[sp,#0x208]
;;;829        for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
00009e  f04f0803          MOV      r8,#3
0000a2  e048              B        |L3.310|
                  |L3.164|
;;;830          dist1 = dist0;
0000a4  9583              STR      r5,[sp,#0x20c]
;;;831          xx1 = inc1;
0000a6  9781              STR      r7,[sp,#0x204]
;;;832          for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
0000a8  f04f0907          MOV      r9,#7
0000ac  e035              B        |L3.282|
                  |L3.174|
;;;833    	dist2 = dist1;
0000ae  f8ddc20c          LDR      r12,[sp,#0x20c]
;;;834    	xx2 = inc2;
0000b2  9380              STR      r3,[sp,#0x200]
;;;835    	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
0000b4  f04f0b03          MOV      r11,#3
0000b8  f8cdb210          STR      r11,[sp,#0x210]
0000bc  e019              B        |L3.242|
                  |L3.190|
;;;836    	  if (dist2 < *bptr) {
0000be  f8d2b000          LDR      r11,[r2,#0]
0000c2  45e3              CMP      r11,r12
0000c4  dd03              BLE      |L3.206|
;;;837    	    *bptr = dist2;
0000c6  f8c2c000          STR      r12,[r2,#0]
;;;838    	    *cptr = (JSAMPLE) icolor;
0000ca  f88a1000          STRB     r1,[r10,#0]
                  |L3.206|
;;;839    	  }
;;;840    	  dist2 += xx2;
0000ce  f8ddb200          LDR      r11,[sp,#0x200]
0000d2  44dc              ADD      r12,r12,r11
;;;841    	  xx2 += 2 * STEP_C2 * STEP_C2;
0000d4  f8ddb200          LDR      r11,[sp,#0x200]
0000d8  f10b0b80          ADD      r11,r11,#0x80
0000dc  f8cdb200          STR      r11,[sp,#0x200]
;;;842    	  bptr++;
0000e0  1d12              ADDS     r2,r2,#4
;;;843    	  cptr++;
0000e2  f10a0a01          ADD      r10,r10,#1
0000e6  f8ddb210          LDR      r11,[sp,#0x210]       ;835
0000ea  f1ab0b01          SUB      r11,r11,#1            ;835
0000ee  f8cdb210          STR      r11,[sp,#0x210]       ;835
                  |L3.242|
0000f2  f8ddb210          LDR      r11,[sp,#0x210]       ;835
0000f6  f1bb0f00          CMP      r11,#0                ;835
0000fa  dae0              BGE      |L3.190|
;;;844    	}
;;;845    	dist1 += xx1;
0000fc  f8dde204          LDR      lr,[sp,#0x204]
000100  f8ddb20c          LDR      r11,[sp,#0x20c]
000104  44f3              ADD      r11,r11,lr
000106  f8cdb20c          STR      r11,[sp,#0x20c]
;;;846    	xx1 += 2 * STEP_C1 * STEP_C1;
00010a  f8ddb204          LDR      r11,[sp,#0x204]
00010e  f50b7b90          ADD      r11,r11,#0x120
000112  f8cdb204          STR      r11,[sp,#0x204]
000116  f1a90901          SUB      r9,r9,#1              ;832
                  |L3.282|
00011a  f1b90f00          CMP      r9,#0                 ;832
00011e  dac6              BGE      |L3.174|
;;;847          }
;;;848          dist0 += xx0;
000120  f8ddb208          LDR      r11,[sp,#0x208]
000124  445d              ADD      r5,r5,r11
;;;849          xx0 += 2 * STEP_C0 * STEP_C0;
000126  f8ddb208          LDR      r11,[sp,#0x208]
00012a  f50b7b00          ADD      r11,r11,#0x200
00012e  f8cdb208          STR      r11,[sp,#0x208]
000132  f1a80801          SUB      r8,r8,#1              ;829
                  |L3.310|
000136  f1b80f00          CMP      r8,#0                 ;829
00013a  dab3              BGE      |L3.164|
00013c  1c40              ADDS     r0,r0,#1              ;812
                  |L3.318|
00013e  f8ddb248          LDR      r11,[sp,#0x248]       ;812
000142  4558              CMP      r0,r11                ;812
000144  f6ffaf6d          BLT      |L3.34|
;;;850        }
;;;851      }
;;;852    }
000148  f50d7d09          ADD      sp,sp,#0x224
00014c  e8bd8ff0          POP      {r4-r11,pc}
;;;853    
                          ENDP


                          AREA ||i.find_biggest_color_pop||, CODE, READONLY, ALIGN=1

                  find_biggest_color_pop PROC
;;;273    LOCAL(boxptr)
;;;274    find_biggest_color_pop (boxptr boxlist, int numboxes)
000000  b570              PUSH     {r4-r6,lr}
;;;275    /* Find the splittable box with the largest color population */
;;;276    /* Returns NULL if no splittable boxes remain */
;;;277    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;278      register boxptr boxp;
;;;279      register int i;
;;;280      register long maxc = 0;
000006  2500              MOVS     r5,#0
;;;281      boxptr which = NULL;
000008  2000              MOVS     r0,#0
;;;282      
;;;283      for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
00000a  2400              MOVS     r4,#0
00000c  4611              MOV      r1,r2
00000e  e009              B        |L4.36|
                  |L4.16|
;;;284        if (boxp->colorcount > maxc && boxp->volume > 0) {
000010  69ce              LDR      r6,[r1,#0x1c]
000012  42ae              CMP      r6,r5
000014  dd04              BLE      |L4.32|
000016  698e              LDR      r6,[r1,#0x18]
000018  2e00              CMP      r6,#0
00001a  dd01              BLE      |L4.32|
;;;285          which = boxp;
00001c  4608              MOV      r0,r1
;;;286          maxc = boxp->colorcount;
00001e  69cd              LDR      r5,[r1,#0x1c]
                  |L4.32|
000020  1c64              ADDS     r4,r4,#1              ;283
000022  3120              ADDS     r1,r1,#0x20           ;283
                  |L4.36|
000024  429c              CMP      r4,r3                 ;283
000026  dbf3              BLT      |L4.16|
;;;287        }
;;;288      }
;;;289      return which;
;;;290    }
000028  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP


                          AREA ||i.find_biggest_volume||, CODE, READONLY, ALIGN=1

                  find_biggest_volume PROC
;;;293    LOCAL(boxptr)
;;;294    find_biggest_volume (boxptr boxlist, int numboxes)
000000  b570              PUSH     {r4-r6,lr}
;;;295    /* Find the splittable box with the largest (scaled) volume */
;;;296    /* Returns NULL if no splittable boxes remain */
;;;297    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;298      register boxptr boxp;
;;;299      register int i;
;;;300      register INT32 maxv = 0;
000006  2500              MOVS     r5,#0
;;;301      boxptr which = NULL;
000008  2000              MOVS     r0,#0
;;;302      
;;;303      for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
00000a  2400              MOVS     r4,#0
00000c  4611              MOV      r1,r2
00000e  e006              B        |L5.30|
                  |L5.16|
;;;304        if (boxp->volume > maxv) {
000010  698e              LDR      r6,[r1,#0x18]
000012  42ae              CMP      r6,r5
000014  dd01              BLE      |L5.26|
;;;305          which = boxp;
000016  4608              MOV      r0,r1
;;;306          maxv = boxp->volume;
000018  698d              LDR      r5,[r1,#0x18]
                  |L5.26|
00001a  1c64              ADDS     r4,r4,#1              ;303
00001c  3120              ADDS     r1,r1,#0x20           ;303
                  |L5.30|
00001e  429c              CMP      r4,r3                 ;303
000020  dbf6              BLT      |L5.16|
;;;307        }
;;;308      }
;;;309      return which;
;;;310    }
000022  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP


                          AREA ||i.find_nearby_colors||, CODE, READONLY, ALIGN=1

                  find_nearby_colors PROC
;;;646    LOCAL(int)
;;;647    find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;648    		    JSAMPLE colorlist[])
;;;649    /* Locate the colormap entries close enough to an update box to be candidates
;;;650     * for the nearest entry to some cell(s) in the update box.  The update box
;;;651     * is specified by the center coordinates of its first cell.  The number of
;;;652     * candidate colormap entries is returned, and their colormap indexes are
;;;653     * placed in colorlist[].
;;;654     * This routine uses Heckbert's "locally sorted search" criterion to select
;;;655     * the colors that need further consideration.
;;;656     */
;;;657    {
000004  f5ad6d83          SUB      sp,sp,#0x418
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;658      int numcolors = cinfo->actual_number_of_colors;
00000e  f8dd0418          LDR      r0,[sp,#0x418]
000012  f8d00084          LDR      r0,[r0,#0x84]
000016  f8cd0414          STR      r0,[sp,#0x414]
;;;659      int maxc0, maxc1, maxc2;
;;;660      int centerc0, centerc1, centerc2;
;;;661      int i, x, ncolors;
;;;662      INT32 minmaxdist, min_dist, max_dist, tdist;
;;;663      INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */
;;;664    
;;;665      /* Compute true coordinates of update box's upper corner and center.
;;;666       * Actually we compute the coordinates of the center of the upper-corner
;;;667       * histogram cell, which are the upper bounds of the volume we care about.
;;;668       * Note that since ">>" rounds down, the "center" values may be closer to
;;;669       * min than to max; hence comparisons to them must be "<=", not "<".
;;;670       */
;;;671      maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
00001a  f1050c18          ADD      r12,r5,#0x18
;;;672      centerc0 = (minc0 + maxc0) >> 1;
00001e  eb05000c          ADD      r0,r5,r12
000022  1040              ASRS     r0,r0,#1
000024  f8cd0410          STR      r0,[sp,#0x410]
;;;673      maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
000028  f106081c          ADD      r8,r6,#0x1c
;;;674      centerc1 = (minc1 + maxc1) >> 1;
00002c  eb060008          ADD      r0,r6,r8
000030  1040              ASRS     r0,r0,#1
000032  f8cd040c          STR      r0,[sp,#0x40c]
;;;675      maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
000036  f1070918          ADD      r9,r7,#0x18
;;;676      centerc2 = (minc2 + maxc2) >> 1;
00003a  eb070009          ADD      r0,r7,r9
00003e  1040              ASRS     r0,r0,#1
000040  f8cd0408          STR      r0,[sp,#0x408]
;;;677    
;;;678      /* For each color in colormap, find:
;;;679       *  1. its minimum squared-distance to any point in the update box
;;;680       *     (zero if color is within update box);
;;;681       *  2. its maximum squared-distance to any point in the update box.
;;;682       * Both of these can be found by considering only the corners of the box.
;;;683       * We save the minimum distance for each color in mindist[];
;;;684       * only the smallest maximum distance is of interest.
;;;685       */
;;;686      minmaxdist = 0x7FFFFFFFL;
000044  f06f4000          MVN      r0,#0x80000000
000048  f8cd0400          STR      r0,[sp,#0x400]
;;;687    
;;;688      for (i = 0; i < numcolors; i++) {
00004c  2300              MOVS     r3,#0
00004e  e08e              B        |L6.366|
                  |L6.80|
;;;689        /* We compute the squared-c0-distance term, then add in the other two. */
;;;690        x = GETJSAMPLE(cinfo->colormap[0][i]);
000050  f8dd0418          LDR      r0,[sp,#0x418]
000054  f8d00088          LDR      r0,[r0,#0x88]
000058  6800              LDR      r0,[r0,#0]
00005a  5cc2              LDRB     r2,[r0,r3]
;;;691        if (x < minc0) {
00005c  42aa              CMP      r2,r5
00005e  da09              BGE      |L6.116|
;;;692          tdist = (x - minc0) * C0_SCALE;
000060  1b50              SUBS     r0,r2,r5
000062  0041              LSLS     r1,r0,#1
;;;693          min_dist = tdist*tdist;
000064  fb01fa01          MUL      r10,r1,r1
;;;694          tdist = (x - maxc0) * C0_SCALE;
000068  eba2000c          SUB      r0,r2,r12
00006c  0041              LSLS     r1,r0,#1
;;;695          max_dist = tdist*tdist;
00006e  fb01f401          MUL      r4,r1,r1
000072  e01b              B        |L6.172|
                  |L6.116|
;;;696        } else if (x > maxc0) {
000074  4562              CMP      r2,r12
000076  dd09              BLE      |L6.140|
;;;697          tdist = (x - maxc0) * C0_SCALE;
000078  eba2000c          SUB      r0,r2,r12
00007c  0041              LSLS     r1,r0,#1
;;;698          min_dist = tdist*tdist;
00007e  fb01fa01          MUL      r10,r1,r1
;;;699          tdist = (x - minc0) * C0_SCALE;
000082  1b50              SUBS     r0,r2,r5
000084  0041              LSLS     r1,r0,#1
;;;700          max_dist = tdist*tdist;
000086  fb01f401          MUL      r4,r1,r1
00008a  e00f              B        |L6.172|
                  |L6.140|
;;;701        } else {
;;;702          /* within cell range so no contribution to min_dist */
;;;703          min_dist = 0;
00008c  f04f0a00          MOV      r10,#0
;;;704          if (x <= centerc0) {
000090  f8dd0410          LDR      r0,[sp,#0x410]
000094  4282              CMP      r2,r0
000096  dc05              BGT      |L6.164|
;;;705    	tdist = (x - maxc0) * C0_SCALE;
000098  eba2000c          SUB      r0,r2,r12
00009c  0041              LSLS     r1,r0,#1
;;;706    	max_dist = tdist*tdist;
00009e  fb01f401          MUL      r4,r1,r1
0000a2  e003              B        |L6.172|
                  |L6.164|
;;;707          } else {
;;;708    	tdist = (x - minc0) * C0_SCALE;
0000a4  1b50              SUBS     r0,r2,r5
0000a6  0041              LSLS     r1,r0,#1
;;;709    	max_dist = tdist*tdist;
0000a8  fb01f401          MUL      r4,r1,r1
                  |L6.172|
;;;710          }
;;;711        }
;;;712    
;;;713        x = GETJSAMPLE(cinfo->colormap[1][i]);
0000ac  f8dd0418          LDR      r0,[sp,#0x418]
0000b0  f8d00088          LDR      r0,[r0,#0x88]
0000b4  6840              LDR      r0,[r0,#4]
0000b6  5cc2              LDRB     r2,[r0,r3]
;;;714        if (x < minc1) {
0000b8  42b2              CMP      r2,r6
0000ba  da0b              BGE      |L6.212|
;;;715          tdist = (x - minc1) * C1_SCALE;
0000bc  1b90              SUBS     r0,r2,r6
0000be  eb000140          ADD      r1,r0,r0,LSL #1
;;;716          min_dist += tdist*tdist;
0000c2  fb01aa01          MLA      r10,r1,r1,r10
;;;717          tdist = (x - maxc1) * C1_SCALE;
0000c6  eba20008          SUB      r0,r2,r8
0000ca  eb000140          ADD      r1,r0,r0,LSL #1
;;;718          max_dist += tdist*tdist;
0000ce  fb014401          MLA      r4,r1,r1,r4
0000d2  e01d              B        |L6.272|
                  |L6.212|
;;;719        } else if (x > maxc1) {
0000d4  4542              CMP      r2,r8
0000d6  dd0b              BLE      |L6.240|
;;;720          tdist = (x - maxc1) * C1_SCALE;
0000d8  eba20008          SUB      r0,r2,r8
0000dc  eb000140          ADD      r1,r0,r0,LSL #1
;;;721          min_dist += tdist*tdist;
0000e0  fb01aa01          MLA      r10,r1,r1,r10
;;;722          tdist = (x - minc1) * C1_SCALE;
0000e4  1b90              SUBS     r0,r2,r6
0000e6  eb000140          ADD      r1,r0,r0,LSL #1
;;;723          max_dist += tdist*tdist;
0000ea  fb014401          MLA      r4,r1,r1,r4
0000ee  e00f              B        |L6.272|
                  |L6.240|
;;;724        } else {
;;;725          /* within cell range so no contribution to min_dist */
;;;726          if (x <= centerc1) {
0000f0  f8dd040c          LDR      r0,[sp,#0x40c]
0000f4  4282              CMP      r2,r0
0000f6  dc06              BGT      |L6.262|
;;;727    	tdist = (x - maxc1) * C1_SCALE;
0000f8  eba20008          SUB      r0,r2,r8
0000fc  eb000140          ADD      r1,r0,r0,LSL #1
;;;728    	max_dist += tdist*tdist;
000100  fb014401          MLA      r4,r1,r1,r4
000104  e004              B        |L6.272|
                  |L6.262|
;;;729          } else {
;;;730    	tdist = (x - minc1) * C1_SCALE;
000106  1b90              SUBS     r0,r2,r6
000108  eb000140          ADD      r1,r0,r0,LSL #1
;;;731    	max_dist += tdist*tdist;
00010c  fb014401          MLA      r4,r1,r1,r4
                  |L6.272|
;;;732          }
;;;733        }
;;;734    
;;;735        x = GETJSAMPLE(cinfo->colormap[2][i]);
000110  f8dd0418          LDR      r0,[sp,#0x418]
000114  f8d00088          LDR      r0,[r0,#0x88]
000118  6880              LDR      r0,[r0,#8]
00011a  5cc2              LDRB     r2,[r0,r3]
;;;736        if (x < minc2) {
00011c  42ba              CMP      r2,r7
00011e  da07              BGE      |L6.304|
;;;737          tdist = (x - minc2) * C2_SCALE;
000120  1bd1              SUBS     r1,r2,r7
;;;738          min_dist += tdist*tdist;
000122  fb01aa01          MLA      r10,r1,r1,r10
;;;739          tdist = (x - maxc2) * C2_SCALE;
000126  eba20109          SUB      r1,r2,r9
;;;740          max_dist += tdist*tdist;
00012a  fb014401          MLA      r4,r1,r1,r4
00012e  e015              B        |L6.348|
                  |L6.304|
;;;741        } else if (x > maxc2) {
000130  454a              CMP      r2,r9
000132  dd07              BLE      |L6.324|
;;;742          tdist = (x - maxc2) * C2_SCALE;
000134  eba20109          SUB      r1,r2,r9
;;;743          min_dist += tdist*tdist;
000138  fb01aa01          MLA      r10,r1,r1,r10
;;;744          tdist = (x - minc2) * C2_SCALE;
00013c  1bd1              SUBS     r1,r2,r7
;;;745          max_dist += tdist*tdist;
00013e  fb014401          MLA      r4,r1,r1,r4
000142  e00b              B        |L6.348|
                  |L6.324|
;;;746        } else {
;;;747          /* within cell range so no contribution to min_dist */
;;;748          if (x <= centerc2) {
000144  f8dd0408          LDR      r0,[sp,#0x408]
000148  4282              CMP      r2,r0
00014a  dc04              BGT      |L6.342|
;;;749    	tdist = (x - maxc2) * C2_SCALE;
00014c  eba20109          SUB      r1,r2,r9
;;;750    	max_dist += tdist*tdist;
000150  fb014401          MLA      r4,r1,r1,r4
000154  e002              B        |L6.348|
                  |L6.342|
;;;751          } else {
;;;752    	tdist = (x - minc2) * C2_SCALE;
000156  1bd1              SUBS     r1,r2,r7
;;;753    	max_dist += tdist*tdist;
000158  fb014401          MLA      r4,r1,r1,r4
                  |L6.348|
;;;754          }
;;;755        }
;;;756    
;;;757        mindist[i] = min_dist;	/* save away the results */
00015c  f84da023          STR      r10,[sp,r3,LSL #2]
;;;758        if (max_dist < minmaxdist)
000160  f8dd0400          LDR      r0,[sp,#0x400]
000164  4284              CMP      r4,r0
000166  da01              BGE      |L6.364|
;;;759          minmaxdist = max_dist;
000168  f8cd4400          STR      r4,[sp,#0x400]
                  |L6.364|
00016c  1c5b              ADDS     r3,r3,#1              ;688
                  |L6.366|
00016e  f8dd0414          LDR      r0,[sp,#0x414]        ;688
000172  4283              CMP      r3,r0                 ;688
000174  f6ffaf6c          BLT      |L6.80|
;;;760      }
;;;761    
;;;762      /* Now we know that no cell in the update box is more than minmaxdist
;;;763       * away from some colormap entry.  Therefore, only colors that are
;;;764       * within minmaxdist of some part of the box need be considered.
;;;765       */
;;;766      ncolors = 0;
000178  2000              MOVS     r0,#0
00017a  f8cd0404          STR      r0,[sp,#0x404]
;;;767      for (i = 0; i < numcolors; i++) {
00017e  2300              MOVS     r3,#0
000180  e010              B        |L6.420|
                  |L6.386|
;;;768        if (mindist[i] <= minmaxdist)
000182  f85db023          LDR      r11,[sp,r3,LSL #2]
000186  f8dd0400          LDR      r0,[sp,#0x400]
00018a  4583              CMP      r11,r0
00018c  dc09              BGT      |L6.418|
;;;769          colorlist[ncolors++] = (JSAMPLE) i;
00018e  f8dd0404          LDR      r0,[sp,#0x404]
000192  f1000e01          ADD      lr,r0,#1
000196  f8cde404          STR      lr,[sp,#0x404]
00019a  f8dde44c          LDR      lr,[sp,#0x44c]
00019e  f80e3000          STRB     r3,[lr,r0]
                  |L6.418|
0001a2  1c5b              ADDS     r3,r3,#1              ;767
                  |L6.420|
0001a4  f8dd0414          LDR      r0,[sp,#0x414]        ;767
0001a8  4283              CMP      r3,r0                 ;767
0001aa  dbea              BLT      |L6.386|
;;;770      }
;;;771      return ncolors;
0001ac  f8dd0404          LDR      r0,[sp,#0x404]
;;;772    }
0001b0  f50d6d85          ADD      sp,sp,#0x428
0001b4  e8bd8ff0          POP      {r4-r11,pc}
;;;773    
                          ENDP


                          AREA ||i.finish_pass1||, CODE, READONLY, ALIGN=1

                  finish_pass1 PROC
;;;1143   METHODDEF(void)
;;;1144   finish_pass1 (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;1145   {
000002  4604              MOV      r4,r0
;;;1146     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000004  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;1147   
;;;1148     /* Select the representative colors and fill in cinfo->colormap */
;;;1149     cinfo->colormap = cquantize->sv_colormap;
000008  6928              LDR      r0,[r5,#0x10]
00000a  f8c40088          STR      r0,[r4,#0x88]
;;;1150     select_colors(cinfo, cquantize->desired);
00000e  4620              MOV      r0,r4
000010  6969              LDR      r1,[r5,#0x14]
000012  f7fffffe          BL       select_colors
;;;1151     /* Force next pass to zero the color index table */
;;;1152     cquantize->needs_zeroed = TRUE;
000016  2001              MOVS     r0,#1
000018  61e8              STR      r0,[r5,#0x1c]
;;;1153   }
00001a  bd70              POP      {r4-r6,pc}
;;;1154   
                          ENDP


                          AREA ||i.finish_pass2||, CODE, READONLY, ALIGN=1

                  finish_pass2 PROC
;;;1156   METHODDEF(void)
;;;1157   finish_pass2 (j_decompress_ptr cinfo)
000000  bf00              NOP      
;;;1158   {
;;;1159     GUI_USE_PARA(cinfo);
;;;1160     /* no work */
;;;1161   }
000002  4770              BX       lr
;;;1162   
                          ENDP


                          AREA ||i.init_error_limit||, CODE, READONLY, ALIGN=1

                  init_error_limit PROC
;;;1108   LOCAL(void)
;;;1109   init_error_limit (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1110   /* Allocate and fill in the error_limiter table */
;;;1111   {
000004  4607              MOV      r7,r0
;;;1112     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  f8d781cc          LDR      r8,[r7,#0x1cc]
;;;1113     int * table;
;;;1114     int in, out;
;;;1115   
;;;1116     table = (int *) (*cinfo->mem->alloc_small)
00000a  6878              LDR      r0,[r7,#4]
00000c  f24072fc          MOV      r2,#0x7fc
000010  2101              MOVS     r1,#1
000012  6803              LDR      r3,[r0,#0]
000014  4638              MOV      r0,r7
000016  4798              BLX      r3
000018  4605              MOV      r5,r0
;;;1117       ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
;;;1118     table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
00001a  f505757f          ADD      r5,r5,#0x3fc
;;;1119     cquantize->error_limiter = table;
00001e  f8c85028          STR      r5,[r8,#0x28]
;;;1120   
;;;1121   #define STEPSIZE ((MAXJSAMPLE+1)/16)
;;;1122     /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
;;;1123     out = 0;
000022  2600              MOVS     r6,#0
;;;1124     for (in = 0; in < STEPSIZE; in++, out++) {
000024  2400              MOVS     r4,#0
000026  e007              B        |L9.56|
                  |L9.40|
;;;1125       table[in] = out; table[-in] = -out;
000028  f8456024          STR      r6,[r5,r4,LSL #2]
00002c  4270              RSBS     r0,r6,#0
00002e  4261              RSBS     r1,r4,#0
000030  f8450021          STR      r0,[r5,r1,LSL #2]
000034  1c64              ADDS     r4,r4,#1              ;1124
000036  1c76              ADDS     r6,r6,#1              ;1124
                  |L9.56|
000038  2c10              CMP      r4,#0x10              ;1124
00003a  dbf5              BLT      |L9.40|
;;;1126     }
;;;1127     /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
;;;1128     for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
00003c  e00b              B        |L9.86|
                  |L9.62|
;;;1129       table[in] = out; table[-in] = -out;
00003e  f8456024          STR      r6,[r5,r4,LSL #2]
000042  4270              RSBS     r0,r6,#0
000044  4261              RSBS     r1,r4,#0
000046  f8450021          STR      r0,[r5,r1,LSL #2]
00004a  1c64              ADDS     r4,r4,#1              ;1128
00004c  f0040001          AND      r0,r4,#1              ;1128
000050  f0800001          EOR      r0,r0,#1              ;1128
000054  4406              ADD      r6,r6,r0              ;1128
                  |L9.86|
000056  2c30              CMP      r4,#0x30              ;1128
000058  dbf1              BLT      |L9.62|
;;;1130     }
;;;1131     /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
;;;1132     for (; in <= MAXJSAMPLE; in++) {
00005a  e006              B        |L9.106|
                  |L9.92|
;;;1133       table[in] = out; table[-in] = -out;
00005c  f8456024          STR      r6,[r5,r4,LSL #2]
000060  4270              RSBS     r0,r6,#0
000062  4261              RSBS     r1,r4,#0
000064  f8450021          STR      r0,[r5,r1,LSL #2]
000068  1c64              ADDS     r4,r4,#1              ;1132
                  |L9.106|
00006a  2cff              CMP      r4,#0xff              ;1132
00006c  ddf6              BLE      |L9.92|
;;;1134     }
;;;1135   #undef STEPSIZE
;;;1136   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1137   
                          ENDP


                          AREA ||i.jinit_2pass_quantizer||, CODE, READONLY, ALIGN=2

                  jinit_2pass_quantizer PROC
;;;1245   GLOBAL(void)
;;;1246   jinit_2pass_quantizer (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1247   {
000004  4604              MOV      r4,r0
;;;1248     my_cquantize_ptr cquantize;
;;;1249     int i;
;;;1250   
;;;1251     cquantize = (my_cquantize_ptr)
000006  6860              LDR      r0,[r4,#4]
000008  222c              MOVS     r2,#0x2c
00000a  2101              MOVS     r1,#1
00000c  6803              LDR      r3,[r0,#0]
00000e  4620              MOV      r0,r4
000010  4798              BLX      r3
000012  4605              MOV      r5,r0
;;;1252       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1253   				SIZEOF(my_cquantizer));
;;;1254     cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
000014  f8c451cc          STR      r5,[r4,#0x1cc]
;;;1255     cquantize->pub.start_pass = start_pass_2_quant;
000018  4836              LDR      r0,|L10.244|
00001a  6028              STR      r0,[r5,#0]
;;;1256     cquantize->pub.new_color_map = new_color_map_2_quant;
00001c  4836              LDR      r0,|L10.248|
00001e  60e8              STR      r0,[r5,#0xc]
;;;1257     cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
000020  2000              MOVS     r0,#0
000022  6228              STR      r0,[r5,#0x20]
;;;1258     cquantize->error_limiter = NULL;
000024  62a8              STR      r0,[r5,#0x28]
;;;1259   
;;;1260     /* Make sure jdmaster didn't give me a case I can't handle */
;;;1261     if (cinfo->out_color_components != 3)
000026  6fa0              LDR      r0,[r4,#0x78]
000028  2803              CMP      r0,#3
00002a  d006              BEQ      |L10.58|
;;;1262       ERREXIT(cinfo, JERR_NOTIMPL);
00002c  202f              MOVS     r0,#0x2f
00002e  6821              LDR      r1,[r4,#0]
000030  6148              STR      r0,[r1,#0x14]
000032  6820              LDR      r0,[r4,#0]
000034  6801              LDR      r1,[r0,#0]
000036  4620              MOV      r0,r4
000038  4788              BLX      r1
                  |L10.58|
;;;1263   
;;;1264     /* Allocate the histogram/inverse colormap storage */
;;;1265     cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
00003a  6860              LDR      r0,[r4,#4]
00003c  2280              MOVS     r2,#0x80
00003e  2101              MOVS     r1,#1
000040  6803              LDR      r3,[r0,#0]
000042  4620              MOV      r0,r4
000044  4798              BLX      r3
000046  61a8              STR      r0,[r5,#0x18]
;;;1266       ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
;;;1267     for (i = 0; i < HIST_C0_ELEMS; i++) {
000048  2600              MOVS     r6,#0
00004a  e00a              B        |L10.98|
                  |L10.76|
;;;1268       cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
00004c  6860              LDR      r0,[r4,#4]
00004e  f44f5280          MOV      r2,#0x1000
000052  2101              MOVS     r1,#1
000054  6843              LDR      r3,[r0,#4]
000056  4620              MOV      r0,r4
000058  4798              BLX      r3
00005a  69a9              LDR      r1,[r5,#0x18]
00005c  f8410026          STR      r0,[r1,r6,LSL #2]
000060  1c76              ADDS     r6,r6,#1              ;1267
                  |L10.98|
000062  2e20              CMP      r6,#0x20              ;1267
000064  dbf2              BLT      |L10.76|
;;;1269         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1270          HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1271     }
;;;1272     cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
000066  2001              MOVS     r0,#1
000068  61e8              STR      r0,[r5,#0x1c]
;;;1273   
;;;1274     /* Allocate storage for the completed colormap, if required.
;;;1275      * We do this now since it is FAR storage and may affect
;;;1276      * the memory manager's space calculations.
;;;1277      */
;;;1278     if (cinfo->enable_2pass_quant) {
00006a  6ee0              LDR      r0,[r4,#0x6c]
00006c  b328              CBZ      r0,|L10.186|
;;;1279       /* Make sure color count is acceptable */
;;;1280       int desired = cinfo->desired_number_of_colors;
00006e  6e27              LDR      r7,[r4,#0x60]
;;;1281       /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
;;;1282       if (desired < 8)
000070  2f08              CMP      r7,#8
000072  da09              BGE      |L10.136|
;;;1283         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
000074  2038              MOVS     r0,#0x38
000076  6821              LDR      r1,[r4,#0]
000078  6148              STR      r0,[r1,#0x14]
00007a  2008              MOVS     r0,#8
00007c  6821              LDR      r1,[r4,#0]
00007e  6188              STR      r0,[r1,#0x18]
000080  6820              LDR      r0,[r4,#0]
000082  6801              LDR      r1,[r0,#0]
000084  4620              MOV      r0,r4
000086  4788              BLX      r1
                  |L10.136|
;;;1284       /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;1285       if (desired > MAXNUMCOLORS)
000088  f5b77f80          CMP      r7,#0x100
00008c  dd0a              BLE      |L10.164|
;;;1286         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
00008e  2039              MOVS     r0,#0x39
000090  6821              LDR      r1,[r4,#0]
000092  6148              STR      r0,[r1,#0x14]
000094  f44f7080          MOV      r0,#0x100
000098  6821              LDR      r1,[r4,#0]
00009a  6188              STR      r0,[r1,#0x18]
00009c  6820              LDR      r0,[r4,#0]
00009e  6801              LDR      r1,[r0,#0]
0000a0  4620              MOV      r0,r4
0000a2  4788              BLX      r1
                  |L10.164|
;;;1287       cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
0000a4  6860              LDR      r0,[r4,#4]
0000a6  2303              MOVS     r3,#3
0000a8  463a              MOV      r2,r7
0000aa  2101              MOVS     r1,#1
0000ac  f8d0c008          LDR      r12,[r0,#8]
0000b0  4620              MOV      r0,r4
0000b2  47e0              BLX      r12
0000b4  6128              STR      r0,[r5,#0x10]
;;;1288         ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
;;;1289       cquantize->desired = desired;
0000b6  616f              STR      r7,[r5,#0x14]
;;;1290     } else
0000b8  e001              B        |L10.190|
                  |L10.186|
;;;1291       cquantize->sv_colormap = NULL;
0000ba  2000              MOVS     r0,#0
0000bc  6128              STR      r0,[r5,#0x10]
                  |L10.190|
;;;1292   
;;;1293     /* Only F-S dithering or no dithering is supported. */
;;;1294     /* If user asks for ordered dither, give him F-S. */
;;;1295     if (cinfo->dither_mode != JDITHER_NONE)
0000be  f8940058          LDRB     r0,[r4,#0x58]
0000c2  b110              CBZ      r0,|L10.202|
;;;1296       cinfo->dither_mode = JDITHER_FS;
0000c4  2002              MOVS     r0,#2
0000c6  f8840058          STRB     r0,[r4,#0x58]
                  |L10.202|
;;;1297   
;;;1298     /* Allocate Floyd-Steinberg workspace if necessary.
;;;1299      * This isn't really needed until pass 2, but again it is FAR storage.
;;;1300      * Although we will cope with a later change in dither_mode,
;;;1301      * we do not promise to honor max_memory_to_use if dither_mode changes.
;;;1302      */
;;;1303     if (cinfo->dither_mode == JDITHER_FS) {
0000ca  f8940058          LDRB     r0,[r4,#0x58]
0000ce  2802              CMP      r0,#2
0000d0  d10d              BNE      |L10.238|
;;;1304       cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
0000d2  6f20              LDR      r0,[r4,#0x70]
0000d4  1c80              ADDS     r0,r0,#2
0000d6  eb000040          ADD      r0,r0,r0,LSL #1
0000da  0042              LSLS     r2,r0,#1
0000dc  6860              LDR      r0,[r4,#4]
0000de  2101              MOVS     r1,#1
0000e0  6843              LDR      r3,[r0,#4]
0000e2  4620              MOV      r0,r4
0000e4  4798              BLX      r3
0000e6  6228              STR      r0,[r5,#0x20]
;;;1305         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1306          (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
;;;1307       /* Might as well create the error-limiting table too. */
;;;1308       init_error_limit(cinfo);
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       init_error_limit
                  |L10.238|
;;;1309     }
;;;1310   }
0000ee  e8bd81f0          POP      {r4-r8,pc}
;;;1311   
                          ENDP

0000f2  0000              DCW      0x0000
                  |L10.244|
                          DCD      start_pass_2_quant
                  |L10.248|
                          DCD      new_color_map_2_quant

                          AREA ||i.median_cut||, CODE, READONLY, ALIGN=1

                  median_cut PROC
;;;424    LOCAL(int)
;;;425    median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;426    	    int desired_colors)
;;;427    /* Repeatedly select and split the largest box until we have enough boxes */
;;;428    {
000004  b083              SUB      sp,sp,#0xc
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;429      int n,lb;
;;;430      int c0,c1,c2,cmax;
;;;431      register boxptr b1,b2;
;;;432    
;;;433      while (numboxes < desired_colors) {
00000c  e06d              B        |L11.234|
                  |L11.14|
;;;434        /* Select box to split.
;;;435         * Current algorithm: by population for first half, then by volume.
;;;436         */
;;;437        if (numboxes*2 <= desired_colors) {
00000e  ebb90f46          CMP      r9,r6,LSL #1
000012  db05              BLT      |L11.32|
;;;438          b1 = find_biggest_color_pop(boxlist, numboxes);
000014  4631              MOV      r1,r6
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       find_biggest_color_pop
00001c  4604              MOV      r4,r0
00001e  e004              B        |L11.42|
                  |L11.32|
;;;439        } else {
;;;440          b1 = find_biggest_volume(boxlist, numboxes);
000020  4631              MOV      r1,r6
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       find_biggest_volume
000028  4604              MOV      r4,r0
                  |L11.42|
;;;441        }
;;;442        if (b1 == NULL)		/* no splittable boxes left! */
00002a  b904              CBNZ     r4,|L11.46|
;;;443          break;
00002c  e05f              B        |L11.238|
                  |L11.46|
;;;444        b2 = &boxlist[numboxes];	/* where new box will go */
00002e  eb081546          ADD      r5,r8,r6,LSL #5
;;;445        /* Copy the color bounds to the new box. */
;;;446        b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
000032  6860              LDR      r0,[r4,#4]
000034  6068              STR      r0,[r5,#4]
000036  68e0              LDR      r0,[r4,#0xc]
000038  60e8              STR      r0,[r5,#0xc]
00003a  6960              LDR      r0,[r4,#0x14]
00003c  6168              STR      r0,[r5,#0x14]
;;;447        b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
00003e  6820              LDR      r0,[r4,#0]
000040  6028              STR      r0,[r5,#0]
000042  68a0              LDR      r0,[r4,#8]
000044  60a8              STR      r0,[r5,#8]
000046  6920              LDR      r0,[r4,#0x10]
000048  6128              STR      r0,[r5,#0x10]
;;;448        /* Choose which axis to split the box on.
;;;449         * Current algorithm: longest scaled axis.
;;;450         * See notes in update_box about scaling distances.
;;;451         */
;;;452        c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
00004a  e9d41000          LDRD     r1,r0,[r4,#0]
00004e  1a40              SUBS     r0,r0,r1
000050  0100              LSLS     r0,r0,#4
000052  9001              STR      r0,[sp,#4]
;;;453        c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
000054  e9d41002          LDRD     r1,r0,[r4,#8]
000058  1a40              SUBS     r0,r0,r1
00005a  0080              LSLS     r0,r0,#2
00005c  eb000a40          ADD      r10,r0,r0,LSL #1
;;;454        c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
000060  e9d41004          LDRD     r1,r0,[r4,#0x10]
000064  1a40              SUBS     r0,r0,r1
000066  ea4f0bc0          LSL      r11,r0,#3
;;;455        /* We want to break any ties in favor of green, then red, blue last.
;;;456         * This code does the right thing for R,G,B or B,G,R color orders only.
;;;457         */
;;;458    #if RGB_RED == 0
;;;459        cmax = c1; n = 1;
00006a  f8cda000          STR      r10,[sp,#0]
00006e  2001              MOVS     r0,#1
000070  9002              STR      r0,[sp,#8]
;;;460        if (c0 > cmax) { cmax = c0; n = 0; }
000072  e9dda000          LDRD     r10,r0,[sp,#0]
000076  4550              CMP      r0,r10
000078  dd03              BLE      |L11.130|
00007a  9801              LDR      r0,[sp,#4]
00007c  9000              STR      r0,[sp,#0]
00007e  2000              MOVS     r0,#0
000080  9002              STR      r0,[sp,#8]
                  |L11.130|
;;;461        if (c2 > cmax) { n = 2; }
000082  9800              LDR      r0,[sp,#0]
000084  4583              CMP      r11,r0
000086  dd01              BLE      |L11.140|
000088  2002              MOVS     r0,#2
00008a  9002              STR      r0,[sp,#8]
                  |L11.140|
;;;462    #else
;;;463        cmax = c1; n = 1;
;;;464        if (c2 > cmax) { cmax = c2; n = 2; }
;;;465        if (c0 > cmax) { n = 0; }
;;;466    #endif
;;;467        /* Choose split point along selected axis, and update box bounds.
;;;468         * Current algorithm: split at halfway point.
;;;469         * (Since the box has been shrunk to minimum volume,
;;;470         * any split will produce two nonempty subboxes.)
;;;471         * Note that lb value is max for lower box, so must be < old max.
;;;472         */
;;;473        switch (n) {
00008c  9802              LDR      r0,[sp,#8]
00008e  b120              CBZ      r0,|L11.154|
000090  2801              CMP      r0,#1
000092  d00c              BEQ      |L11.174|
000094  2802              CMP      r0,#2
000096  d11e              BNE      |L11.214|
000098  e013              B        |L11.194|
                  |L11.154|
;;;474        case 0:
;;;475          lb = (b1->c0max + b1->c0min) / 2;
00009a  e9d42100          LDRD     r2,r1,[r4,#0]
00009e  1888              ADDS     r0,r1,r2
0000a0  eb0071d0          ADD      r1,r0,r0,LSR #31
0000a4  104f              ASRS     r7,r1,#1
;;;476          b1->c0max = lb;
0000a6  6067              STR      r7,[r4,#4]
;;;477          b2->c0min = lb+1;
0000a8  1c78              ADDS     r0,r7,#1
0000aa  6028              STR      r0,[r5,#0]
;;;478          break;
0000ac  e013              B        |L11.214|
                  |L11.174|
;;;479        case 1:
;;;480          lb = (b1->c1max + b1->c1min) / 2;
0000ae  e9d42102          LDRD     r2,r1,[r4,#8]
0000b2  1888              ADDS     r0,r1,r2
0000b4  eb0071d0          ADD      r1,r0,r0,LSR #31
0000b8  104f              ASRS     r7,r1,#1
;;;481          b1->c1max = lb;
0000ba  60e7              STR      r7,[r4,#0xc]
;;;482          b2->c1min = lb+1;
0000bc  1c78              ADDS     r0,r7,#1
0000be  60a8              STR      r0,[r5,#8]
;;;483          break;
0000c0  e009              B        |L11.214|
                  |L11.194|
;;;484        case 2:
;;;485          lb = (b1->c2max + b1->c2min) / 2;
0000c2  e9d42104          LDRD     r2,r1,[r4,#0x10]
0000c6  1888              ADDS     r0,r1,r2
0000c8  eb0071d0          ADD      r1,r0,r0,LSR #31
0000cc  104f              ASRS     r7,r1,#1
;;;486          b1->c2max = lb;
0000ce  6167              STR      r7,[r4,#0x14]
;;;487          b2->c2min = lb+1;
0000d0  1c78              ADDS     r0,r7,#1
0000d2  6128              STR      r0,[r5,#0x10]
;;;488          break;
0000d4  bf00              NOP      
                  |L11.214|
0000d6  bf00              NOP                            ;478
;;;489        }
;;;490        /* Update stats for boxes */
;;;491        update_box(cinfo, b1);
0000d8  4621              MOV      r1,r4
0000da  9803              LDR      r0,[sp,#0xc]
0000dc  f7fffffe          BL       update_box
;;;492        update_box(cinfo, b2);
0000e0  4629              MOV      r1,r5
0000e2  9803              LDR      r0,[sp,#0xc]
0000e4  f7fffffe          BL       update_box
;;;493        numboxes++;
0000e8  1c76              ADDS     r6,r6,#1
                  |L11.234|
0000ea  454e              CMP      r6,r9                 ;433
0000ec  db8f              BLT      |L11.14|
                  |L11.238|
0000ee  bf00              NOP                            ;443
;;;494      }
;;;495      return numboxes;
0000f0  4630              MOV      r0,r6
;;;496    }
0000f2  b007              ADD      sp,sp,#0x1c
0000f4  e8bd8ff0          POP      {r4-r11,pc}
;;;497    
                          ENDP


                          AREA ||i.new_color_map_2_quant||, CODE, READONLY, ALIGN=1

                  new_color_map_2_quant PROC
;;;1231   METHODDEF(void)
;;;1232   new_color_map_2_quant (j_decompress_ptr cinfo)
000000  f8d011cc          LDR      r1,[r0,#0x1cc]
;;;1233   {
;;;1234     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1235   
;;;1236     /* Reset the inverse color map */
;;;1237     cquantize->needs_zeroed = TRUE;
000004  2201              MOVS     r2,#1
000006  61ca              STR      r2,[r1,#0x1c]
;;;1238   }
000008  4770              BX       lr
;;;1239   
                          ENDP


                          AREA ||i.pass2_fs_dither||, CODE, READONLY, ALIGN=1

                  pass2_fs_dither PROC
;;;949    METHODDEF(void)
;;;950    pass2_fs_dither (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;951    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;952    /* This version performs Floyd-Steinberg dithering */
;;;953    {
000004  b093              SUB      sp,sp,#0x4c
000006  4680              MOV      r8,r0
;;;954      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8d891cc          LDR      r9,[r8,#0x1cc]
;;;955      hist3d histogram = cquantize->histogram;
00000c  f8d90018          LDR      r0,[r9,#0x18]
000010  9012              STR      r0,[sp,#0x48]
;;;956      register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
;;;957      LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
;;;958      LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
;;;959      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;960      JSAMPROW inptr;		/* => current input pixel */
;;;961      JSAMPROW outptr;		/* => current output pixel */
;;;962      histptr cachep;
;;;963      int dir;			/* +1 or -1 depending on direction */
;;;964      int dir3;			/* 3*dir, for advancing inptr & errorptr */
;;;965      int row;
;;;966      JDIMENSION col;
;;;967      JDIMENSION width = cinfo->output_width;
000012  f8d80070          LDR      r0,[r8,#0x70]
000016  9006              STR      r0,[sp,#0x18]
;;;968      JSAMPLE *range_limit = cinfo->sample_range_limit;
000018  f8d80144          LDR      r0,[r8,#0x144]
00001c  9005              STR      r0,[sp,#0x14]
;;;969      int *error_limit = cquantize->error_limiter;
00001e  f8d90028          LDR      r0,[r9,#0x28]
000022  9004              STR      r0,[sp,#0x10]
;;;970      JSAMPROW colormap0 = cinfo->colormap[0];
000024  f8d80088          LDR      r0,[r8,#0x88]
000028  6800              LDR      r0,[r0,#0]
00002a  9003              STR      r0,[sp,#0xc]
;;;971      JSAMPROW colormap1 = cinfo->colormap[1];
00002c  f8d80088          LDR      r0,[r8,#0x88]
000030  6840              LDR      r0,[r0,#4]
000032  9002              STR      r0,[sp,#8]
;;;972      JSAMPROW colormap2 = cinfo->colormap[2];
000034  f8d80088          LDR      r0,[r8,#0x88]
000038  6880              LDR      r0,[r0,#8]
00003a  9001              STR      r0,[sp,#4]
;;;973      SHIFT_TEMPS
;;;974    
;;;975      for (row = 0; row < num_rows; row++) {
00003c  2000              MOVS     r0,#0
00003e  9008              STR      r0,[sp,#0x20]
000040  e0c9              B        |L13.470|
                  |L13.66|
;;;976        inptr = input_buf[row];
000042  9908              LDR      r1,[sp,#0x20]
000044  9814              LDR      r0,[sp,#0x50]
000046  f850b021          LDR      r11,[r0,r1,LSL #2]
;;;977        outptr = output_buf[row];
00004a  9908              LDR      r1,[sp,#0x20]
00004c  9815              LDR      r0,[sp,#0x54]
00004e  f8500021          LDR      r0,[r0,r1,LSL #2]
000052  900b              STR      r0,[sp,#0x2c]
;;;978        if (cquantize->on_odd_row) {
000054  f8d90024          LDR      r0,[r9,#0x24]
000058  b1d0              CBZ      r0,|L13.144|
;;;979          /* work right to left in this row */
;;;980          inptr += (width-1) * 3;	/* so point to rightmost pixel */
00005a  9806              LDR      r0,[sp,#0x18]
00005c  1e40              SUBS     r0,r0,#1
00005e  eb000040          ADD      r0,r0,r0,LSL #1
000062  4483              ADD      r11,r11,r0
;;;981          outptr += width-1;
000064  9806              LDR      r0,[sp,#0x18]
000066  1e40              SUBS     r0,r0,#1
000068  990b              LDR      r1,[sp,#0x2c]
00006a  4408              ADD      r0,r0,r1
00006c  900b              STR      r0,[sp,#0x2c]
;;;982          dir = -1;
00006e  f04f30ff          MOV      r0,#0xffffffff
000072  9009              STR      r0,[sp,#0x24]
;;;983          dir3 = -3;
000074  f06f0a02          MVN      r10,#2
;;;984          errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
000078  f8d91020          LDR      r1,[r9,#0x20]
00007c  9806              LDR      r0,[sp,#0x18]
00007e  1c40              ADDS     r0,r0,#1
000080  eb000040          ADD      r0,r0,r0,LSL #1
000084  eb010740          ADD      r7,r1,r0,LSL #1
;;;985          cquantize->on_odd_row = FALSE; /* flip for next time */
000088  2000              MOVS     r0,#0
00008a  f8c90024          STR      r0,[r9,#0x24]
00008e  e007              B        |L13.160|
                  |L13.144|
;;;986        } else {
;;;987          /* work left to right in this row */
;;;988          dir = 1;
000090  2001              MOVS     r0,#1
000092  9009              STR      r0,[sp,#0x24]
;;;989          dir3 = 3;
000094  f04f0a03          MOV      r10,#3
;;;990          errorptr = cquantize->fserrors; /* => entry before first real column */
000098  f8d97020          LDR      r7,[r9,#0x20]
;;;991          cquantize->on_odd_row = TRUE; /* flip for next time */
00009c  f8c90024          STR      r0,[r9,#0x24]
                  |L13.160|
;;;992        }
;;;993        /* Preset error values: no error propagated to first pixel from left */
;;;994        cur0 = cur1 = cur2 = 0;
0000a0  2000              MOVS     r0,#0
0000a2  4606              MOV      r6,r0
0000a4  4605              MOV      r5,r0
0000a6  4604              MOV      r4,r0
;;;995        /* and no error propagated to row below yet */
;;;996        belowerr0 = belowerr1 = belowerr2 = 0;
0000a8  900f              STR      r0,[sp,#0x3c]
0000aa  9010              STR      r0,[sp,#0x40]
0000ac  9011              STR      r0,[sp,#0x44]
;;;997        bpreverr0 = bpreverr1 = bpreverr2 = 0;
0000ae  900c              STR      r0,[sp,#0x30]
0000b0  900d              STR      r0,[sp,#0x34]
0000b2  900e              STR      r0,[sp,#0x38]
;;;998    
;;;999        for (col = width; col > 0; col--) {
0000b4  9806              LDR      r0,[sp,#0x18]
0000b6  9007              STR      r0,[sp,#0x1c]
0000b8  e07d              B        |L13.438|
                  |L13.186|
;;;1000         /* curN holds the error propagated from the previous pixel on the
;;;1001          * current line.  Add the error propagated from the previous line
;;;1002          * to form the complete error correction term for this pixel, and
;;;1003          * round the error term (which is expressed * 16) to an integer.
;;;1004          * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;1005          * for either sign of the error value.
;;;1006          * Note: errorptr points to *previous* column's array entry.
;;;1007          */
;;;1008         cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
0000ba  f937001a          LDRSH    r0,[r7,r10,LSL #1]
0000be  4420              ADD      r0,r0,r4
0000c0  3008              ADDS     r0,r0,#8
0000c2  1104              ASRS     r4,r0,#4
;;;1009         cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
0000c4  f10a0001          ADD      r0,r10,#1
0000c8  f9370010          LDRSH    r0,[r7,r0,LSL #1]
0000cc  4428              ADD      r0,r0,r5
0000ce  3008              ADDS     r0,r0,#8
0000d0  1105              ASRS     r5,r0,#4
;;;1010         cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
0000d2  f10a0002          ADD      r0,r10,#2
0000d6  f9370010          LDRSH    r0,[r7,r0,LSL #1]
0000da  4430              ADD      r0,r0,r6
0000dc  3008              ADDS     r0,r0,#8
0000de  1106              ASRS     r6,r0,#4
;;;1011         /* Limit the error using transfer function set by init_error_limit.
;;;1012          * See comments with init_error_limit for rationale.
;;;1013          */
;;;1014         cur0 = error_limit[cur0];
0000e0  9804              LDR      r0,[sp,#0x10]
0000e2  f8504024          LDR      r4,[r0,r4,LSL #2]
;;;1015         cur1 = error_limit[cur1];
0000e6  9804              LDR      r0,[sp,#0x10]
0000e8  f8505025          LDR      r5,[r0,r5,LSL #2]
;;;1016         cur2 = error_limit[cur2];
0000ec  9804              LDR      r0,[sp,#0x10]
0000ee  f8506026          LDR      r6,[r0,r6,LSL #2]
;;;1017         /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;1018          * The maximum error is +- MAXJSAMPLE (or less with error limiting);
;;;1019          * this sets the required size of the range_limit array.
;;;1020          */
;;;1021         cur0 += GETJSAMPLE(inptr[0]);
0000f2  f89b0000          LDRB     r0,[r11,#0]
0000f6  4404              ADD      r4,r4,r0
;;;1022         cur1 += GETJSAMPLE(inptr[1]);
0000f8  f89b0001          LDRB     r0,[r11,#1]
0000fc  4405              ADD      r5,r5,r0
;;;1023         cur2 += GETJSAMPLE(inptr[2]);
0000fe  f89b0002          LDRB     r0,[r11,#2]
000102  4406              ADD      r6,r6,r0
;;;1024         cur0 = GETJSAMPLE(range_limit[cur0]);
000104  9805              LDR      r0,[sp,#0x14]
000106  5d04              LDRB     r4,[r0,r4]
;;;1025         cur1 = GETJSAMPLE(range_limit[cur1]);
000108  9805              LDR      r0,[sp,#0x14]
00010a  5d45              LDRB     r5,[r0,r5]
;;;1026         cur2 = GETJSAMPLE(range_limit[cur2]);
00010c  9805              LDR      r0,[sp,#0x14]
00010e  5d86              LDRB     r6,[r0,r6]
;;;1027         /* Index into the cache with adjusted pixel value */
;;;1028         cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
000110  10e1              ASRS     r1,r4,#3
000112  9812              LDR      r0,[sp,#0x48]
000114  f8500021          LDR      r0,[r0,r1,LSL #2]
000118  10a9              ASRS     r1,r5,#2
00011a  eb001081          ADD      r0,r0,r1,LSL #6
00011e  10f1              ASRS     r1,r6,#3
000120  eb000041          ADD      r0,r0,r1,LSL #1
000124  900a              STR      r0,[sp,#0x28]
;;;1029         /* If we have not seen this color before, find nearest colormap */
;;;1030         /* entry and update the cache */
;;;1031         if (*cachep == 0)
000126  980a              LDR      r0,[sp,#0x28]
000128  8800              LDRH     r0,[r0,#0]
00012a  b928              CBNZ     r0,|L13.312|
;;;1032   	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
00012c  10f3              ASRS     r3,r6,#3
00012e  10aa              ASRS     r2,r5,#2
000130  10e1              ASRS     r1,r4,#3
000132  4640              MOV      r0,r8
000134  f7fffffe          BL       fill_inverse_cmap
                  |L13.312|
;;;1033         /* Now emit the colormap index for this cell */
;;;1034         { register int pixcode = *cachep - 1;
000138  990a              LDR      r1,[sp,#0x28]
00013a  8809              LDRH     r1,[r1,#0]
00013c  1e48              SUBS     r0,r1,#1
;;;1035   	*outptr = (JSAMPLE) pixcode;
00013e  990b              LDR      r1,[sp,#0x2c]
000140  7008              STRB     r0,[r1,#0]
;;;1036   	/* Compute representation error for this pixel */
;;;1037   	cur0 -= GETJSAMPLE(colormap0[pixcode]);
000142  9903              LDR      r1,[sp,#0xc]
000144  5c09              LDRB     r1,[r1,r0]
000146  1a64              SUBS     r4,r4,r1
;;;1038   	cur1 -= GETJSAMPLE(colormap1[pixcode]);
000148  9902              LDR      r1,[sp,#8]
00014a  5c09              LDRB     r1,[r1,r0]
00014c  1a6d              SUBS     r5,r5,r1
;;;1039   	cur2 -= GETJSAMPLE(colormap2[pixcode]);
00014e  9901              LDR      r1,[sp,#4]
000150  5c09              LDRB     r1,[r1,r0]
000152  1a76              SUBS     r6,r6,r1
;;;1040         }
;;;1041         /* Compute error fractions to be propagated to adjacent pixels.
;;;1042          * Add these into the running sums, and simultaneously shift the
;;;1043          * next-line error sums left by 1 column.
;;;1044          */
;;;1045         { register LOCFSERROR bnexterr, delta;
;;;1046   
;;;1047   	bnexterr = cur0;	/* Process component 0 */
000154  4620              MOV      r0,r4
;;;1048   	delta = cur0 * 2;
000156  0061              LSLS     r1,r4,#1
;;;1049   	cur0 += delta;		/* form error * 3 */
000158  440c              ADD      r4,r4,r1
;;;1050   	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
00015a  9a0e              LDR      r2,[sp,#0x38]
00015c  4422              ADD      r2,r2,r4
00015e  b212              SXTH     r2,r2
000160  803a              STRH     r2,[r7,#0]
;;;1051   	cur0 += delta;		/* form error * 5 */
000162  440c              ADD      r4,r4,r1
;;;1052   	bpreverr0 = belowerr0 + cur0;
000164  9a11              LDR      r2,[sp,#0x44]
000166  4422              ADD      r2,r2,r4
000168  920e              STR      r2,[sp,#0x38]
;;;1053   	belowerr0 = bnexterr;
00016a  9011              STR      r0,[sp,#0x44]
;;;1054   	cur0 += delta;		/* form error * 7 */
00016c  440c              ADD      r4,r4,r1
;;;1055   	bnexterr = cur1;	/* Process component 1 */
00016e  4628              MOV      r0,r5
;;;1056   	delta = cur1 * 2;
000170  0069              LSLS     r1,r5,#1
;;;1057   	cur1 += delta;		/* form error * 3 */
000172  440d              ADD      r5,r5,r1
;;;1058   	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
000174  9a0d              LDR      r2,[sp,#0x34]
000176  442a              ADD      r2,r2,r5
000178  b212              SXTH     r2,r2
00017a  807a              STRH     r2,[r7,#2]
;;;1059   	cur1 += delta;		/* form error * 5 */
00017c  440d              ADD      r5,r5,r1
;;;1060   	bpreverr1 = belowerr1 + cur1;
00017e  9a10              LDR      r2,[sp,#0x40]
000180  442a              ADD      r2,r2,r5
000182  920d              STR      r2,[sp,#0x34]
;;;1061   	belowerr1 = bnexterr;
000184  9010              STR      r0,[sp,#0x40]
;;;1062   	cur1 += delta;		/* form error * 7 */
000186  440d              ADD      r5,r5,r1
;;;1063   	bnexterr = cur2;	/* Process component 2 */
000188  4630              MOV      r0,r6
;;;1064   	delta = cur2 * 2;
00018a  0071              LSLS     r1,r6,#1
;;;1065   	cur2 += delta;		/* form error * 3 */
00018c  440e              ADD      r6,r6,r1
;;;1066   	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
00018e  9a0c              LDR      r2,[sp,#0x30]
000190  4432              ADD      r2,r2,r6
000192  b212              SXTH     r2,r2
000194  80ba              STRH     r2,[r7,#4]
;;;1067   	cur2 += delta;		/* form error * 5 */
000196  440e              ADD      r6,r6,r1
;;;1068   	bpreverr2 = belowerr2 + cur2;
000198  9a0f              LDR      r2,[sp,#0x3c]
00019a  4432              ADD      r2,r2,r6
00019c  920c              STR      r2,[sp,#0x30]
;;;1069   	belowerr2 = bnexterr;
00019e  900f              STR      r0,[sp,#0x3c]
;;;1070   	cur2 += delta;		/* form error * 7 */
0001a0  440e              ADD      r6,r6,r1
;;;1071         }
;;;1072         /* At this point curN contains the 7/16 error value to be propagated
;;;1073          * to the next pixel on the current line, and all the errors for the
;;;1074          * next line have been shifted over.  We are therefore ready to move on.
;;;1075          */
;;;1076         inptr += dir3;		/* Advance pixel pointers to next column */
0001a2  44d3              ADD      r11,r11,r10
;;;1077         outptr += dir;
0001a4  9909              LDR      r1,[sp,#0x24]
0001a6  980b              LDR      r0,[sp,#0x2c]
0001a8  4408              ADD      r0,r0,r1
0001aa  900b              STR      r0,[sp,#0x2c]
;;;1078         errorptr += dir3;		/* advance errorptr to current column */
0001ac  eb07074a          ADD      r7,r7,r10,LSL #1
0001b0  9807              LDR      r0,[sp,#0x1c]         ;999
0001b2  1e40              SUBS     r0,r0,#1              ;999
0001b4  9007              STR      r0,[sp,#0x1c]         ;999
                  |L13.438|
0001b6  9807              LDR      r0,[sp,#0x1c]         ;999
0001b8  2800              CMP      r0,#0                 ;999
0001ba  f47faf7e          BNE      |L13.186|
;;;1079       }
;;;1080       /* Post-loop cleanup: we must unload the final error values into the
;;;1081        * final fserrors[] entry.  Note we need not unload belowerrN because
;;;1082        * it is for the dummy column before or after the actual array.
;;;1083        */
;;;1084       errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
0001be  980e              LDR      r0,[sp,#0x38]
0001c0  b200              SXTH     r0,r0
0001c2  8038              STRH     r0,[r7,#0]
;;;1085       errorptr[1] = (FSERROR) bpreverr1;
0001c4  980d              LDR      r0,[sp,#0x34]
0001c6  b200              SXTH     r0,r0
0001c8  8078              STRH     r0,[r7,#2]
;;;1086       errorptr[2] = (FSERROR) bpreverr2;
0001ca  980c              LDR      r0,[sp,#0x30]
0001cc  b200              SXTH     r0,r0
0001ce  80b8              STRH     r0,[r7,#4]
0001d0  9808              LDR      r0,[sp,#0x20]         ;975
0001d2  1c40              ADDS     r0,r0,#1              ;975
0001d4  9008              STR      r0,[sp,#0x20]         ;975
                  |L13.470|
0001d6  9916              LDR      r1,[sp,#0x58]         ;975
0001d8  9808              LDR      r0,[sp,#0x20]         ;975
0001da  4288              CMP      r0,r1                 ;975
0001dc  f6ffaf31          BLT      |L13.66|
;;;1087     }
;;;1088   }
0001e0  b017              ADD      sp,sp,#0x5c
0001e2  e8bd8ff0          POP      {r4-r11,pc}
;;;1089   
                          ENDP


                          AREA ||i.pass2_no_dither||, CODE, READONLY, ALIGN=1

                  pass2_no_dither PROC
;;;915    METHODDEF(void)
;;;916    pass2_no_dither (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;917    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;918    /* This version performs no dithering */
;;;919    {
000004  b085              SUB      sp,sp,#0x14
000006  4606              MOV      r6,r0
000008  468b              MOV      r11,r1
;;;920      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000a  f8d601cc          LDR      r0,[r6,#0x1cc]
00000e  9004              STR      r0,[sp,#0x10]
;;;921      hist3d histogram = cquantize->histogram;
000010  9804              LDR      r0,[sp,#0x10]
000012  6980              LDR      r0,[r0,#0x18]
000014  9003              STR      r0,[sp,#0xc]
;;;922      register JSAMPROW inptr, outptr;
;;;923      register histptr cachep;
;;;924      register int c0, c1, c2;
;;;925      int row;
;;;926      JDIMENSION col;
;;;927      JDIMENSION width = cinfo->output_width;
000016  6f30              LDR      r0,[r6,#0x70]
000018  9000              STR      r0,[sp,#0]
;;;928    
;;;929      for (row = 0; row < num_rows; row++) {
00001a  2500              MOVS     r5,#0
00001c  e032              B        |L14.132|
                  |L14.30|
;;;930        inptr = input_buf[row];
00001e  f85b4025          LDR      r4,[r11,r5,LSL #2]
;;;931        outptr = output_buf[row];
000022  9807              LDR      r0,[sp,#0x1c]
000024  f8500025          LDR      r0,[r0,r5,LSL #2]
000028  9002              STR      r0,[sp,#8]
;;;932        for (col = width; col > 0; col--) {
00002a  9800              LDR      r0,[sp,#0]
00002c  9001              STR      r0,[sp,#4]
00002e  e025              B        |L14.124|
                  |L14.48|
;;;933          /* get pixel value and index into the cache */
;;;934          c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
000030  f8141b01          LDRB     r1,[r4],#1
000034  ea4f08e1          ASR      r8,r1,#3
;;;935          c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
000038  f8141b01          LDRB     r1,[r4],#1
00003c  ea4f09a1          ASR      r9,r1,#2
;;;936          c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
000040  f8141b01          LDRB     r1,[r4],#1
000044  ea4f0ae1          ASR      r10,r1,#3
;;;937          cachep = & histogram[c0][c1][c2];
000048  9803              LDR      r0,[sp,#0xc]
00004a  f8500028          LDR      r0,[r0,r8,LSL #2]
00004e  eb001089          ADD      r0,r0,r9,LSL #6
000052  eb00074a          ADD      r7,r0,r10,LSL #1
;;;938          /* If we have not seen this color before, find nearest colormap entry */
;;;939          /* and update the cache */
;;;940          if (*cachep == 0)
000056  8838              LDRH     r0,[r7,#0]
000058  b928              CBNZ     r0,|L14.102|
;;;941    	fill_inverse_cmap(cinfo, c0,c1,c2);
00005a  4653              MOV      r3,r10
00005c  464a              MOV      r2,r9
00005e  4641              MOV      r1,r8
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       fill_inverse_cmap
                  |L14.102|
;;;942          /* Now emit the colormap index for this cell */
;;;943          *outptr++ = (JSAMPLE) (*cachep - 1);
000066  7838              LDRB     r0,[r7,#0]
000068  1e40              SUBS     r0,r0,#1
00006a  b2c1              UXTB     r1,r0
00006c  9802              LDR      r0,[sp,#8]
00006e  7001              STRB     r1,[r0,#0]
000070  9802              LDR      r0,[sp,#8]
000072  1c40              ADDS     r0,r0,#1
000074  9002              STR      r0,[sp,#8]
000076  9801              LDR      r0,[sp,#4]            ;932
000078  1e40              SUBS     r0,r0,#1              ;932
00007a  9001              STR      r0,[sp,#4]            ;932
                  |L14.124|
00007c  9801              LDR      r0,[sp,#4]            ;932
00007e  2800              CMP      r0,#0                 ;932
000080  d1d6              BNE      |L14.48|
000082  1c6d              ADDS     r5,r5,#1              ;929
                  |L14.132|
000084  9808              LDR      r0,[sp,#0x20]         ;929
000086  4285              CMP      r5,r0                 ;929
000088  dbc9              BLT      |L14.30|
;;;944        }
;;;945      }
;;;946    }
00008a  b009              ADD      sp,sp,#0x24
00008c  e8bd8ff0          POP      {r4-r11,pc}
;;;947    
                          ENDP


                          AREA ||i.prescan_quantize||, CODE, READONLY, ALIGN=1

                  prescan_quantize PROC
;;;223    METHODDEF(void)
;;;224    prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;225    		  JSAMPARRAY output_buf, int num_rows)
;;;226    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;227      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
00000a  f8d4c1cc          LDR      r12,[r4,#0x1cc]
;;;228      register JSAMPROW ptr;
;;;229      register histptr histp;
;;;230      register hist3d histogram = cquantize->histogram;
00000e  f8dc8018          LDR      r8,[r12,#0x18]
;;;231      int row;
;;;232      JDIMENSION col;
;;;233      JDIMENSION width = cinfo->output_width;
000012  f8d49070          LDR      r9,[r4,#0x70]
;;;234    
;;;235      GUI_USE_PARA(output_buf);
000016  bf00              NOP      
;;;236      for (row = 0; row < num_rows; row++) {
000018  2200              MOVS     r2,#0
00001a  e02b              B        |L15.116|
                  |L15.28|
;;;237        ptr = input_buf[row];
00001c  f8551022          LDR      r1,[r5,r2,LSL #2]
;;;238        for (col = width; col > 0; col--) {
000020  464f              MOV      r7,r9
000022  e024              B        |L15.110|
                  |L15.36|
;;;239          /* get pixel value and index into the histogram */
;;;240          histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
000024  f891a000          LDRB     r10,[r1,#0]
000028  ea4f0aea          ASR      r10,r10,#3
00002c  f858a02a          LDR      r10,[r8,r10,LSL #2]
000030  f891b001          LDRB     r11,[r1,#1]
000034  ea4f0bab          ASR      r11,r11,#2
000038  eb0a1a8b          ADD      r10,r10,r11,LSL #6
00003c  f891b002          LDRB     r11,[r1,#2]
000040  ea4f0beb          ASR      r11,r11,#3
000044  eb0a004b          ADD      r0,r10,r11,LSL #1
;;;241    			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
;;;242    			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
;;;243          /* increment, check for overflow and undo increment if so. */
;;;244          if (++(*histp) <= 0)
000048  f8b0a000          LDRH     r10,[r0,#0]
00004c  f10a0a01          ADD      r10,r10,#1
000050  fa1ffa8a          UXTH     r10,r10
000054  f8a0a000          STRH     r10,[r0,#0]
000058  f1ba0f00          CMP      r10,#0
00005c  dc05              BGT      |L15.106|
;;;245    	(*histp)--;
00005e  f8b0a000          LDRH     r10,[r0,#0]
000062  f1aa0a01          SUB      r10,r10,#1
000066  f8a0a000          STRH     r10,[r0,#0]
                  |L15.106|
;;;246          ptr += 3;
00006a  1cc9              ADDS     r1,r1,#3
00006c  1e7f              SUBS     r7,r7,#1              ;238
                  |L15.110|
00006e  2f00              CMP      r7,#0                 ;238
000070  d1d8              BNE      |L15.36|
000072  1c52              ADDS     r2,r2,#1              ;236
                  |L15.116|
000074  429a              CMP      r2,r3                 ;236
000076  dbd1              BLT      |L15.28|
;;;247        }
;;;248      }
;;;249    }
000078  e8bd8ff0          POP      {r4-r11,pc}
;;;250    
                          ENDP


                          AREA ||i.select_colors||, CODE, READONLY, ALIGN=1

                  select_colors PROC
;;;539    LOCAL(void)
;;;540    select_colors (j_decompress_ptr cinfo, int desired_colors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;541    /* Master routine for color selection */
;;;542    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;543      boxptr boxlist;
;;;544      int numboxes;
;;;545      int i;
;;;546    
;;;547      /* Allocate workspace for box list */
;;;548      boxlist = (boxptr) (*cinfo->mem->alloc_small)
000008  ea4f1248          LSL      r2,r8,#5
00000c  6868              LDR      r0,[r5,#4]
00000e  2101              MOVS     r1,#1
000010  6803              LDR      r3,[r0,#0]
000012  4628              MOV      r0,r5
000014  4798              BLX      r3
000016  4604              MOV      r4,r0
;;;549        ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
;;;550      /* Initialize one box containing whole space */
;;;551      numboxes = 1;
000018  2601              MOVS     r6,#1
;;;552      boxlist[0].c0min = 0;
00001a  2000              MOVS     r0,#0
00001c  6020              STR      r0,[r4,#0]
;;;553      boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
00001e  201f              MOVS     r0,#0x1f
000020  6060              STR      r0,[r4,#4]
;;;554      boxlist[0].c1min = 0;
000022  2000              MOVS     r0,#0
000024  60a0              STR      r0,[r4,#8]
;;;555      boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
000026  203f              MOVS     r0,#0x3f
000028  60e0              STR      r0,[r4,#0xc]
;;;556      boxlist[0].c2min = 0;
00002a  2000              MOVS     r0,#0
00002c  6120              STR      r0,[r4,#0x10]
;;;557      boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
00002e  201f              MOVS     r0,#0x1f
000030  6160              STR      r0,[r4,#0x14]
;;;558      /* Shrink it to actually-used volume and set its statistics */
;;;559      update_box(cinfo, & boxlist[0]);
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       update_box
;;;560      /* Perform median-cut to produce final box list */
;;;561      numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
00003a  4643              MOV      r3,r8
00003c  4632              MOV      r2,r6
00003e  4621              MOV      r1,r4
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       median_cut
000046  4606              MOV      r6,r0
;;;562      /* Compute the representative color for each box, fill colormap */
;;;563      for (i = 0; i < numboxes; i++)
000048  2700              MOVS     r7,#0
00004a  e006              B        |L16.90|
                  |L16.76|
;;;564        compute_color(cinfo, & boxlist[i], i);
00004c  eb041147          ADD      r1,r4,r7,LSL #5
000050  463a              MOV      r2,r7
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       compute_color
000058  1c7f              ADDS     r7,r7,#1              ;563
                  |L16.90|
00005a  42b7              CMP      r7,r6                 ;563
00005c  dbf6              BLT      |L16.76|
;;;565      cinfo->actual_number_of_colors = numboxes;
00005e  f8c56084          STR      r6,[r5,#0x84]
;;;566      TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
000062  2060              MOVS     r0,#0x60
000064  6829              LDR      r1,[r5,#0]
000066  6148              STR      r0,[r1,#0x14]
000068  6828              LDR      r0,[r5,#0]
00006a  6186              STR      r6,[r0,#0x18]
00006c  6828              LDR      r0,[r5,#0]
00006e  2101              MOVS     r1,#1
000070  6842              LDR      r2,[r0,#4]
000072  4628              MOV      r0,r5
000074  4790              BLX      r2
;;;567    }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;568    
                          ENDP


                          AREA ||i.start_pass_2_quant||, CODE, READONLY, ALIGN=2

                  start_pass_2_quant PROC
;;;1168   METHODDEF(void)
;;;1169   start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1170   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1171     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8d451cc          LDR      r5,[r4,#0x1cc]
;;;1172     hist3d histogram = cquantize->histogram;
00000c  f8d59018          LDR      r9,[r5,#0x18]
;;;1173     int i;
;;;1174   
;;;1175     /* Only F-S dithering or no dithering is supported. */
;;;1176     /* If user asks for ordered dither, give him F-S. */
;;;1177     if (cinfo->dither_mode != JDITHER_NONE)
000010  f8940058          LDRB     r0,[r4,#0x58]
000014  b110              CBZ      r0,|L17.28|
;;;1178       cinfo->dither_mode = JDITHER_FS;
000016  2002              MOVS     r0,#2
000018  f8840058          STRB     r0,[r4,#0x58]
                  |L17.28|
;;;1179   
;;;1180     if (is_pre_scan) {
00001c  b137              CBZ      r7,|L17.44|
;;;1181       /* Set up method pointers */
;;;1182       cquantize->pub.color_quantize = prescan_quantize;
00001e  482f              LDR      r0,|L17.220|
000020  6068              STR      r0,[r5,#4]
;;;1183       cquantize->pub.finish_pass = finish_pass1;
000022  482f              LDR      r0,|L17.224|
000024  60a8              STR      r0,[r5,#8]
;;;1184       cquantize->needs_zeroed = TRUE; /* Always zero histogram */
000026  2001              MOVS     r0,#1
000028  61e8              STR      r0,[r5,#0x1c]
00002a  e045              B        |L17.184|
                  |L17.44|
;;;1185     } else {
;;;1186       /* Set up method pointers */
;;;1187       if (cinfo->dither_mode == JDITHER_FS)
00002c  f8940058          LDRB     r0,[r4,#0x58]
000030  2802              CMP      r0,#2
000032  d102              BNE      |L17.58|
;;;1188         cquantize->pub.color_quantize = pass2_fs_dither;
000034  482b              LDR      r0,|L17.228|
000036  6068              STR      r0,[r5,#4]
000038  e001              B        |L17.62|
                  |L17.58|
;;;1189       else
;;;1190         cquantize->pub.color_quantize = pass2_no_dither;
00003a  482b              LDR      r0,|L17.232|
00003c  6068              STR      r0,[r5,#4]
                  |L17.62|
;;;1191       cquantize->pub.finish_pass = finish_pass2;
00003e  482b              LDR      r0,|L17.236|
000040  60a8              STR      r0,[r5,#8]
;;;1192   
;;;1193       /* Make sure color count is acceptable */
;;;1194       i = cinfo->actual_number_of_colors;
000042  f8d46084          LDR      r6,[r4,#0x84]
;;;1195       if (i < 1)
000046  2e01              CMP      r6,#1
000048  da09              BGE      |L17.94|
;;;1196         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
00004a  2038              MOVS     r0,#0x38
00004c  6821              LDR      r1,[r4,#0]
00004e  6148              STR      r0,[r1,#0x14]
000050  2001              MOVS     r0,#1
000052  6821              LDR      r1,[r4,#0]
000054  6188              STR      r0,[r1,#0x18]
000056  6820              LDR      r0,[r4,#0]
000058  6801              LDR      r1,[r0,#0]
00005a  4620              MOV      r0,r4
00005c  4788              BLX      r1
                  |L17.94|
;;;1197       if (i > MAXNUMCOLORS)
00005e  f5b67f80          CMP      r6,#0x100
000062  dd0a              BLE      |L17.122|
;;;1198         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
000064  2039              MOVS     r0,#0x39
000066  6821              LDR      r1,[r4,#0]
000068  6148              STR      r0,[r1,#0x14]
00006a  f44f7080          MOV      r0,#0x100
00006e  6821              LDR      r1,[r4,#0]
000070  6188              STR      r0,[r1,#0x18]
000072  6820              LDR      r0,[r4,#0]
000074  6801              LDR      r1,[r0,#0]
000076  4620              MOV      r0,r4
000078  4788              BLX      r1
                  |L17.122|
;;;1199   
;;;1200       if (cinfo->dither_mode == JDITHER_FS) {
00007a  f8940058          LDRB     r0,[r4,#0x58]
00007e  2802              CMP      r0,#2
000080  d11a              BNE      |L17.184|
;;;1201         size_t arraysize = (size_t) ((cinfo->output_width + 2) *
000082  6f20              LDR      r0,[r4,#0x70]
000084  1c80              ADDS     r0,r0,#2
000086  eb000040          ADD      r0,r0,r0,LSL #1
00008a  ea4f0840          LSL      r8,r0,#1
;;;1202   				   (3 * SIZEOF(FSERROR)));
;;;1203         /* Allocate Floyd-Steinberg workspace if we didn't already. */
;;;1204         if (cquantize->fserrors == NULL)
00008e  6a28              LDR      r0,[r5,#0x20]
000090  b930              CBNZ     r0,|L17.160|
;;;1205   	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
000092  6860              LDR      r0,[r4,#4]
000094  4642              MOV      r2,r8
000096  2101              MOVS     r1,#1
000098  6843              LDR      r3,[r0,#4]
00009a  4620              MOV      r0,r4
00009c  4798              BLX      r3
00009e  6228              STR      r0,[r5,#0x20]
                  |L17.160|
;;;1206   	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;1207         /* Initialize the propagated errors to zero. */
;;;1208         jzero_far((void FAR *) cquantize->fserrors, arraysize);
0000a0  4641              MOV      r1,r8
0000a2  6a28              LDR      r0,[r5,#0x20]
0000a4  f7fffffe          BL       jzero_far
;;;1209         /* Make the error-limit table if we didn't already. */
;;;1210         if (cquantize->error_limiter == NULL)
0000a8  6aa8              LDR      r0,[r5,#0x28]
0000aa  b910              CBNZ     r0,|L17.178|
;;;1211   	init_error_limit(cinfo);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       init_error_limit
                  |L17.178|
;;;1212         cquantize->on_odd_row = FALSE;
0000b2  2000              MOVS     r0,#0
0000b4  6268              STR      r0,[r5,#0x24]
;;;1213       }
0000b6  bf00              NOP      
                  |L17.184|
;;;1214   
;;;1215     }
;;;1216     /* Zero the histogram or inverse color map, if necessary */
;;;1217     if (cquantize->needs_zeroed) {
0000b8  69e8              LDR      r0,[r5,#0x1c]
0000ba  b160              CBZ      r0,|L17.214|
;;;1218       for (i = 0; i < HIST_C0_ELEMS; i++) {
0000bc  2600              MOVS     r6,#0
0000be  e006              B        |L17.206|
                  |L17.192|
;;;1219         jzero_far((void FAR *) histogram[i],
0000c0  f8590026          LDR      r0,[r9,r6,LSL #2]
0000c4  f44f5180          MOV      r1,#0x1000
0000c8  f7fffffe          BL       jzero_far
0000cc  1c76              ADDS     r6,r6,#1              ;1218
                  |L17.206|
0000ce  2e20              CMP      r6,#0x20              ;1218
0000d0  dbf6              BLT      |L17.192|
;;;1220   		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1221       }
;;;1222       cquantize->needs_zeroed = FALSE;
0000d2  2000              MOVS     r0,#0
0000d4  61e8              STR      r0,[r5,#0x1c]
                  |L17.214|
;;;1223     }
;;;1224   }
0000d6  e8bd87f0          POP      {r4-r10,pc}
;;;1225   
                          ENDP

0000da  0000              DCW      0x0000
                  |L17.220|
                          DCD      prescan_quantize
                  |L17.224|
                          DCD      finish_pass1
                  |L17.228|
                          DCD      pass2_fs_dither
                  |L17.232|
                          DCD      pass2_no_dither
                  |L17.236|
                          DCD      finish_pass2

                          AREA ||i.update_box||, CODE, READONLY, ALIGN=1

                  update_box PROC
;;;313    LOCAL(void)
;;;314    update_box (j_decompress_ptr cinfo, boxptr boxp)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;315    /* Shrink the min/max bounds of a box to enclose only nonzero elements, */
;;;316    /* and recompute its volume and population */
;;;317    {
000004  b085              SUB      sp,sp,#0x14
000006  460b              MOV      r3,r1
;;;318      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000008  f8ddb014          LDR      r11,[sp,#0x14]
00000c  f8dbb1cc          LDR      r11,[r11,#0x1cc]
000010  f8cdb010          STR      r11,[sp,#0x10]
;;;319      hist3d histogram = cquantize->histogram;
000014  f8ddb010          LDR      r11,[sp,#0x10]
000018  f8dba018          LDR      r10,[r11,#0x18]
;;;320      histptr histp;
;;;321      int c0,c1,c2;
;;;322      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;323      INT32 dist0,dist1,dist2;
;;;324      long ccount;
;;;325      
;;;326      c0min = boxp->c0min;  c0max = boxp->c0max;
00001c  681f              LDR      r7,[r3,#0]
00001e  f8d3c004          LDR      r12,[r3,#4]
;;;327      c1min = boxp->c1min;  c1max = boxp->c1max;
000022  689e              LDR      r6,[r3,#8]
000024  f8d3800c          LDR      r8,[r3,#0xc]
;;;328      c2min = boxp->c2min;  c2max = boxp->c2max;
000028  691c              LDR      r4,[r3,#0x10]
00002a  f8d39014          LDR      r9,[r3,#0x14]
;;;329      
;;;330      if (c0max > c0min)
00002e  45bc              CMP      r12,r7
000030  dd1c              BLE      |L18.108|
;;;331        for (c0 = c0min; c0 <= c0max; c0++)
000032  4638              MOV      r0,r7
000034  e018              B        |L18.104|
                  |L18.54|
;;;332          for (c1 = c1min; c1 <= c1max; c1++) {
000036  4631              MOV      r1,r6
000038  e013              B        |L18.98|
                  |L18.58|
;;;333    	histp = & histogram[c0][c1][c2min];
00003a  f85ab020          LDR      r11,[r10,r0,LSL #2]
00003e  eb0b1b81          ADD      r11,r11,r1,LSL #6
000042  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;334    	for (c2 = c2min; c2 <= c2max; c2++)
000046  4622              MOV      r2,r4
000048  e008              B        |L18.92|
                  |L18.74|
;;;335    	  if (*histp++ != 0) {
00004a  f835bb02          LDRH     r11,[r5],#2
00004e  f1bb0f00          CMP      r11,#0
000052  d002              BEQ      |L18.90|
;;;336    	    boxp->c0min = c0min = c0;
000054  4607              MOV      r7,r0
000056  6018              STR      r0,[r3,#0]
;;;337    	    goto have_c0min;
000058  e009              B        |L18.110|
                  |L18.90|
00005a  1c52              ADDS     r2,r2,#1              ;334
                  |L18.92|
00005c  454a              CMP      r2,r9                 ;334
00005e  ddf4              BLE      |L18.74|
000060  1c49              ADDS     r1,r1,#1              ;332
                  |L18.98|
000062  4541              CMP      r1,r8                 ;332
000064  dde9              BLE      |L18.58|
000066  1c40              ADDS     r0,r0,#1              ;331
                  |L18.104|
000068  4560              CMP      r0,r12                ;331
00006a  dde4              BLE      |L18.54|
                  |L18.108|
;;;338    	  }
;;;339          }
;;;340     have_c0min:
00006c  bf00              NOP      
                  |L18.110|
;;;341      if (c0max > c0min)
00006e  45bc              CMP      r12,r7
000070  dd1c              BLE      |L18.172|
;;;342        for (c0 = c0max; c0 >= c0min; c0--)
000072  4660              MOV      r0,r12
000074  e018              B        |L18.168|
                  |L18.118|
;;;343          for (c1 = c1min; c1 <= c1max; c1++) {
000076  4631              MOV      r1,r6
000078  e013              B        |L18.162|
                  |L18.122|
;;;344    	histp = & histogram[c0][c1][c2min];
00007a  f85ab020          LDR      r11,[r10,r0,LSL #2]
00007e  eb0b1b81          ADD      r11,r11,r1,LSL #6
000082  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;345    	for (c2 = c2min; c2 <= c2max; c2++)
000086  4622              MOV      r2,r4
000088  e008              B        |L18.156|
                  |L18.138|
;;;346    	  if (*histp++ != 0) {
00008a  f835bb02          LDRH     r11,[r5],#2
00008e  f1bb0f00          CMP      r11,#0
000092  d002              BEQ      |L18.154|
;;;347    	    boxp->c0max = c0max = c0;
000094  4684              MOV      r12,r0
000096  6058              STR      r0,[r3,#4]
;;;348    	    goto have_c0max;
000098  e009              B        |L18.174|
                  |L18.154|
00009a  1c52              ADDS     r2,r2,#1              ;345
                  |L18.156|
00009c  454a              CMP      r2,r9                 ;345
00009e  ddf4              BLE      |L18.138|
0000a0  1c49              ADDS     r1,r1,#1              ;343
                  |L18.162|
0000a2  4541              CMP      r1,r8                 ;343
0000a4  dde9              BLE      |L18.122|
0000a6  1e40              SUBS     r0,r0,#1              ;342
                  |L18.168|
0000a8  42b8              CMP      r0,r7                 ;342
0000aa  dae4              BGE      |L18.118|
                  |L18.172|
;;;349    	  }
;;;350          }
;;;351     have_c0max:
0000ac  bf00              NOP      
                  |L18.174|
;;;352      if (c1max > c1min)
0000ae  45b0              CMP      r8,r6
0000b0  dd1c              BLE      |L18.236|
;;;353        for (c1 = c1min; c1 <= c1max; c1++)
0000b2  4631              MOV      r1,r6
0000b4  e018              B        |L18.232|
                  |L18.182|
;;;354          for (c0 = c0min; c0 <= c0max; c0++) {
0000b6  4638              MOV      r0,r7
0000b8  e013              B        |L18.226|
                  |L18.186|
;;;355    	histp = & histogram[c0][c1][c2min];
0000ba  f85ab020          LDR      r11,[r10,r0,LSL #2]
0000be  eb0b1b81          ADD      r11,r11,r1,LSL #6
0000c2  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;356    	for (c2 = c2min; c2 <= c2max; c2++)
0000c6  4622              MOV      r2,r4
0000c8  e008              B        |L18.220|
                  |L18.202|
;;;357    	  if (*histp++ != 0) {
0000ca  f835bb02          LDRH     r11,[r5],#2
0000ce  f1bb0f00          CMP      r11,#0
0000d2  d002              BEQ      |L18.218|
;;;358    	    boxp->c1min = c1min = c1;
0000d4  460e              MOV      r6,r1
0000d6  6099              STR      r1,[r3,#8]
;;;359    	    goto have_c1min;
0000d8  e009              B        |L18.238|
                  |L18.218|
0000da  1c52              ADDS     r2,r2,#1              ;356
                  |L18.220|
0000dc  454a              CMP      r2,r9                 ;356
0000de  ddf4              BLE      |L18.202|
0000e0  1c40              ADDS     r0,r0,#1              ;354
                  |L18.226|
0000e2  4560              CMP      r0,r12                ;354
0000e4  dde9              BLE      |L18.186|
0000e6  1c49              ADDS     r1,r1,#1              ;353
                  |L18.232|
0000e8  4541              CMP      r1,r8                 ;353
0000ea  dde4              BLE      |L18.182|
                  |L18.236|
;;;360    	  }
;;;361          }
;;;362     have_c1min:
0000ec  bf00              NOP      
                  |L18.238|
;;;363      if (c1max > c1min)
0000ee  45b0              CMP      r8,r6
0000f0  dd1c              BLE      |L18.300|
;;;364        for (c1 = c1max; c1 >= c1min; c1--)
0000f2  4641              MOV      r1,r8
0000f4  e018              B        |L18.296|
                  |L18.246|
;;;365          for (c0 = c0min; c0 <= c0max; c0++) {
0000f6  4638              MOV      r0,r7
0000f8  e013              B        |L18.290|
                  |L18.250|
;;;366    	histp = & histogram[c0][c1][c2min];
0000fa  f85ab020          LDR      r11,[r10,r0,LSL #2]
0000fe  eb0b1b81          ADD      r11,r11,r1,LSL #6
000102  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;367    	for (c2 = c2min; c2 <= c2max; c2++)
000106  4622              MOV      r2,r4
000108  e008              B        |L18.284|
                  |L18.266|
;;;368    	  if (*histp++ != 0) {
00010a  f835bb02          LDRH     r11,[r5],#2
00010e  f1bb0f00          CMP      r11,#0
000112  d002              BEQ      |L18.282|
;;;369    	    boxp->c1max = c1max = c1;
000114  4688              MOV      r8,r1
000116  60d9              STR      r1,[r3,#0xc]
;;;370    	    goto have_c1max;
000118  e009              B        |L18.302|
                  |L18.282|
00011a  1c52              ADDS     r2,r2,#1              ;367
                  |L18.284|
00011c  454a              CMP      r2,r9                 ;367
00011e  ddf4              BLE      |L18.266|
000120  1c40              ADDS     r0,r0,#1              ;365
                  |L18.290|
000122  4560              CMP      r0,r12                ;365
000124  dde9              BLE      |L18.250|
000126  1e49              SUBS     r1,r1,#1              ;364
                  |L18.296|
000128  42b1              CMP      r1,r6                 ;364
00012a  dae4              BGE      |L18.246|
                  |L18.300|
;;;371    	  }
;;;372          }
;;;373     have_c1max:
00012c  bf00              NOP      
                  |L18.302|
;;;374      if (c2max > c2min)
00012e  45a1              CMP      r9,r4
000130  dd1d              BLE      |L18.366|
;;;375        for (c2 = c2min; c2 <= c2max; c2++)
000132  4622              MOV      r2,r4
000134  e019              B        |L18.362|
                  |L18.310|
;;;376          for (c0 = c0min; c0 <= c0max; c0++) {
000136  4638              MOV      r0,r7
000138  e014              B        |L18.356|
                  |L18.314|
;;;377    	histp = & histogram[c0][c1min][c2];
00013a  f85ab020          LDR      r11,[r10,r0,LSL #2]
00013e  eb0b1b86          ADD      r11,r11,r6,LSL #6
000142  eb0b0542          ADD      r5,r11,r2,LSL #1
;;;378    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
000146  4631              MOV      r1,r6
000148  e009              B        |L18.350|
                  |L18.330|
;;;379    	  if (*histp != 0) {
00014a  f8b5b000          LDRH     r11,[r5,#0]
00014e  f1bb0f00          CMP      r11,#0
000152  d002              BEQ      |L18.346|
;;;380    	    boxp->c2min = c2min = c2;
000154  4614              MOV      r4,r2
000156  611a              STR      r2,[r3,#0x10]
;;;381    	    goto have_c2min;
000158  e00a              B        |L18.368|
                  |L18.346|
00015a  1c49              ADDS     r1,r1,#1              ;378
00015c  3540              ADDS     r5,r5,#0x40           ;378
                  |L18.350|
00015e  4541              CMP      r1,r8                 ;378
000160  ddf3              BLE      |L18.330|
000162  1c40              ADDS     r0,r0,#1              ;376
                  |L18.356|
000164  4560              CMP      r0,r12                ;376
000166  dde8              BLE      |L18.314|
000168  1c52              ADDS     r2,r2,#1              ;375
                  |L18.362|
00016a  454a              CMP      r2,r9                 ;375
00016c  dde3              BLE      |L18.310|
                  |L18.366|
;;;382    	  }
;;;383          }
;;;384     have_c2min:
00016e  bf00              NOP      
                  |L18.368|
;;;385      if (c2max > c2min)
000170  45a1              CMP      r9,r4
000172  dd1d              BLE      |L18.432|
;;;386        for (c2 = c2max; c2 >= c2min; c2--)
000174  464a              MOV      r2,r9
000176  e019              B        |L18.428|
                  |L18.376|
;;;387          for (c0 = c0min; c0 <= c0max; c0++) {
000178  4638              MOV      r0,r7
00017a  e014              B        |L18.422|
                  |L18.380|
;;;388    	histp = & histogram[c0][c1min][c2];
00017c  f85ab020          LDR      r11,[r10,r0,LSL #2]
000180  eb0b1b86          ADD      r11,r11,r6,LSL #6
000184  eb0b0542          ADD      r5,r11,r2,LSL #1
;;;389    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
000188  4631              MOV      r1,r6
00018a  e009              B        |L18.416|
                  |L18.396|
;;;390    	  if (*histp != 0) {
00018c  f8b5b000          LDRH     r11,[r5,#0]
000190  f1bb0f00          CMP      r11,#0
000194  d002              BEQ      |L18.412|
;;;391    	    boxp->c2max = c2max = c2;
000196  4691              MOV      r9,r2
000198  615a              STR      r2,[r3,#0x14]
;;;392    	    goto have_c2max;
00019a  e00a              B        |L18.434|
                  |L18.412|
00019c  1c49              ADDS     r1,r1,#1              ;389
00019e  3540              ADDS     r5,r5,#0x40           ;389
                  |L18.416|
0001a0  4541              CMP      r1,r8                 ;389
0001a2  ddf3              BLE      |L18.396|
0001a4  1c40              ADDS     r0,r0,#1              ;387
                  |L18.422|
0001a6  4560              CMP      r0,r12                ;387
0001a8  dde8              BLE      |L18.380|
0001aa  1e52              SUBS     r2,r2,#1              ;386
                  |L18.428|
0001ac  42a2              CMP      r2,r4                 ;386
0001ae  dae3              BGE      |L18.376|
                  |L18.432|
;;;393    	  }
;;;394          }
;;;395     have_c2max:
0001b0  bf00              NOP      
                  |L18.434|
;;;396    
;;;397      /* Update box volume.
;;;398       * We use 2-norm rather than real volume here; this biases the method
;;;399       * against making long narrow boxes, and it has the side benefit that
;;;400       * a box is splittable iff norm > 0.
;;;401       * Since the differences are expressed in histogram-cell units,
;;;402       * we have to shift back to JSAMPLE units to get consistent distances;
;;;403       * after which, we scale according to the selected distance scale factors.
;;;404       */
;;;405      dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
0001b2  ebac0b07          SUB      r11,r12,r7
0001b6  ea4f1e0b          LSL      lr,r11,#4
0001ba  f8cde00c          STR      lr,[sp,#0xc]
;;;406      dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
0001be  eba80b06          SUB      r11,r8,r6
0001c2  ea4f0b8b          LSL      r11,r11,#2
0001c6  eb0b0b4b          ADD      r11,r11,r11,LSL #1
0001ca  f8cdb008          STR      r11,[sp,#8]
;;;407      dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
0001ce  eba90b04          SUB      r11,r9,r4
0001d2  ea4f0bcb          LSL      r11,r11,#3
0001d6  f8cdb004          STR      r11,[sp,#4]
;;;408      boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
0001da  f8dde00c          LDR      lr,[sp,#0xc]
0001de  fb0efe0e          MUL      lr,lr,lr
0001e2  f8ddb008          LDR      r11,[sp,#8]
0001e6  fb0bee0b          MLA      lr,r11,r11,lr
0001ea  f8ddb004          LDR      r11,[sp,#4]
0001ee  fb0beb0b          MLA      r11,r11,r11,lr
0001f2  f8c3b018          STR      r11,[r3,#0x18]
;;;409      
;;;410      /* Now scan remaining volume of box and compute population */
;;;411      ccount = 0;
0001f6  f04f0b00          MOV      r11,#0
0001fa  f8cdb000          STR      r11,[sp,#0]
;;;412      for (c0 = c0min; c0 <= c0max; c0++)
0001fe  4638              MOV      r0,r7
000200  e01c              B        |L18.572|
                  |L18.514|
;;;413        for (c1 = c1min; c1 <= c1max; c1++) {
000202  4631              MOV      r1,r6
000204  e017              B        |L18.566|
                  |L18.518|
;;;414          histp = & histogram[c0][c1][c2min];
000206  f85ab020          LDR      r11,[r10,r0,LSL #2]
00020a  eb0b1b81          ADD      r11,r11,r1,LSL #6
00020e  eb0b0544          ADD      r5,r11,r4,LSL #1
;;;415          for (c2 = c2min; c2 <= c2max; c2++, histp++)
000212  4622              MOV      r2,r4
000214  e00c              B        |L18.560|
                  |L18.534|
;;;416    	if (*histp != 0) {
000216  f8b5b000          LDRH     r11,[r5,#0]
00021a  f1bb0f00          CMP      r11,#0
00021e  d005              BEQ      |L18.556|
;;;417    	  ccount++;
000220  f8ddb000          LDR      r11,[sp,#0]
000224  f10b0b01          ADD      r11,r11,#1
000228  f8cdb000          STR      r11,[sp,#0]
                  |L18.556|
00022c  1c52              ADDS     r2,r2,#1              ;415
00022e  1cad              ADDS     r5,r5,#2              ;415
                  |L18.560|
000230  454a              CMP      r2,r9                 ;415
000232  ddf0              BLE      |L18.534|
000234  1c49              ADDS     r1,r1,#1              ;413
                  |L18.566|
000236  4541              CMP      r1,r8                 ;413
000238  dde5              BLE      |L18.518|
00023a  1c40              ADDS     r0,r0,#1              ;412
                  |L18.572|
00023c  4560              CMP      r0,r12                ;412
00023e  dde0              BLE      |L18.514|
;;;418    	}
;;;419        }
;;;420      boxp->colorcount = ccount;
000240  f8ddb000          LDR      r11,[sp,#0]
000244  f8c3b01c          STR      r11,[r3,#0x1c]
;;;421    }
000248  b007              ADD      sp,sp,#0x1c
00024a  e8bd8ff0          POP      {r4-r11,pc}
;;;422    
                          ENDP

