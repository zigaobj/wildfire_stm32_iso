; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\guidev.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\guidev.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\guidev.crf ..\..\uCGUI\MemDev\GUIDEV.c]
                          THUMB

                          AREA ||i.GUI_MEMDEV_CopyToLCD||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_CopyToLCD PROC
;;;344    */
;;;345    void GUI_MEMDEV_CopyToLCD(GUI_MEMDEV_Handle hMem) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;346      GUI_MEMDEV_CopyToLCDAt(hMem, GUI_POS_AUTO, GUI_POS_AUTO);
000004  4a02              LDR      r2,|L1.16|
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GUI_MEMDEV_CopyToLCDAt
;;;347    }
00000e  bd10              POP      {r4,pc}
;;;348    
                          ENDP

                  |L1.16|
                          DCD      0xfffff001

                          AREA ||i.GUI_MEMDEV_CopyToLCDAt||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_CopyToLCDAt PROC
;;;296    */
;;;297    void GUI_MEMDEV_CopyToLCDAt(GUI_MEMDEV_Handle hMem, int x, int y) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;298      if (hMem) {
00000a  2e00              CMP      r6,#0
00000c  d03a              BEQ      |L2.132|
;;;299        GUI_MEMDEV_Handle hMemPrev;
;;;300        GUI_MEMDEV* pDevData;
;;;301      #if (GUI_WINSUPPORT)
;;;302        GUI_RECT r;
;;;303      #endif
;;;304      #if GUI_NUM_LAYERS > 1
;;;305        int PrevLayer;
;;;306      #endif
;;;307        GUI_LOCK();
00000e  f7fffffe          BL       GUI_Lock
;;;308        hMemPrev = GUI_Context.hDevData;
000012  481d              LDR      r0,|L2.136|
000014  f9b08050          LDRSH    r8,[r0,#0x50]  ; GUI_Context
;;;309        pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       GUI_ALLOC_h2p
00001e  4604              MOV      r4,r0
;;;310        /* Make sure LCD is selected as device */
;;;311      #if GUI_NUM_LAYERS > 1
;;;312        PrevLayer = GUI_SelectLayer(pDevData->LayerIndex);
;;;313      #else
;;;314        GUI_SelectLCD();  /* Activate LCD */
000020  f7fffffe          BL       GUI_SelectLCD
;;;315      #endif
;;;316        if (x == GUI_POS_AUTO) {
000024  f64070ff          MOV      r0,#0xfff
000028  1940              ADDS     r0,r0,r5
00002a  d103              BNE      |L2.52|
;;;317          x = pDevData->x0;
00002c  f9b45000          LDRSH    r5,[r4,#0]
;;;318          y = pDevData->y0;
000030  f9b47002          LDRSH    r7,[r4,#2]
                  |L2.52|
;;;319        }
;;;320      #if (GUI_WINSUPPORT)
;;;321        /* Calculate rectangle */
;;;322        r.x1 = (r.x0 = x) + pDevData->XSize-1;
000034  b228              SXTH     r0,r5
000036  f8ad0000          STRH     r0,[sp,#0]
00003a  88a1              LDRH     r1,[r4,#4]
00003c  4408              ADD      r0,r0,r1
00003e  1e40              SUBS     r0,r0,#1
000040  b200              SXTH     r0,r0
000042  f8ad0004          STRH     r0,[sp,#4]
;;;323        r.y1 = (r.y0 = y) + pDevData->YSize-1;;
000046  b238              SXTH     r0,r7
000048  f8ad0002          STRH     r0,[sp,#2]
00004c  88e1              LDRH     r1,[r4,#6]
00004e  4408              ADD      r0,r0,r1
000050  1e40              SUBS     r0,r0,#1
000052  b200              SXTH     r0,r0
000054  f8ad0006          STRH     r0,[sp,#6]
;;;324        /* Do the drawing. Window manager has to be on */
;;;325        WM_Activate();
000058  f7fffffe          BL       WM_Activate
;;;326        WM_ITERATE_START(&r) {
00005c  4668              MOV      r0,sp
00005e  f7fffffe          BL       WM__InitIVRSearch
000062  b148              CBZ      r0,|L2.120|
000064  bf00              NOP      
                  |L2.102|
;;;327      #endif
;;;328        GUI_MEMDEV__WriteToActiveAt(hMem, x, y);
000066  463a              MOV      r2,r7
000068  4629              MOV      r1,r5
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       GUI_MEMDEV__WriteToActiveAt
;;;329      #if (GUI_WINSUPPORT)
;;;330        } WM_ITERATE_END();
000070  f7fffffe          BL       WM__GetNextIVR
000074  2800              CMP      r0,#0
000076  d1f6              BNE      |L2.102|
                  |L2.120|
;;;331      #endif
;;;332      #if GUI_NUM_LAYERS > 1
;;;333        GUI_SelectLayer(PrevLayer);
;;;334      #endif
;;;335        /* Reactivate previously used device */
;;;336        GUI_MEMDEV_Select(hMemPrev);
000078  4640              MOV      r0,r8
00007a  f7fffffe          BL       GUI_MEMDEV_Select
;;;337        GUI_UNLOCK();
00007e  f7fffffe          BL       GUI_Unlock
;;;338      }
000082  bf00              NOP      
                  |L2.132|
;;;339    }
000084  e8bd81fc          POP      {r2-r8,pc}
;;;340    
                          ENDP

                  |L2.136|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV_Create||, CODE, READONLY, ALIGN=1

                  GUI_MEMDEV_Create PROC
;;;218    */
;;;219    GUI_MEMDEV_Handle GUI_MEMDEV_Create(int x0, int y0, int xsize, int ysize) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;220      return GUI_MEMDEV_CreateEx(x0, y0, xsize, ysize, GUI_MEMDEV_HASTRANS);
00000a  2000              MOVS     r0,#0
00000c  463b              MOV      r3,r7
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  9000              STR      r0,[sp,#0]
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GUI_MEMDEV_CreateEx
;;;221    }
00001a  bdf8              POP      {r3-r7,pc}
;;;222    
                          ENDP


                          AREA ||i.GUI_MEMDEV_CreateEx||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_CreateEx PROC
;;;185    */
;;;186    GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx(int x0, int y0, int xSize, int ySize, int Flags) {
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
;;;187      GUI_MEMDEV_Handle hMemDev;
;;;188      const tLCDDEV_APIList * pDeviceAPI;
;;;189      tLCDDEV_Color2Index   * pfColor2Index;
;;;190      tLCDDEV_Index2Color   * pfIndex2Color;
;;;191      tLCDDEV_GetIndexMask  * pfGetIndexMask;
;;;192      GUI_LOCK();
00000a  f7fffffe          BL       GUI_Lock
;;;193      #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;194        pDeviceAPI = LCD_aAPI[GUI_Context.SelLayer];
;;;195      #else
;;;196        pDeviceAPI = LCD_aAPI[0];
00000e  4817              LDR      r0,|L4.108|
000010  f8d0b000          LDR      r11,[r0,#0]  ; LCD_aAPI
;;;197      #endif
;;;198      if (GUI_Context.hDevData == 0) {
000014  4816              LDR      r0,|L4.112|
000016  f8b00050          LDRH     r0,[r0,#0x50]  ; GUI_Context
00001a  b948              CBNZ     r0,|L4.48|
;;;199        pfColor2Index = GUI_Context.pDeviceAPI->pfColor2Index;    /* LCD_L0_Color2Index; */
00001c  4814              LDR      r0,|L4.112|
00001e  6cc0              LDR      r0,[r0,#0x4c]  ; GUI_Context
000020  6804              LDR      r4,[r0,#0]
;;;200        pfIndex2Color = GUI_Context.pDeviceAPI->pfIndex2Color;    /* LCD_L0_Index2Color; */
000022  4813              LDR      r0,|L4.112|
000024  6cc0              LDR      r0,[r0,#0x4c]  ; GUI_Context
000026  6845              LDR      r5,[r0,#4]
;;;201        pfGetIndexMask= GUI_Context.pDeviceAPI->pfGetIndexMask;   /* LCD_L0_GetIndexMask */
000028  4811              LDR      r0,|L4.112|
00002a  6cc0              LDR      r0,[r0,#0x4c]  ; GUI_Context
00002c  6886              LDR      r6,[r0,#8]
00002e  e009              B        |L4.68|
                  |L4.48|
;;;202      } else {
;;;203        /* If a memory device is already selected, we create a compatible one by copying its data */
;;;204        GUI_MEMDEV* pDevSel;
;;;205        pDevSel = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000030  490f              LDR      r1,|L4.112|
000032  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
000036  f7fffffe          BL       GUI_ALLOC_h2p
00003a  4607              MOV      r7,r0
;;;206        pfColor2Index = pDevSel->pfColor2Index;
00003c  69fc              LDR      r4,[r7,#0x1c]
;;;207        pfIndex2Color = pDevSel->pfIndex2Color;
00003e  6a3d              LDR      r5,[r7,#0x20]
;;;208        pfGetIndexMask= pDevSel->pfGetIndexMask;
000040  6a7e              LDR      r6,[r7,#0x24]
;;;209      }
000042  bf00              NOP      
                  |L4.68|
;;;210      hMemDev = GUI_MEMDEV__CreateFixed(x0, y0, xSize, ySize, Flags, pDeviceAPI->pMemDevAPI, 
000044  f8db003c          LDR      r0,[r11,#0x3c]
000048  a901              ADD      r1,sp,#4
00004a  c171              STM      r1!,{r0,r4-r6}
00004c  9812              LDR      r0,[sp,#0x48]
00004e  9000              STR      r0,[sp,#0]
000050  4651              MOV      r1,r10
000052  4648              MOV      r0,r9
000054  e9dd2307          LDRD     r2,r3,[sp,#0x1c]
000058  f7fffffe          BL       GUI_MEMDEV__CreateFixed
00005c  4680              MOV      r8,r0
;;;211                                        pfColor2Index, pfIndex2Color ,pfGetIndexMask);
;;;212      GUI_UNLOCK();
00005e  f7fffffe          BL       GUI_Unlock
;;;213      return hMemDev;
000062  4640              MOV      r0,r8
;;;214    }
000064  b009              ADD      sp,sp,#0x24
000066  e8bd8ff0          POP      {r4-r11,pc}
;;;215    /*********************************************************************
                          ENDP

00006a  0000              DCW      0x0000
                  |L4.108|
                          DCD      LCD_aAPI
                  |L4.112|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV_Delete||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_Delete PROC
;;;88     */
;;;89     void GUI_MEMDEV_Delete(GUI_MEMDEV_Handle hMemDev) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;90     /* Make sure memory device is not used */
;;;91       GUI_LOCK();
000004  f7fffffe          BL       GUI_Lock
;;;92       if (hMemDev) {
000008  b1a5              CBZ      r5,|L5.52|
;;;93         GUI_MEMDEV* pDev;
;;;94         if (GUI_Context.hDevData == hMemDev) {
00000a  480c              LDR      r0,|L5.60|
00000c  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
000010  42a8              CMP      r0,r5
000012  d101              BNE      |L5.24|
;;;95     	    GUI_SelectLCD();
000014  f7fffffe          BL       GUI_SelectLCD
                  |L5.24|
;;;96         }
;;;97         pDev = GUI_MEMDEV_H2P(hMemDev);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       GUI_ALLOC_h2p
00001e  4604              MOV      r4,r0
;;;98         /* Delete the associated usage device */
;;;99         if (pDev->hUsage)
000020  8b20              LDRH     r0,[r4,#0x18]
000022  b118              CBZ      r0,|L5.44|
;;;100          GUI_USAGE_DecUseCnt(pDev->hUsage);
000024  f9b40018          LDRSH    r0,[r4,#0x18]
000028  f7fffffe          BL       GUI_USAGE_DecUseCnt
                  |L5.44|
;;;101        GUI_ALLOC_Free(hMemDev);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       GUI_ALLOC_Free
;;;102      }
000032  bf00              NOP      
                  |L5.52|
;;;103      GUI_UNLOCK();
000034  f7fffffe          BL       GUI_Unlock
;;;104    }
000038  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV_Select||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_Select PROC
;;;226    */
;;;227    GUI_MEMDEV_Handle GUI_MEMDEV_Select(GUI_MEMDEV_Handle hMem) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;228      GUI_MEMDEV_Handle r;
;;;229      GUI_LOCK();
000004  f7fffffe          BL       GUI_Lock
;;;230      r = GUI_Context.hDevData;
000008  4812              LDR      r0,|L6.84|
00000a  f9b05050          LDRSH    r5,[r0,#0x50]  ; GUI_Context
;;;231      if (hMem == 0) {
00000e  b914              CBNZ     r4,|L6.22|
;;;232        GUI_SelectLCD();
000010  f7fffffe          BL       GUI_SelectLCD
000014  e019              B        |L6.74|
                  |L6.22|
;;;233      } else {
;;;234        GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4606              MOV      r6,r0
;;;235        #if GUI_WINSUPPORT
;;;236          WM_Deactivate();
00001e  f7fffffe          BL       WM_Deactivate
;;;237        #endif
;;;238        /* If LCD was selected Save cliprect */
;;;239        if (GUI_Context.hDevData == 0) {
000022  480c              LDR      r0,|L6.84|
000024  f8b00050          LDRH     r0,[r0,#0x50]  ; GUI_Context
000028  b930              CBNZ     r0,|L6.56|
;;;240          GUI_Context.ClipRectPrev = GUI_Context.ClipRect;
00002a  480a              LDR      r0,|L6.84|
00002c  3052              ADDS     r0,r0,#0x52
00002e  4909              LDR      r1,|L6.84|
000030  688a              LDR      r2,[r1,#8]  ; GUI_Context
000032  6002              STR      r2,[r0,#0]  ; GUI_Context
000034  68c9              LDR      r1,[r1,#0xc]  ; GUI_Context
000036  6041              STR      r1,[r0,#4]  ; GUI_Context
                  |L6.56|
;;;241        }
;;;242        GUI_Context.hDevData = hMem;
000038  4806              LDR      r0,|L6.84|
00003a  f8a04050          STRH     r4,[r0,#0x50]
;;;243        GUI_Context.pDeviceAPI = pDev->pAPIList;
00003e  4905              LDR      r1,|L6.84|
000040  6ab0              LDR      r0,[r6,#0x28]
000042  64c8              STR      r0,[r1,#0x4c]  ; GUI_Context
;;;244        LCD_SetClipRectMax();
000044  f7fffffe          BL       LCD_SetClipRectMax
;;;245      }
000048  bf00              NOP      
                  |L6.74|
;;;246      GUI_UNLOCK();
00004a  f7fffffe          BL       GUI_Unlock
;;;247      return r;
00004e  4628              MOV      r0,r5
;;;248    }
000050  bd70              POP      {r4-r6,pc}
;;;249    
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__Color2Index||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__Color2Index PROC
;;;55     */
;;;56     unsigned int GUI_MEMDEV__Color2Index(LCD_COLOR Color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;57       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  4904              LDR      r1,|L7.24|
000006  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4605              MOV      r5,r0
;;;58       return pDev->pfColor2Index(Color);
000010  4620              MOV      r0,r4
000012  69e9              LDR      r1,[r5,#0x1c]
000014  4788              BLX      r1
;;;59     }
000016  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  |L7.24|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__CreateFixed||, CODE, READONLY, ALIGN=1

                  GUI_MEMDEV__CreateFixed PROC
;;;109    */
;;;110    GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;111                                            ,const tLCDDEV_APIList * pMemDevAPI
;;;112                                            ,tLCDDEV_Color2Index*        pfColor2Index
;;;113                                            ,tLCDDEV_Index2Color*        pfIndex2Color
;;;114                                            ,tLCDDEV_GetIndexMask*       pfGetIndexMask) {
000004  b083              SUB      sp,sp,#0xc
000006  4690              MOV      r8,r2
000008  461d              MOV      r5,r3
00000a  f8dd9040          LDR      r9,[sp,#0x40]
;;;115      I32 MemSize;
;;;116      GUI_USAGE_Handle hUsage = 0;
00000e  f04f0a00          MOV      r10,#0
;;;117      unsigned int BitsPerPixel, BytesPerLine;
;;;118      GUI_MEMDEV_Handle hMemDev;
;;;119      BitsPerPixel = pMemDevAPI->BitsPerPixel;
000012  9811              LDR      r0,[sp,#0x44]
000014  6c00              LDR      r0,[r0,#0x40]
000016  9002              STR      r0,[sp,#8]
;;;120      BytesPerLine = (xsize * BitsPerPixel + 7) >> 3;     /* Note: This code works with 8 and 16 bit memory devices. If other BPPs are introduced for MemDevs, it needs to be changed */
000018  9902              LDR      r1,[sp,#8]
00001a  fb08f001          MUL      r0,r8,r1
00001e  1dc0              ADDS     r0,r0,#7
000020  ea4f0bd0          LSR      r11,r0,#3
;;;121      /* Calc available MemSize */
;;;122      MemSize = GUI_ALLOC_GetMaxSize();
000024  f7fffffe          BL       GUI_ALLOC_GetMaxSize
000028  4606              MOV      r6,r0
;;;123      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
00002a  f0190f01          TST      r9,#1
00002e  d106              BNE      |L8.62|
;;;124        MemSize = (MemSize / 4) * 3;   /* We need to reserve some memory for usage object ... TBD: This can be optimized as we do not use memory perfectly. */
000030  4630              MOV      r0,r6
000032  17f1              ASRS     r1,r6,#31
000034  eb067191          ADD      r1,r6,r1,LSR #30
000038  1089              ASRS     r1,r1,#2
00003a  eb010641          ADD      r6,r1,r1,LSL #1
                  |L8.62|
;;;125      }
;;;126      if (ysize<=0) {
00003e  2d00              CMP      r5,#0
000040  dc0b              BGT      |L8.90|
;;;127        int MaxLines = (MemSize - sizeof(GUI_MEMDEV)) / BytesPerLine;
000042  f1a6012c          SUB      r1,r6,#0x2c
000046  fbb1f0fb          UDIV     r0,r1,r11
;;;128        ysize = (MaxLines > -ysize) ? -ysize : MaxLines;
00004a  4269              RSBS     r1,r5,#0
00004c  4288              CMP      r0,r1
00004e  dd01              BLE      |L8.84|
000050  4269              RSBS     r1,r5,#0
000052  e000              B        |L8.86|
                  |L8.84|
000054  4601              MOV      r1,r0
                  |L8.86|
000056  460d              MOV      r5,r1
;;;129      }
000058  bf00              NOP      
                  |L8.90|
;;;130      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
00005a  f0190f01          TST      r9,#1
00005e  d108              BNE      |L8.114|
;;;131        /* Create the usage map */
;;;132        hUsage = GUI_USAGE_BM_Create(x0, y0, xsize, ysize, 0);
000060  2000              MOVS     r0,#0
000062  462b              MOV      r3,r5
000064  4642              MOV      r2,r8
000066  9000              STR      r0,[sp,#0]
000068  e9dd0103          LDRD     r0,r1,[sp,#0xc]
00006c  f7fffffe          BL       GUI_USAGE_BM_Create
000070  4682              MOV      r10,r0
                  |L8.114|
;;;133      }
;;;134      /* Check if we can alloc sufficient memory */
;;;135      if (ysize <= 0) {
000072  2d00              CMP      r5,#0
000074  dc05              BGT      |L8.130|
;;;136        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Too little memory");
;;;137        GUI_UNLOCK();
000076  f7fffffe          BL       GUI_Unlock
;;;138        return 0;    
00007a  2000              MOVS     r0,#0
                  |L8.124|
;;;139      }
;;;140      MemSize = ysize * BytesPerLine + sizeof(GUI_MEMDEV);
;;;141      if (Flags & GUI_MEMDEV_NOTRANS) {
;;;142        hMemDev = GUI_ALLOC_AllocNoInit(MemSize);
;;;143      } else {
;;;144        hMemDev = GUI_ALLOC_AllocZero(MemSize);
;;;145      }
;;;146      if (hMemDev) {
;;;147        GUI_MEMDEV* pDevData;
;;;148        pDevData = GUI_MEMDEV_H2P(hMemDev);
;;;149        pDevData->x0            = x0;
;;;150        pDevData->y0            = y0;
;;;151        pDevData->XSize         = xsize;
;;;152        pDevData->YSize         = ysize;
;;;153        pDevData->NumColors     = 
;;;154        #if GUI_NUM_LAYERS == 1
;;;155          LCD_GET_NUMCOLORS();
;;;156        #else
;;;157          LCD_GetNumColorsEx(GUI_Context.SelLayer);
;;;158        #endif
;;;159        pDevData->BytesPerLine  = BytesPerLine;
;;;160        pDevData->hUsage        = hUsage;
;;;161        /* Set color conversion routine pointers */
;;;162        pDevData->pfColor2Index = pfColor2Index;    /* LCD_L0_Color2Index; */
;;;163        pDevData->pfIndex2Color = pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;164        pDevData->pfGetIndexMask= pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;165    
;;;166        pDevData->pAPIList      = pMemDevAPI;
;;;167        pDevData->BitsPerPixel  = BitsPerPixel;
;;;168        #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;169          pDevData->LayerIndex  = GUI_Context.SelLayer;
;;;170        #else
;;;171          pDevData->LayerIndex  = 0;
;;;172        #endif
;;;173      } else {
;;;174        if (hUsage) {
;;;175          GUI_ALLOC_Free(hUsage);
;;;176        }
;;;177        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Alloc failed");
;;;178      }
;;;179      return hMemDev;
;;;180    }
00007c  b007              ADD      sp,sp,#0x1c
00007e  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.130|
000082  fb05f00b          MUL      r0,r5,r11             ;140
000086  f100062c          ADD      r6,r0,#0x2c           ;140
00008a  f0190f01          TST      r9,#1                 ;141
00008e  d004              BEQ      |L8.154|
000090  b230              SXTH     r0,r6                 ;142
000092  f7fffffe          BL       GUI_ALLOC_AllocNoInit
000096  4607              MOV      r7,r0                 ;142
000098  e003              B        |L8.162|
                  |L8.154|
00009a  b230              SXTH     r0,r6                 ;144
00009c  f7fffffe          BL       GUI_ALLOC_AllocZero
0000a0  4607              MOV      r7,r0                 ;144
                  |L8.162|
0000a2  b317              CBZ      r7,|L8.234|
0000a4  4638              MOV      r0,r7                 ;148
0000a6  f7fffffe          BL       GUI_ALLOC_h2p
0000aa  4604              MOV      r4,r0                 ;148
0000ac  9803              LDR      r0,[sp,#0xc]          ;149
0000ae  b200              SXTH     r0,r0                 ;149
0000b0  8020              STRH     r0,[r4,#0]            ;149
0000b2  9804              LDR      r0,[sp,#0x10]         ;150
0000b4  b200              SXTH     r0,r0                 ;150
0000b6  8060              STRH     r0,[r4,#2]            ;150
0000b8  fa0ff088          SXTH     r0,r8                 ;151
0000bc  80a0              STRH     r0,[r4,#4]            ;151
0000be  b228              SXTH     r0,r5                 ;152
0000c0  80e0              STRH     r0,[r4,#6]            ;152
0000c2  f7fffffe          BL       LCD_GetNumColors
0000c6  60a0              STR      r0,[r4,#8]            ;153
0000c8  f8c4b00c          STR      r11,[r4,#0xc]         ;159
0000cc  f8a4a018          STRH     r10,[r4,#0x18]        ;160
0000d0  9812              LDR      r0,[sp,#0x48]         ;162
0000d2  61e0              STR      r0,[r4,#0x1c]         ;162
0000d4  9813              LDR      r0,[sp,#0x4c]         ;163
0000d6  6220              STR      r0,[r4,#0x20]         ;163
0000d8  9814              LDR      r0,[sp,#0x50]         ;164
0000da  6260              STR      r0,[r4,#0x24]         ;164
0000dc  9811              LDR      r0,[sp,#0x44]         ;166
0000de  62a0              STR      r0,[r4,#0x28]         ;166
0000e0  9802              LDR      r0,[sp,#8]            ;167
0000e2  6120              STR      r0,[r4,#0x10]         ;167
0000e4  2000              MOVS     r0,#0                 ;171
0000e6  6160              STR      r0,[r4,#0x14]         ;171
0000e8  e005              B        |L8.246|
                  |L8.234|
0000ea  f1ba0f00          CMP      r10,#0                ;174
0000ee  d002              BEQ      |L8.246|
0000f0  4650              MOV      r0,r10                ;175
0000f2  f7fffffe          BL       GUI_ALLOC_Free
                  |L8.246|
0000f6  4638              MOV      r0,r7                 ;179
0000f8  e7c0              B        |L8.124|
;;;181    
                          ENDP


                          AREA ||i.GUI_MEMDEV__GetIndexMask||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetIndexMask PROC
;;;73     */
;;;74     unsigned int GUI_MEMDEV__GetIndexMask(void) {
000000  b510              PUSH     {r4,lr}
;;;75       GUI_MEMDEV * pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000002  4904              LDR      r1,|L9.20|
000004  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4604              MOV      r4,r0
;;;76       return pDev->pfGetIndexMask();
00000e  6a60              LDR      r0,[r4,#0x24]
000010  4780              BLX      r0
;;;77     }
000012  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  |L9.20|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__GetRect||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetRect PROC
;;;43     */
;;;44     void GUI_MEMDEV__GetRect(GUI_RECT* pRect) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;45       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  490b              LDR      r1,|L10.52|
000006  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;46       pRect->x0 = pDev->x0;
000010  8820              LDRH     r0,[r4,#0]
000012  8028              STRH     r0,[r5,#0]
;;;47       pRect->y0 = pDev->y0;
000014  8860              LDRH     r0,[r4,#2]
000016  8068              STRH     r0,[r5,#2]
;;;48       pRect->x1 = pDev->x0 + pDev->XSize-1;
000018  8820              LDRH     r0,[r4,#0]
00001a  88a1              LDRH     r1,[r4,#4]
00001c  4408              ADD      r0,r0,r1
00001e  1e40              SUBS     r0,r0,#1
000020  b200              SXTH     r0,r0
000022  80a8              STRH     r0,[r5,#4]
;;;49       pRect->y1 = pDev->y0 + pDev->YSize-1;
000024  8860              LDRH     r0,[r4,#2]
000026  88e1              LDRH     r1,[r4,#6]
000028  4408              ADD      r0,r0,r1
00002a  1e40              SUBS     r0,r0,#1
00002c  b200              SXTH     r0,r0
00002e  80e8              STRH     r0,[r5,#6]
;;;50     }
000030  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__Index2Color||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__Index2Color PROC
;;;64     */
;;;65     LCD_COLOR GUI_MEMDEV__Index2Color(int Index) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;66       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  4904              LDR      r1,|L11.24|
000006  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4605              MOV      r5,r0
;;;67       return pDev->pfIndex2Color(Index);
000010  4620              MOV      r0,r4
000012  6a29              LDR      r1,[r5,#0x20]
000014  4788              BLX      r1
;;;68     }
000016  bd70              POP      {r4-r6,pc}
;;;69     
                          ENDP

                  |L11.24|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__WriteToActiveAt||, CODE, READONLY, ALIGN=1

                  GUI_MEMDEV__WriteToActiveAt PROC
;;;253    */
;;;254    void GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b08c              SUB      sp,sp,#0x30
000006  4692              MOV      r10,r2
;;;255      GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
000008  980c              LDR      r0,[sp,#0x30]
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4605              MOV      r5,r0
;;;256      GUI_USAGE_h hUsage = pDev->hUsage; 
000010  f9b50018          LDRSH    r0,[r5,#0x18]
000014  900b              STR      r0,[sp,#0x2c]
;;;257      GUI_USAGE*  pUsage;
;;;258      int YSize = pDev->YSize;
000016  f9b50006          LDRSH    r0,[r5,#6]
00001a  900a              STR      r0,[sp,#0x28]
;;;259      int yi;
;;;260      unsigned int BytesPerLine = pDev->BytesPerLine;
00001c  68ef              LDR      r7,[r5,#0xc]
;;;261      unsigned int BitsPerPixel = pDev->BitsPerPixel;
00001e  f8d5b010          LDR      r11,[r5,#0x10]
;;;262      int BytesPerPixel = BitsPerPixel >> 3;
000022  ea4f00db          LSR      r0,r11,#3
000026  9009              STR      r0,[sp,#0x24]
;;;263      U8* pData = (U8*)(pDev+1);
000028  f105082c          ADD      r8,r5,#0x2c
;;;264      if (hUsage) {
00002c  980b              LDR      r0,[sp,#0x2c]
00002e  2800              CMP      r0,#0
000030  d05f              BEQ      |L12.242|
;;;265        pUsage = GUI_USAGE_H2P(hUsage);
000032  980b              LDR      r0,[sp,#0x2c]
000034  f7fffffe          BL       GUI_ALLOC_h2p
000038  4606              MOV      r6,r0
;;;266        for (yi = 0; yi < YSize; yi++) {
00003a  2400              MOVS     r4,#0
00003c  e055              B        |L12.234|
                  |L12.62|
;;;267          int xOff = 0;
00003e  2000              MOVS     r0,#0
000040  9008              STR      r0,[sp,#0x20]
;;;268          int XSize;
;;;269          XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
000042  68b0              LDR      r0,[r6,#8]
000044  4622              MOV      r2,r4
000046  a908              ADD      r1,sp,#0x20
000048  6943              LDR      r3,[r0,#0x14]
00004a  4630              MOV      r0,r6
00004c  4798              BLX      r3
00004e  4681              MOV      r9,r0
;;;270          if (XSize == pDev->XSize) {
000050  f9b50004          LDRSH    r0,[r5,#4]
000054  4548              CMP      r0,r9
000056  d123              BNE      |L12.160|
;;;271            /* If the entire line is affected, calculate the number of entire lines */
;;;272            int y0 = yi;
000058  9407              STR      r4,[sp,#0x1c]
;;;273            while ((GUI_USAGE_GetNextDirty(pUsage, &xOff, yi + 1)) == XSize) {
00005a  e000              B        |L12.94|
                  |L12.92|
;;;274              yi++;
00005c  1c64              ADDS     r4,r4,#1
                  |L12.94|
00005e  68b0              LDR      r0,[r6,#8]            ;273
000060  1c62              ADDS     r2,r4,#1              ;273
000062  a908              ADD      r1,sp,#0x20           ;273
000064  6943              LDR      r3,[r0,#0x14]         ;273
000066  4630              MOV      r0,r6                 ;273
000068  4798              BLX      r3                    ;273
00006a  4548              CMP      r0,r9                 ;273
00006c  d0f6              BEQ      |L12.92|
;;;275            }
;;;276    		    LCD_DrawBitmap(x, y + y0, pDev->XSize, yi - y0 + 1, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
00006e  2000              MOVS     r0,#0
000070  e9cdb702          STRD     r11,r7,[sp,#8]
000074  e9cd8004          STRD     r8,r0,[sp,#0x10]
000078  2001              MOVS     r0,#1
00007a  9000              STR      r0,[sp,#0]
00007c  9001              STR      r0,[sp,#4]
00007e  9807              LDR      r0,[sp,#0x1c]
000080  1a20              SUBS     r0,r4,r0
000082  1c43              ADDS     r3,r0,#1
000084  f9b52004          LDRSH    r2,[r5,#4]
000088  9807              LDR      r0,[sp,#0x1c]
00008a  eb0a0100          ADD      r1,r10,r0
00008e  980d              LDR      r0,[sp,#0x34]
000090  f7fffffe          BL       LCD_DrawBitmap
;;;277            pData += (yi - y0 + 1) * BytesPerLine;
000094  9807              LDR      r0,[sp,#0x1c]
000096  1a20              SUBS     r0,r4,r0
000098  1c40              ADDS     r0,r0,#1
00009a  fb008807          MLA      r8,r0,r7,r8
;;;278          } else {
00009e  e023              B        |L12.232|
                  |L12.160|
;;;279            /* Draw the partial line which needs to be drawn */
;;;280            for (; XSize; ) {
0000a0  e01e              B        |L12.224|
                  |L12.162|
;;;281              LCD_DrawBitmap(x + xOff, y + yi, XSize, 1, 1, 1, BitsPerPixel, BytesPerLine, pData + xOff * BytesPerPixel, NULL);
0000a2  2100              MOVS     r1,#0
0000a4  e9dd2008          LDRD     r2,r0,[sp,#0x20]
0000a8  fb028000          MLA      r0,r2,r0,r8
0000ac  e9cdb702          STRD     r11,r7,[sp,#8]
0000b0  e9cd0104          STRD     r0,r1,[sp,#0x10]
0000b4  2001              MOVS     r0,#1
0000b6  9000              STR      r0,[sp,#0]
0000b8  eb0a0104          ADD      r1,r10,r4
0000bc  9001              STR      r0,[sp,#4]
0000be  9b08              LDR      r3,[sp,#0x20]
0000c0  9a0d              LDR      r2,[sp,#0x34]
0000c2  18d0              ADDS     r0,r2,r3
0000c4  2301              MOVS     r3,#1
0000c6  464a              MOV      r2,r9
0000c8  f7fffffe          BL       LCD_DrawBitmap
;;;282              xOff += XSize;
0000cc  9808              LDR      r0,[sp,#0x20]
0000ce  4448              ADD      r0,r0,r9
0000d0  9008              STR      r0,[sp,#0x20]
;;;283              XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
0000d2  68b0              LDR      r0,[r6,#8]
0000d4  4622              MOV      r2,r4
0000d6  a908              ADD      r1,sp,#0x20
0000d8  6943              LDR      r3,[r0,#0x14]
0000da  4630              MOV      r0,r6
0000dc  4798              BLX      r3
0000de  4681              MOV      r9,r0
                  |L12.224|
0000e0  f1b90f00          CMP      r9,#0                 ;280
0000e4  d1dd              BNE      |L12.162|
;;;284            }
;;;285            pData += BytesPerLine;
0000e6  44b8              ADD      r8,r8,r7
                  |L12.232|
0000e8  1c64              ADDS     r4,r4,#1              ;266
                  |L12.234|
0000ea  980a              LDR      r0,[sp,#0x28]         ;266
0000ec  4284              CMP      r4,r0                 ;266
0000ee  dba6              BLT      |L12.62|
0000f0  e00e              B        |L12.272|
                  |L12.242|
;;;286          }
;;;287        }
;;;288      } else {
;;;289    		LCD_DrawBitmap(x, y, pDev->XSize, YSize, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
0000f2  2000              MOVS     r0,#0
0000f4  e9cdb702          STRD     r11,r7,[sp,#8]
0000f8  e9cd8004          STRD     r8,r0,[sp,#0x10]
0000fc  2001              MOVS     r0,#1
0000fe  9000              STR      r0,[sp,#0]
000100  9001              STR      r0,[sp,#4]
000102  f9b52004          LDRSH    r2,[r5,#4]
000106  4651              MOV      r1,r10
000108  9b0a              LDR      r3,[sp,#0x28]
00010a  980d              LDR      r0,[sp,#0x34]
00010c  f7fffffe          BL       LCD_DrawBitmap
                  |L12.272|
;;;290      }
;;;291    }
000110  b00f              ADD      sp,sp,#0x3c
000112  e8bd8ff0          POP      {r4-r11,pc}
;;;292    
                          ENDP

