; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\wm_iscompletelyvisible.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\wm_iscompletelyvisible.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\wm_iscompletelyvisible.crf ..\..\uCGUI\WM\WM_IsCompletelyVisible.c]
                          THUMB

                          AREA ||i.WM_IsCompletelyVisible||, CODE, READONLY, ALIGN=1

                  WM_IsCompletelyVisible PROC
;;;145    */
;;;146    char WM_IsCompletelyVisible(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;147      int r = 0;
000004  2500              MOVS     r5,#0
;;;148      if (hWin) {
000006  b13c              CBZ      r4,|L1.24|
;;;149        WM_LOCK();
000008  f7fffffe          BL       GUI_Lock
;;;150        r = _IsCompletelyVisible(hWin);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       _IsCompletelyVisible
000012  4605              MOV      r5,r0
;;;151        WM_UNLOCK();
000014  f7fffffe          BL       GUI_Unlock
                  |L1.24|
;;;152      }
;;;153      return r;
000018  b2e8              UXTB     r0,r5
;;;154    }
00001a  bd70              POP      {r4-r6,pc}
;;;155    
                          ENDP


                          AREA ||i._CompareRect||, CODE, READONLY, ALIGN=1

                  _CompareRect PROC
;;;36     */
;;;37     static char _CompareRect(const GUI_RECT * pRect0, const GUI_RECT * pRect1 ) {
000000  4602              MOV      r2,r0
;;;38       if (pRect0->x0 != pRect1->x0) {
000002  f9b20000          LDRSH    r0,[r2,#0]
000006  f9b13000          LDRSH    r3,[r1,#0]
00000a  4298              CMP      r0,r3
00000c  d001              BEQ      |L2.18|
;;;39         return 1;                          /* Not equal */
00000e  2001              MOVS     r0,#1
                  |L2.16|
;;;40       }
;;;41       if (pRect0->x1 != pRect1->x1) {
;;;42         return 1;                          /* Not equal */
;;;43       }
;;;44       if (pRect0->y0 != pRect1->y0) {
;;;45         return 1;                          /* Not equal */
;;;46       }
;;;47       if (pRect0->y1 != pRect1->y1) {
;;;48         return 1;                          /* Not equal */
;;;49       }
;;;50       return 0;                            /* Equal */
;;;51     }
000010  4770              BX       lr
                  |L2.18|
000012  f9b20004          LDRSH    r0,[r2,#4]            ;41
000016  f9b13004          LDRSH    r3,[r1,#4]            ;41
00001a  4298              CMP      r0,r3                 ;41
00001c  d001              BEQ      |L2.34|
00001e  2001              MOVS     r0,#1                 ;42
000020  e7f6              B        |L2.16|
                  |L2.34|
000022  f9b20002          LDRSH    r0,[r2,#2]            ;44
000026  f9b13002          LDRSH    r3,[r1,#2]            ;44
00002a  4298              CMP      r0,r3                 ;44
00002c  d001              BEQ      |L2.50|
00002e  2001              MOVS     r0,#1                 ;45
000030  e7ee              B        |L2.16|
                  |L2.50|
000032  f9b20006          LDRSH    r0,[r2,#6]            ;47
000036  f9b13006          LDRSH    r3,[r1,#6]            ;47
00003a  4298              CMP      r0,r3                 ;47
00003c  d001              BEQ      |L2.66|
00003e  2001              MOVS     r0,#1                 ;48
000040  e7e6              B        |L2.16|
                  |L2.66|
000042  2000              MOVS     r0,#0                 ;50
000044  e7e4              B        |L2.16|
;;;52     
                          ENDP


                          AREA ||i._HasOverlap||, CODE, READONLY, ALIGN=1

                  _HasOverlap PROC
;;;77     */
;;;78     static int _HasOverlap(WM_Obj * pWin, GUI_RECT * pRect) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;79       WM_Obj * pParent;
;;;80       WM_HMEM hParent;
;;;81       /* Step 1:
;;;82        Check if there are any visible children. If this is so, then the
;;;83        window has an overlap.
;;;84        */
;;;85       /* Check all children */
;;;86       if (_WindowSiblingsOverlapRect(pWin->hFirstChild, pRect)) {
000008  f9b40018          LDRSH    r0,[r4,#0x18]
00000c  4639              MOV      r1,r7
00000e  f7fffffe          BL       _WindowSiblingsOverlapRect
000012  b110              CBZ      r0,|L3.26|
;;;87         return 1;
000014  2001              MOVS     r0,#1
                  |L3.22|
;;;88       }
;;;89     
;;;90       /* STEP 2:
;;;91            Find out the max. height (r.y1) if we are at the left border.
;;;92            Since we are using the same height for all IVRs at the same y0,
;;;93            we do this only for the leftmost one.
;;;94       */
;;;95     
;;;96       /* Iterate over all windows which are above */
;;;97       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;98       for (hParent = pWin->hParent; hParent; hParent = pParent->hParent) {
;;;99         pParent = WM_H2P(hParent);
;;;100        if (_WindowSiblingsOverlapRect(pParent->hNext, pRect)) {
;;;101          return 1;
;;;102        }
;;;103      }
;;;104      return 0;
;;;105    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L3.26|
00001a  f9b46016          LDRSH    r6,[r4,#0x16]         ;98
00001e  e00d              B        |L3.60|
                  |L3.32|
000020  4630              MOV      r0,r6                 ;99
000022  f7fffffe          BL       GUI_ALLOC_h2p
000026  4605              MOV      r5,r0                 ;99
000028  f9b5001a          LDRSH    r0,[r5,#0x1a]         ;100
00002c  4639              MOV      r1,r7                 ;100
00002e  f7fffffe          BL       _WindowSiblingsOverlapRect
000032  b108              CBZ      r0,|L3.56|
000034  2001              MOVS     r0,#1                 ;101
000036  e7ee              B        |L3.22|
                  |L3.56|
000038  f9b56016          LDRSH    r6,[r5,#0x16]         ;98
                  |L3.60|
00003c  2e00              CMP      r6,#0                 ;98
00003e  d1ef              BNE      |L3.32|
000040  2000              MOVS     r0,#0                 ;104
000042  e7e8              B        |L3.22|
;;;106    
                          ENDP


                          AREA ||i._IsCompletelyVisible||, CODE, READONLY, ALIGN=1

                  _IsCompletelyVisible PROC
;;;111    */
;;;112    static char _IsCompletelyVisible(WM_HWIN hWin) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
;;;113      WM_Obj * pWin;
;;;114      GUI_RECT Rect;
;;;115    
;;;116      pWin = WM_H2P(hWin);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       GUI_ALLOC_h2p
00000a  4604              MOV      r4,r0
;;;117      Rect = pWin->Rect;
00000c  e9d40100          LDRD     r0,r1,[r4,#0]
000010  e9cd0100          STRD     r0,r1,[sp,#0]
;;;118      if (WM__ClipAtParentBorders(&Rect, hWin) == 0) {
000014  4629              MOV      r1,r5
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       WM__ClipAtParentBorders
00001c  b908              CBNZ     r0,|L4.34|
;;;119        return 0;                 /* Nothing is left */
00001e  2000              MOVS     r0,#0
                  |L4.32|
;;;120      }
;;;121      /* Check if the window is still the original one */
;;;122      if (_CompareRect(&Rect, &pWin->Rect)) {
;;;123        return 0;                 /* Not completely visible */
;;;124      }
;;;125      /* Now the difficult part ...
;;;126         Find the rectangles.
;;;127      */
;;;128      if (_HasOverlap(pWin, &Rect)) {
;;;129        return 0;
;;;130      }
;;;131      return 1;                   /* Is completely visible */
;;;132    }
000020  bd7c              POP      {r2-r6,pc}
                  |L4.34|
000022  4621              MOV      r1,r4                 ;122
000024  4668              MOV      r0,sp                 ;122
000026  f7fffffe          BL       _CompareRect
00002a  b108              CBZ      r0,|L4.48|
00002c  2000              MOVS     r0,#0                 ;123
00002e  e7f7              B        |L4.32|
                  |L4.48|
000030  4669              MOV      r1,sp                 ;128
000032  4620              MOV      r0,r4                 ;128
000034  f7fffffe          BL       _HasOverlap
000038  b108              CBZ      r0,|L4.62|
00003a  2000              MOVS     r0,#0                 ;129
00003c  e7f0              B        |L4.32|
                  |L4.62|
00003e  2001              MOVS     r0,#1                 ;131
000040  e7ee              B        |L4.32|
;;;133    
                          ENDP


                          AREA ||i._WindowSiblingsOverlapRect||, CODE, READONLY, ALIGN=1

                  _WindowSiblingsOverlapRect PROC
;;;57     */
;;;58     static char _WindowSiblingsOverlapRect(WM_HWIN iWin, GUI_RECT* pRect) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;59       WM_Obj* pWin;
;;;60       for (; iWin; iWin = pWin->hNext) { 
000008  e011              B        |L5.46|
                  |L5.10|
;;;61         int Status = (pWin = WM_H2P(iWin))->Status;
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4604              MOV      r4,r0
000012  8b87              LDRH     r7,[r0,#0x1c]
;;;62         /* Check if this window affects us at all */    
;;;63         if (Status & WM_SF_ISVIS) {
000014  f0170f02          TST      r7,#2
000018  d007              BEQ      |L5.42|
;;;64           /* Check if this window affects us at all */    
;;;65           if (GUI_RectsIntersect(pRect, &pWin->Rect)) {
00001a  4621              MOV      r1,r4
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       GUI_RectsIntersect
000022  b110              CBZ      r0,|L5.42|
;;;66             return 1;
000024  2001              MOVS     r0,#1
                  |L5.38|
;;;67           }
;;;68         }
;;;69       }
;;;70       return 0;
;;;71     }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L5.42|
00002a  f9b4501a          LDRSH    r5,[r4,#0x1a]         ;60
                  |L5.46|
00002e  2d00              CMP      r5,#0                 ;60
000030  d1eb              BNE      |L5.10|
000032  2000              MOVS     r0,#0                 ;70
000034  e7f7              B        |L5.38|
;;;72     
                          ENDP

