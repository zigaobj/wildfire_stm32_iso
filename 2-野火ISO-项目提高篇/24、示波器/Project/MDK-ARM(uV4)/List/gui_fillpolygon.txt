; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\gui_fillpolygon.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\gui_fillpolygon.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\gui_fillpolygon.crf ..\..\uCGUI\Core\GUI_FillPolygon.c]
                          THUMB

                          AREA ||i.GL_FillPolygon||, CODE, READONLY, ALIGN=2

                  GL_FillPolygon PROC
;;;207    */
;;;208    void GL_FillPolygon  (const GUI_POINT*paPoint, int NumPoints, int xOff, int yOff) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  461f              MOV      r7,r3
;;;209      int i, y;
;;;210      int yMin = GUI_YMAX;
00000e  f64070ff          MOV      r0,#0xfff
000012  9006              STR      r0,[sp,#0x18]
;;;211      int yMax = GUI_YMIN;
000014  4240              RSBS     r0,r0,#0
000016  9005              STR      r0,[sp,#0x14]
;;;212    /* First step : find uppermost and lowermost coordinates */
;;;213      for (i=0; i<NumPoints; i++) {
000018  2500              MOVS     r5,#0
00001a  e00c              B        |L1.54|
                  |L1.28|
;;;214        y = (paPoint + i)->y;
00001c  eb060085          ADD      r0,r6,r5,LSL #2
000020  f9b04002          LDRSH    r4,[r0,#2]
;;;215        if (y < yMin)
000024  9806              LDR      r0,[sp,#0x18]
000026  4284              CMP      r4,r0
000028  da00              BGE      |L1.44|
;;;216          yMin = y;
00002a  9406              STR      r4,[sp,#0x18]
                  |L1.44|
;;;217        if (y > yMax)
00002c  9805              LDR      r0,[sp,#0x14]
00002e  4284              CMP      r4,r0
000030  dd00              BLE      |L1.52|
;;;218          yMax = y;
000032  9405              STR      r4,[sp,#0x14]
                  |L1.52|
000034  1c6d              ADDS     r5,r5,#1              ;213
                  |L1.54|
000036  454d              CMP      r5,r9                 ;213
000038  dbf0              BLT      |L1.28|
;;;219      }
;;;220    /* Use Clipping rect to reduce calculation (if possible) */
;;;221      if (GUI_Context.pClipRect_HL) {
00003a  4841              LDR      r0,|L1.320|
00003c  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
00003e  b1d8              CBZ      r0,|L1.120|
;;;222        if (yMax > (GUI_Context.pClipRect_HL->y1 - yOff))
000040  483f              LDR      r0,|L1.320|
000042  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000044  f9b00006          LDRSH    r0,[r0,#6]
000048  1bc1              SUBS     r1,r0,r7
00004a  9805              LDR      r0,[sp,#0x14]
00004c  4281              CMP      r1,r0
00004e  da05              BGE      |L1.92|
;;;223          yMax = (GUI_Context.pClipRect_HL->y1 - yOff);
000050  483b              LDR      r0,|L1.320|
000052  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000054  f9b00006          LDRSH    r0,[r0,#6]
000058  1bc0              SUBS     r0,r0,r7
00005a  9005              STR      r0,[sp,#0x14]
                  |L1.92|
;;;224        if (yMin < (GUI_Context.pClipRect_HL->y0 - yOff))
00005c  4838              LDR      r0,|L1.320|
00005e  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000060  f9b00002          LDRSH    r0,[r0,#2]
000064  1bc1              SUBS     r1,r0,r7
000066  9806              LDR      r0,[sp,#0x18]
000068  4281              CMP      r1,r0
00006a  dd05              BLE      |L1.120|
;;;225          yMin = (GUI_Context.pClipRect_HL->y0 - yOff);
00006c  4834              LDR      r0,|L1.320|
00006e  6940              LDR      r0,[r0,#0x14]  ; GUI_Context
000070  f9b00002          LDRSH    r0,[r0,#2]
000074  1bc0              SUBS     r0,r0,r7
000076  9006              STR      r0,[sp,#0x18]
                  |L1.120|
;;;226      }
;;;227    /* Second step: Calculate and draw horizontal lines */
;;;228      for (y=yMin; y<=yMax; y++) {
000078  9c06              LDR      r4,[sp,#0x18]
00007a  e05b              B        |L1.308|
                  |L1.124|
;;;229        _Init();
00007c  f7fffffe          BL       _Init
;;;230        /* find next intersection and count lines*/
;;;231        for (i=0; i<NumPoints; i++) {
000080  2500              MOVS     r5,#0
000082  e050              B        |L1.294|
                  |L1.132|
;;;232          int i1 = (i < (NumPoints - 1)) ? i + 1 : 0;
000084  f1a90001          SUB      r0,r9,#1
000088  42a8              CMP      r0,r5
00008a  dd01              BLE      |L1.144|
00008c  1c68              ADDS     r0,r5,#1
00008e  e000              B        |L1.146|
                  |L1.144|
000090  2000              MOVS     r0,#0
                  |L1.146|
000092  9004              STR      r0,[sp,#0x10]
;;;233          int y0 = (paPoint + i )->y;
000094  eb060085          ADD      r0,r6,r5,LSL #2
000098  f9b0b002          LDRSH    r11,[r0,#2]
;;;234          int y1 = (paPoint + i1)->y;
00009c  9804              LDR      r0,[sp,#0x10]
00009e  eb060080          ADD      r0,r6,r0,LSL #2
0000a2  f9b08002          LDRSH    r8,[r0,#2]
;;;235          /* Check if starting point is on line */
;;;236          if (y0 == y) {
0000a6  45a3              CMP      r11,r4
0000a8  d124              BNE      |L1.244|
;;;237            if (y1 == y) {  /* Add the entire line */
0000aa  45a0              CMP      r8,r4
0000ac  d10c              BNE      |L1.200|
;;;238              _DrawHLine((paPoint + i )->x + xOff , y + yOff, (paPoint + i1)->x + xOff);
0000ae  9b04              LDR      r3,[sp,#0x10]
0000b0  f9363023          LDRSH    r3,[r6,r3,LSL #2]
0000b4  eb03020a          ADD      r2,r3,r10
0000b8  19e1              ADDS     r1,r4,r7
0000ba  f9363025          LDRSH    r3,[r6,r5,LSL #2]
0000be  eb03000a          ADD      r0,r3,r10
0000c2  f7fffffe          BL       _DrawHLine
0000c6  e02d              B        |L1.292|
                  |L1.200|
;;;239            } else {        /* Add only one point */
;;;240              int yPrev = _GetPrevPointDiffy(paPoint, i, NumPoints, y);
0000c8  4623              MOV      r3,r4
0000ca  464a              MOV      r2,r9
0000cc  4629              MOV      r1,r5
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       _GetPrevPointDiffy
0000d4  9003              STR      r0,[sp,#0xc]
;;;241              if (yPrev != y) {
0000d6  9803              LDR      r0,[sp,#0xc]
0000d8  42a0              CMP      r0,r4
0000da  d00a              BEQ      |L1.242|
;;;242                _AddPoint((paPoint + i)->x, y, yPrev - y, y1 - y, xOff, yOff);
0000dc  eba80304          SUB      r3,r8,r4
0000e0  e9cda700          STRD     r10,r7,[sp,#0]
0000e4  9903              LDR      r1,[sp,#0xc]
0000e6  1b0a              SUBS     r2,r1,r4
0000e8  f9360025          LDRSH    r0,[r6,r5,LSL #2]
0000ec  4621              MOV      r1,r4
0000ee  f7fffffe          BL       _AddPoint
                  |L1.242|
;;;243              } 
;;;244            }
0000f2  e017              B        |L1.292|
                  |L1.244|
;;;245          } else if (y1 != y) {  /* Ignore if end-point is on the line */
0000f4  45a0              CMP      r8,r4
0000f6  d015              BEQ      |L1.292|
;;;246            if (((y1 >= y) && (y0 <= y)) || ((y0 >= y) && (y1 <= y))) {
0000f8  45a0              CMP      r8,r4
0000fa  db01              BLT      |L1.256|
0000fc  45a3              CMP      r11,r4
0000fe  dd03              BLE      |L1.264|
                  |L1.256|
000100  45a3              CMP      r11,r4
000102  db0f              BLT      |L1.292|
000104  45a0              CMP      r8,r4
000106  dc0d              BGT      |L1.292|
                  |L1.264|
;;;247              int xIntersect;
;;;248              if (_CheckYInterSect(y, &xIntersect, paPoint + i, paPoint + i1)) {
000108  9804              LDR      r0,[sp,#0x10]
00010a  eb060380          ADD      r3,r6,r0,LSL #2
00010e  eb060285          ADD      r2,r6,r5,LSL #2
000112  a903              ADD      r1,sp,#0xc
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       _CheckYInterSect
00011a  b110              CBZ      r0,|L1.290|
;;;249                _Add(xIntersect);
00011c  9803              LDR      r0,[sp,#0xc]
00011e  f7fffffe          BL       _Add
                  |L1.290|
;;;250              }
;;;251            }
000122  bf00              NOP      
                  |L1.292|
000124  1c6d              ADDS     r5,r5,#1              ;231
                  |L1.294|
000126  454d              CMP      r5,r9                 ;231
000128  dbac              BLT      |L1.132|
;;;252          }
;;;253        }
;;;254        _Flush(xOff, y + yOff);
00012a  19e1              ADDS     r1,r4,r7
00012c  4650              MOV      r0,r10
00012e  f7fffffe          BL       _Flush
000132  1c64              ADDS     r4,r4,#1              ;228
                  |L1.308|
000134  9805              LDR      r0,[sp,#0x14]         ;228
000136  4284              CMP      r4,r0                 ;228
000138  dda0              BLE      |L1.124|
;;;255      }  
;;;256    }
00013a  b007              ADD      sp,sp,#0x1c
00013c  e8bd8ff0          POP      {r4-r11,pc}
;;;257    
                          ENDP

                  |L1.320|
                          DCD      GUI_Context

                          AREA ||i.GUI_FillPolygon||, CODE, READONLY, ALIGN=2

                  GUI_FillPolygon PROC
;;;261    */
;;;262    void GUI_FillPolygon(const GUI_POINT* pPoints, int NumPoints, int x0, int y0) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;263      GUI_LOCK();
00000c  f7fffffe          BL       GUI_Lock
;;;264      #if (GUI_WINSUPPORT)
;;;265        WM_ADDORG(x0, y0);
000010  480c              LDR      r0,|L2.68|
000012  6c40              LDR      r0,[r0,#0x44]  ; GUI_Context
000014  4404              ADD      r4,r4,r0
000016  480b              LDR      r0,|L2.68|
000018  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
00001a  4405              ADD      r5,r5,r0
;;;266        WM_ITERATE_START(NULL); {
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       WM__InitIVRSearch
000022  b150              CBZ      r0,|L2.58|
000024  bf00              NOP      
                  |L2.38|
;;;267      #endif
;;;268      GL_FillPolygon (pPoints, NumPoints, x0, y0);
000026  462b              MOV      r3,r5
000028  4622              MOV      r2,r4
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       GL_FillPolygon
;;;269      #if (GUI_WINSUPPORT)
;;;270        } WM_ITERATE_END();
000032  f7fffffe          BL       WM__GetNextIVR
000036  2800              CMP      r0,#0
000038  d1f5              BNE      |L2.38|
                  |L2.58|
;;;271      #endif
;;;272      GUI_UNLOCK();
00003a  f7fffffe          BL       GUI_Unlock
;;;273    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;274    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      GUI_Context

                          AREA ||i._Add||, CODE, READONLY, ALIGN=2

                  _Add PROC
;;;115    */
;;;116    static void _Add(int x) {
000000  4601              MOV      r1,r0
;;;117      if (GL_FP_Cnt < GUI_FP_MAXCOUNT) {
000002  4811              LDR      r0,|L3.72|
000004  6800              LDR      r0,[r0,#0]  ; GL_FP_Cnt
000006  280c              CMP      r0,#0xc
000008  da1d              BGE      |L3.70|
;;;118        int i;
;;;119        /* Move all entries to the right (bigger x-value) */
;;;120        for (i=GL_FP_Cnt; i ; i--) {
00000a  4a0f              LDR      r2,|L3.72|
00000c  6810              LDR      r0,[r2,#0]  ; GL_FP_Cnt
00000e  e00d              B        |L3.44|
                  |L3.16|
;;;121          if (_aX[i-1] < x)
000010  1e42              SUBS     r2,r0,#1
000012  4b0e              LDR      r3,|L3.76|
000014  f9332012          LDRSH    r2,[r3,r2,LSL #1]
000018  428a              CMP      r2,r1
00001a  da00              BGE      |L3.30|
;;;122            break;
00001c  e008              B        |L3.48|
                  |L3.30|
;;;123          _aX[i] = _aX[i-1];
00001e  1e42              SUBS     r2,r0,#1
000020  4b0a              LDR      r3,|L3.76|
000022  f8332012          LDRH     r2,[r3,r2,LSL #1]
000026  f8232010          STRH     r2,[r3,r0,LSL #1]
00002a  1e40              SUBS     r0,r0,#1              ;120
                  |L3.44|
00002c  2800              CMP      r0,#0                 ;120
00002e  d1ef              BNE      |L3.16|
                  |L3.48|
000030  bf00              NOP                            ;122
;;;124        }
;;;125        /* Insert new entry */
;;;126        _aX[i]    = x;
000032  b20a              SXTH     r2,r1
000034  4b05              LDR      r3,|L3.76|
000036  f8232010          STRH     r2,[r3,r0,LSL #1]
;;;127        GL_FP_Cnt++;
00003a  4a03              LDR      r2,|L3.72|
00003c  6812              LDR      r2,[r2,#0]  ; GL_FP_Cnt
00003e  1c52              ADDS     r2,r2,#1
000040  4b01              LDR      r3,|L3.72|
000042  601a              STR      r2,[r3,#0]  ; GL_FP_Cnt
;;;128      }
000044  bf00              NOP      
                  |L3.70|
;;;129    }
000046  4770              BX       lr
;;;130    
                          ENDP

                  |L3.72|
                          DCD      GL_FP_Cnt
                  |L3.76|
                          DCD      _aX

                          AREA ||i._AddPoint||, CODE, READONLY, ALIGN=2

                  _AddPoint PROC
;;;167    */
;;;168    static void _AddPoint(int x, int y, int y0, int y1, int xOff, int yOff) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;169      if ((y0 ^ y1) >= 0) {
000010  ea960007          EORS     r0,r6,r7
000014  d409              BMI      |L4.42|
;;;170        x += xOff;
000016  4444              ADD      r4,r4,r8
;;;171        LCD_HL_DrawHLine(x, y + yOff, x);    /* V-point, not crossing the polygon */
000018  eb050109          ADD      r1,r5,r9
00001c  4805              LDR      r0,|L4.52|
00001e  6dc0              LDR      r0,[r0,#0x5c]  ; GUI_Context
000020  4622              MOV      r2,r4
000022  6803              LDR      r3,[r0,#0]
000024  4620              MOV      r0,r4
000026  4798              BLX      r3
000028  e002              B        |L4.48|
                  |L4.42|
;;;172      } else {
;;;173        _Add(x);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _Add
                  |L4.48|
;;;174      }
;;;175    }
000030  e8bd87f0          POP      {r4-r10,pc}
;;;176    
                          ENDP

                  |L4.52|
                          DCD      GUI_Context

                          AREA ||i._CheckYInterSect||, CODE, READONLY, ALIGN=1

                  _CheckYInterSect PROC
;;;74     */
;;;75     static int _CheckYInterSect(int y, int* px, const GUI_POINT*paPoint0, const GUI_POINT*paPoint1) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  4604              MOV      r4,r0
000006  468c              MOV      r12,r1
000008  4615              MOV      r5,r2
;;;76       int x0, y0, x1, y1;
;;;77       if (paPoint0->y <= (paPoint1)->y) {
00000a  f9b50002          LDRSH    r0,[r5,#2]
00000e  f9b38002          LDRSH    r8,[r3,#2]
000012  4540              CMP      r0,r8
000014  dc11              BGT      |L5.58|
;;;78         y0 = paPoint0->y;
000016  f9b51002          LDRSH    r1,[r5,#2]
;;;79         if (y0 > y)      /* Check if there is an intersection ... (early out) */
00001a  42a1              CMP      r1,r4
00001c  dd02              BLE      |L5.36|
;;;80           return 0;
00001e  2000              MOVS     r0,#0
                  |L5.32|
;;;81         y1 = paPoint1->y;
;;;82         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;83           return 0;
;;;84         x0 = paPoint0->x;
;;;85         x1 = paPoint1->x;
;;;86       } else {
;;;87         y0 = paPoint1->y;
;;;88         if (y0 > y)      /* Check if there is an intersection ... (early out) */
;;;89           return 0;
;;;90         y1 = paPoint0->y;
;;;91         if (y1 < y)      /* Check if there is an intersection ... (early out) */
;;;92           return 0;
;;;93         x0 = paPoint1->x;
;;;94         x1 = paPoint0->x;
;;;95       }
;;;96     /* Calculate intersection */
;;;97       {
;;;98         I32 Mul = (I32)(x1 - x0) * (I32)(y - y0);
;;;99         if (Mul > 0) {
;;;100          Mul += (y1 - y0) >> 1;	          /* for proper rounding */
;;;101        } else {
;;;102          Mul -= ((y1 - y0) >> 1) - 1;	    /* for proper rounding */
;;;103        }
;;;104        x0 += Mul / (y1 - y0);
;;;105      }
;;;106      *px = x0;
;;;107      return 1;
;;;108    } 
000020  e8bd83f0          POP      {r4-r9,pc}
                  |L5.36|
000024  f9b32002          LDRSH    r2,[r3,#2]            ;81
000028  42a2              CMP      r2,r4                 ;82
00002a  da01              BGE      |L5.48|
00002c  2000              MOVS     r0,#0                 ;83
00002e  e7f7              B        |L5.32|
                  |L5.48|
000030  f9b56000          LDRSH    r6,[r5,#0]            ;84
000034  f9b37000          LDRSH    r7,[r3,#0]            ;85
000038  e00f              B        |L5.90|
                  |L5.58|
00003a  f9b31002          LDRSH    r1,[r3,#2]            ;87
00003e  42a1              CMP      r1,r4                 ;88
000040  dd01              BLE      |L5.70|
000042  2000              MOVS     r0,#0                 ;89
000044  e7ec              B        |L5.32|
                  |L5.70|
000046  f9b52002          LDRSH    r2,[r5,#2]            ;90
00004a  42a2              CMP      r2,r4                 ;91
00004c  da01              BGE      |L5.82|
00004e  2000              MOVS     r0,#0                 ;92
000050  e7e6              B        |L5.32|
                  |L5.82|
000052  f9b36000          LDRSH    r6,[r3,#0]            ;93
000056  f9b57000          LDRSH    r7,[r5,#0]            ;94
                  |L5.90|
00005a  eba70806          SUB      r8,r7,r6              ;98
00005e  eba40901          SUB      r9,r4,r1              ;98
000062  fb08f009          MUL      r0,r8,r9              ;98
000066  2800              CMP      r0,#0                 ;99
000068  dd04              BLE      |L5.116|
00006a  eba20801          SUB      r8,r2,r1              ;100
00006e  eb000068          ADD      r0,r0,r8,ASR #1       ;100
000072  e007              B        |L5.132|
                  |L5.116|
000074  eba20801          SUB      r8,r2,r1              ;102
000078  f04f0901          MOV      r9,#1                 ;102
00007c  ebc90868          RSB      r8,r9,r8,ASR #1       ;102
000080  eba00008          SUB      r0,r0,r8              ;102
                  |L5.132|
000084  eba20801          SUB      r8,r2,r1              ;104
000088  fb90f8f8          SDIV     r8,r0,r8              ;104
00008c  4446              ADD      r6,r6,r8              ;104
00008e  f8cc6000          STR      r6,[r12,#0]           ;106
000092  2001              MOVS     r0,#1                 ;107
000094  e7c4              B        |L5.32|
;;;109    
                          ENDP


                          AREA ||i._DrawHLine||, CODE, READONLY, ALIGN=2

                  _DrawHLine PROC
;;;52     */
;;;53     static void _DrawHLine(int x0, int y, int x1) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;54       if (x0 < x1) {
000008  42ac              CMP      r4,r5
00000a  da07              BGE      |L6.28|
;;;55         LCD_HL_DrawHLine(x0, y, x1);
00000c  4807              LDR      r0,|L6.44|
00000e  6dc0              LDR      r0,[r0,#0x5c]  ; GUI_Context
000010  462a              MOV      r2,r5
000012  4631              MOV      r1,r6
000014  6803              LDR      r3,[r0,#0]
000016  4620              MOV      r0,r4
000018  4798              BLX      r3
00001a  e006              B        |L6.42|
                  |L6.28|
;;;56       } else {
;;;57         LCD_HL_DrawHLine(x1, y, x0);
00001c  4803              LDR      r0,|L6.44|
00001e  6dc0              LDR      r0,[r0,#0x5c]  ; GUI_Context
000020  4622              MOV      r2,r4
000022  4631              MOV      r1,r6
000024  6803              LDR      r3,[r0,#0]
000026  4628              MOV      r0,r5
000028  4798              BLX      r3
                  |L6.42|
;;;58       }
;;;59     }
00002a  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  |L6.44|
                          DCD      GUI_Context

                          AREA ||i._Flush||, CODE, READONLY, ALIGN=2

                  _Flush PROC
;;;146    */
;;;147    static void _Flush(int x0, int y) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;148      int i, x = 0;
000008  f04f0900          MOV      r9,#0
;;;149      char On=0;
00000c  2600              MOVS     r6,#0
;;;150      for (i=0; i<GL_FP_Cnt; i++) {
00000e  2500              MOVS     r5,#0
000010  e00f              B        |L7.50|
                  |L7.18|
;;;151        int xNew = _aX[i];
000012  480b              LDR      r0,|L7.64|
000014  f9307015          LDRSH    r7,[r0,r5,LSL #1]
;;;152        if (On) {
000018  b13e              CBZ      r6,|L7.42|
;;;153          LCD_HL_DrawHLine(x0 + x, y, x0 + xNew);
00001a  19e2              ADDS     r2,r4,r7
00001c  eb040009          ADD      r0,r4,r9
000020  4908              LDR      r1,|L7.68|
000022  6dc9              LDR      r1,[r1,#0x5c]  ; GUI_Context
000024  680b              LDR      r3,[r1,#0]
000026  4641              MOV      r1,r8
000028  4798              BLX      r3
                  |L7.42|
;;;154        }
;;;155        On ^= 1;
00002a  f0860601          EOR      r6,r6,#1
;;;156        x = xNew;
00002e  46b9              MOV      r9,r7
000030  1c6d              ADDS     r5,r5,#1              ;150
                  |L7.50|
000032  4805              LDR      r0,|L7.72|
000034  6800              LDR      r0,[r0,#0]            ;150  ; GL_FP_Cnt
000036  4285              CMP      r5,r0                 ;150
000038  dbeb              BLT      |L7.18|
;;;157      }
;;;158    }
00003a  e8bd87f0          POP      {r4-r10,pc}
;;;159    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      _aX
                  |L7.68|
                          DCD      GUI_Context
                  |L7.72|
                          DCD      GL_FP_Cnt

                          AREA ||i._GetPrevPointDiffy||, CODE, READONLY, ALIGN=1

                  _GetPrevPointDiffy PROC
;;;182    */
;;;183    static int _GetPrevPointDiffy(const GUI_POINT* paPoint, int i,
000000  b570              PUSH     {r4-r6,lr}
;;;184                                  const int NumPoints, const int y0) {
000002  4605              MOV      r5,r0
;;;185      int j, y1;
;;;186      for (j = 0; j < (NumPoints - 1) ; j++) {
000004  2600              MOVS     r6,#0
000006  e00d              B        |L8.36|
                  |L8.8|
;;;187        i = (i != 0) ? i - 1 : NumPoints - 1;
000008  b109              CBZ      r1,|L8.14|
00000a  1e48              SUBS     r0,r1,#1
00000c  e000              B        |L8.16|
                  |L8.14|
00000e  1e50              SUBS     r0,r2,#1
                  |L8.16|
000010  4601              MOV      r1,r0
;;;188        y1 = (paPoint + i)->y;
000012  eb050081          ADD      r0,r5,r1,LSL #2
000016  f9b04002          LDRSH    r4,[r0,#2]
;;;189        if (y1 != y0) {
00001a  429c              CMP      r4,r3
00001c  d001              BEQ      |L8.34|
;;;190          return y1;
00001e  4620              MOV      r0,r4
                  |L8.32|
;;;191        }
;;;192      }
;;;193      return y0;
;;;194    }
000020  bd70              POP      {r4-r6,pc}
                  |L8.34|
000022  1c76              ADDS     r6,r6,#1              ;186
                  |L8.36|
000024  1e50              SUBS     r0,r2,#1              ;186
000026  42b0              CMP      r0,r6                 ;186
000028  dcee              BGT      |L8.8|
00002a  4618              MOV      r0,r3                 ;193
00002c  e7f8              B        |L8.32|
;;;195    
                          ENDP


                          AREA ||i._Init||, CODE, READONLY, ALIGN=2

                  _Init PROC
;;;136    */
;;;137    static void _Init(void) {
000000  2000              MOVS     r0,#0
;;;138      GL_FP_Cnt = 0;
000002  4901              LDR      r1,|L9.8|
000004  6008              STR      r0,[r1,#0]  ; GL_FP_Cnt
;;;139    }
000006  4770              BX       lr
;;;140    
                          ENDP

                  |L9.8|
                          DCD      GL_FP_Cnt

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  _aX
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  GL_FP_Cnt
                          DCD      0x00000000
