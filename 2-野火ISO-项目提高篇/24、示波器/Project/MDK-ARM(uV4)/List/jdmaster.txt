; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\jdmaster.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\jdmaster.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\uCOS-II\Source -I..\..\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\..\User\app -I..\..\User\bsp -I..\..\uCGUI\inc -I..\..\uCGUI\Config -I..\..\uCGUI\LCDDriver -I..\..\uCGUI\uCGUIDemo -I..\..\User\fatfs -I..\..\User\mp3\pub -I..\..\User\Memory -Id:\Keil\ARM\RV31\INC -Id:\Keil\ARM\CMSIS\Include -Id:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\jdmaster.crf ..\..\uCGUI\JPEG\jdmaster.c]
                          THUMB

                          AREA ||i.finish_output_pass||, CODE, READONLY, ALIGN=1

                  finish_output_pass PROC
;;;497    METHODDEF(void)
;;;498    finish_output_pass (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;499    {
000002  4604              MOV      r4,r0
;;;500      my_master_ptr master = (my_master_ptr) cinfo->master;
000004  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;501    
;;;502      if (cinfo->quantize_colors)
000008  6d60              LDR      r0,[r4,#0x54]
00000a  b120              CBZ      r0,|L1.22|
;;;503        (*cinfo->cquantize->finish_pass) (cinfo);
00000c  f8d401cc          LDR      r0,[r4,#0x1cc]
000010  6881              LDR      r1,[r0,#8]
000012  4620              MOV      r0,r4
000014  4788              BLX      r1
                  |L1.22|
;;;504      master->pass_number++;
000016  68e8              LDR      r0,[r5,#0xc]
000018  1c40              ADDS     r0,r0,#1
00001a  60e8              STR      r0,[r5,#0xc]
;;;505    }
00001c  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP


                          AREA ||i.jinit_master_decompress||, CODE, READONLY, ALIGN=2

                  jinit_master_decompress PROC
;;;542    GLOBAL(void)
;;;543    jinit_master_decompress (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;544    {
000002  4605              MOV      r5,r0
;;;545      my_master_ptr master;
;;;546    
;;;547      master = (my_master_ptr)
000004  6868              LDR      r0,[r5,#4]
000006  221c              MOVS     r2,#0x1c
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4628              MOV      r0,r5
00000e  4798              BLX      r3
000010  4604              MOV      r4,r0
;;;548          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;549    				  SIZEOF(my_decomp_master));
;;;550      cinfo->master = (struct jpeg_decomp_master *) master;
000012  f8c541a4          STR      r4,[r5,#0x1a4]
;;;551      master->pub.prepare_for_output_pass = prepare_for_output_pass;
000016  4805              LDR      r0,|L2.44|
000018  6020              STR      r0,[r4,#0]
;;;552      master->pub.finish_output_pass = finish_output_pass;
00001a  4805              LDR      r0,|L2.48|
00001c  6060              STR      r0,[r4,#4]
;;;553    
;;;554      master->pub.is_dummy_pass = FALSE;
00001e  2000              MOVS     r0,#0
000020  60a0              STR      r0,[r4,#8]
;;;555    
;;;556      master_selection(cinfo);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       master_selection
;;;557    }
000028  bd70              POP      {r4-r6,pc}
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      prepare_for_output_pass
                  |L2.48|
                          DCD      finish_output_pass

                          AREA ||i.jpeg_calc_output_dimensions||, CODE, READONLY, ALIGN=1

                  jpeg_calc_output_dimensions PROC
;;;83     GLOBAL(void)
;;;84     jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;85     /* Do computations that are needed before master selection phase */
;;;86     {
000002  4604              MOV      r4,r0
;;;87     #ifdef IDCT_SCALING_SUPPORTED
;;;88       int ci;
;;;89       jpeg_component_info *compptr;
;;;90     #endif
;;;91     
;;;92       /* Prevent application from calling me at wrong times */
;;;93       if (cinfo->global_state != DSTATE_READY)
000004  6960              LDR      r0,[r4,#0x14]
000006  28ca              CMP      r0,#0xca
000008  d009              BEQ      |L3.30|
;;;94         ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
00000a  2014              MOVS     r0,#0x14
00000c  6821              LDR      r1,[r4,#0]
00000e  6148              STR      r0,[r1,#0x14]
000010  6821              LDR      r1,[r4,#0]
000012  6960              LDR      r0,[r4,#0x14]
000014  6188              STR      r0,[r1,#0x18]
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  4620              MOV      r0,r4
00001c  4788              BLX      r1
                  |L3.30|
;;;95     
;;;96     #ifdef IDCT_SCALING_SUPPORTED
;;;97     
;;;98       /* Compute actual output image dimensions and DCT scaling choices. */
;;;99       if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
;;;100        /* Provide 1/8 scaling */
;;;101        cinfo->output_width = (JDIMENSION)
;;;102          jdiv_round_up((long) cinfo->image_width, 8L);
;;;103        cinfo->output_height = (JDIMENSION)
;;;104          jdiv_round_up((long) cinfo->image_height, 8L);
;;;105        cinfo->min_DCT_scaled_size = 1;
;;;106      } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
;;;107        /* Provide 1/4 scaling */
;;;108        cinfo->output_width = (JDIMENSION)
;;;109          jdiv_round_up((long) cinfo->image_width, 4L);
;;;110        cinfo->output_height = (JDIMENSION)
;;;111          jdiv_round_up((long) cinfo->image_height, 4L);
;;;112        cinfo->min_DCT_scaled_size = 2;
;;;113      } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
;;;114        /* Provide 1/2 scaling */
;;;115        cinfo->output_width = (JDIMENSION)
;;;116          jdiv_round_up((long) cinfo->image_width, 2L);
;;;117        cinfo->output_height = (JDIMENSION)
;;;118          jdiv_round_up((long) cinfo->image_height, 2L);
;;;119        cinfo->min_DCT_scaled_size = 4;
;;;120      } else {
;;;121        /* Provide 1/1 scaling */
;;;122        cinfo->output_width = cinfo->image_width;
;;;123        cinfo->output_height = cinfo->image_height;
;;;124        cinfo->min_DCT_scaled_size = DCTSIZE;
;;;125      }
;;;126      /* In selecting the actual DCT scaling for each component, we try to
;;;127       * scale up the chroma components via IDCT scaling rather than upsampling.
;;;128       * This saves time if the upsampler gets to use 1:1 scaling.
;;;129       * Note this code assumes that the supported DCT scalings are powers of 2.
;;;130       */
;;;131      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;132           ci++, compptr++) {
;;;133        int ssize = cinfo->min_DCT_scaled_size;
;;;134        while (ssize < DCTSIZE &&
;;;135    	   (compptr->h_samp_factor * ssize * 2 <=
;;;136    	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
;;;137    	   (compptr->v_samp_factor * ssize * 2 <=
;;;138    	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
;;;139          ssize = ssize * 2;
;;;140        }
;;;141        compptr->DCT_scaled_size = ssize;
;;;142      }
;;;143    
;;;144      /* Recompute downsampled dimensions of components;
;;;145       * application needs to know these if using raw downsampled data.
;;;146       */
;;;147      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;148           ci++, compptr++) {
;;;149        /* Size in samples, after IDCT scaling */
;;;150        compptr->downsampled_width = (JDIMENSION)
;;;151          jdiv_round_up((long) cinfo->image_width *
;;;152    		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
;;;153    		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;154        compptr->downsampled_height = (JDIMENSION)
;;;155          jdiv_round_up((long) cinfo->image_height *
;;;156    		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
;;;157    		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;158      }
;;;159    
;;;160    #else /* !IDCT_SCALING_SUPPORTED */
;;;161    
;;;162      /* Hardwire it to "no scaling" */
;;;163      cinfo->output_width = cinfo->image_width;
00001e  69e0              LDR      r0,[r4,#0x1c]
000020  6720              STR      r0,[r4,#0x70]
;;;164      cinfo->output_height = cinfo->image_height;
000022  6a20              LDR      r0,[r4,#0x20]
000024  6760              STR      r0,[r4,#0x74]
;;;165      /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
;;;166       * and has computed unscaled downsampled_width and downsampled_height.
;;;167       */
;;;168    
;;;169    #endif /* IDCT_SCALING_SUPPORTED */
;;;170    
;;;171      /* Report number of components in selected colorspace. */
;;;172      /* Probably this should be in the color conversion module... */
;;;173      switch (cinfo->out_color_space) {
000026  f8940029          LDRB     r0,[r4,#0x29]
00002a  2806              CMP      r0,#6
00002c  d20f              BCS      |L3.78|
00002e  e8dff000          TBB      [pc,r0]
000032  0e03              DCB      0x0e,0x03
000034  06070a0b          DCB      0x06,0x07,0x0a,0x0b
;;;174      case JCS_GRAYSCALE:
;;;175        cinfo->out_color_components = 1;
000038  2001              MOVS     r0,#1
00003a  67a0              STR      r0,[r4,#0x78]
;;;176        break;
00003c  e00a              B        |L3.84|
;;;177      case JCS_RGB:
;;;178    #if RGB_PIXELSIZE != 3
;;;179        cinfo->out_color_components = RGB_PIXELSIZE;
;;;180        break;
;;;181    #endif /* else share code with YCbCr */
;;;182      case JCS_YCbCr:
00003e  bf00              NOP      
;;;183        cinfo->out_color_components = 3;
000040  2003              MOVS     r0,#3
000042  67a0              STR      r0,[r4,#0x78]
;;;184        break;
000044  e006              B        |L3.84|
;;;185      case JCS_CMYK:
;;;186      case JCS_YCCK:
000046  bf00              NOP      
;;;187        cinfo->out_color_components = 4;
000048  2004              MOVS     r0,#4
00004a  67a0              STR      r0,[r4,#0x78]
;;;188        break;
00004c  e002              B        |L3.84|
                  |L3.78|
;;;189      default:			/* else must be same colorspace as in file */
;;;190        cinfo->out_color_components = cinfo->num_components;
00004e  6a60              LDR      r0,[r4,#0x24]
000050  67a0              STR      r0,[r4,#0x78]
;;;191        break;
000052  bf00              NOP      
                  |L3.84|
000054  bf00              NOP                            ;176
;;;192      }
;;;193      cinfo->output_components = (cinfo->quantize_colors ? 1 :
000056  6d60              LDR      r0,[r4,#0x54]
000058  b108              CBZ      r0,|L3.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L3.96|
                  |L3.94|
;;;194    			      cinfo->out_color_components);
00005e  6fa0              LDR      r0,[r4,#0x78]
                  |L3.96|
000060  67e0              STR      r0,[r4,#0x7c]
;;;195    
;;;196      /* See if upsampler will want to emit more than one row at a time */
;;;197      if (use_merged_upsample(cinfo))
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       use_merged_upsample
000068  b120              CBZ      r0,|L3.116|
;;;198        cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
00006a  f8d40138          LDR      r0,[r4,#0x138]
00006e  f8c40080          STR      r0,[r4,#0x80]
000072  e002              B        |L3.122|
                  |L3.116|
;;;199      else
;;;200        cinfo->rec_outbuf_height = 1;
000074  2001              MOVS     r0,#1
000076  f8c40080          STR      r0,[r4,#0x80]
                  |L3.122|
;;;201    }
00007a  bd10              POP      {r4,pc}
;;;202    
                          ENDP


                          AREA ||i.jpeg_new_colormap||, CODE, READONLY, ALIGN=1

                  jpeg_new_colormap PROC
;;;514    GLOBAL(void)
;;;515    jpeg_new_colormap (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;516    {
000002  4604              MOV      r4,r0
;;;517      my_master_ptr master = (my_master_ptr) cinfo->master;
000004  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;518    
;;;519      /* Prevent application from calling me at wrong times */
;;;520      if (cinfo->global_state != DSTATE_BUFIMAGE)
000008  6960              LDR      r0,[r4,#0x14]
00000a  28cf              CMP      r0,#0xcf
00000c  d009              BEQ      |L4.34|
;;;521        ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
00000e  2014              MOVS     r0,#0x14
000010  6821              LDR      r1,[r4,#0]
000012  6148              STR      r0,[r1,#0x14]
000014  6821              LDR      r1,[r4,#0]
000016  6960              LDR      r0,[r4,#0x14]
000018  6188              STR      r0,[r1,#0x18]
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  4620              MOV      r0,r4
000020  4788              BLX      r1
                  |L4.34|
;;;522    
;;;523      if (cinfo->quantize_colors && cinfo->enable_external_quant &&
000022  6d60              LDR      r0,[r4,#0x54]
000024  b178              CBZ      r0,|L4.70|
000026  6ea0              LDR      r0,[r4,#0x68]
000028  b168              CBZ      r0,|L4.70|
;;;524          cinfo->colormap != NULL) {
00002a  f8d40088          LDR      r0,[r4,#0x88]
00002e  b150              CBZ      r0,|L4.70|
;;;525        /* Select 2-pass quantizer for external colormap use */
;;;526        cinfo->cquantize = master->quantizer_2pass;
000030  69a8              LDR      r0,[r5,#0x18]
000032  f8c401cc          STR      r0,[r4,#0x1cc]
;;;527        /* Notify quantizer of colormap change */
;;;528        (*cinfo->cquantize->new_color_map) (cinfo);
000036  f8d401cc          LDR      r0,[r4,#0x1cc]
00003a  68c1              LDR      r1,[r0,#0xc]
00003c  4620              MOV      r0,r4
00003e  4788              BLX      r1
;;;529        master->pub.is_dummy_pass = FALSE; /* just in case */
000040  2000              MOVS     r0,#0
000042  60a8              STR      r0,[r5,#8]
000044  e006              B        |L4.84|
                  |L4.70|
;;;530      } else
;;;531        ERREXIT(cinfo, JERR_MODE_CHANGE);
000046  202e              MOVS     r0,#0x2e
000048  6821              LDR      r1,[r4,#0]
00004a  6148              STR      r0,[r1,#0x14]
00004c  6820              LDR      r0,[r4,#0]
00004e  6801              LDR      r1,[r0,#0]
000050  4620              MOV      r0,r4
000052  4788              BLX      r1
                  |L4.84|
;;;532    }
000054  bd70              POP      {r4-r6,pc}
;;;533    
                          ENDP


                          AREA ||i.master_selection||, CODE, READONLY, ALIGN=1

                  master_selection PROC
;;;287    LOCAL(void)
;;;288    master_selection (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
000004  4604              MOV      r4,r0
;;;290      my_master_ptr master = (my_master_ptr) cinfo->master;
000006  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;291      boolean use_c_buffer;
;;;292      long samplesperrow;
;;;293      JDIMENSION jd_samplesperrow;
;;;294    
;;;295      /* Initialize dimensions and other stuff */
;;;296      jpeg_calc_output_dimensions(cinfo);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       jpeg_calc_output_dimensions
;;;297      prepare_range_limit_table(cinfo);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       prepare_range_limit_table
;;;298    
;;;299      /* Width of an output scanline must be representable as JDIMENSION. */
;;;300      samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
000016  6fa1              LDR      r1,[r4,#0x78]
000018  6f20              LDR      r0,[r4,#0x70]
00001a  fb00f601          MUL      r6,r0,r1
;;;301      jd_samplesperrow = (JDIMENSION) samplesperrow;
00001e  4637              MOV      r7,r6
;;;302      if ((long) jd_samplesperrow != samplesperrow)
000020  42b7              CMP      r7,r6
000022  d006              BEQ      |L5.50|
;;;303        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
000024  2046              MOVS     r0,#0x46
000026  6821              LDR      r1,[r4,#0]
000028  6148              STR      r0,[r1,#0x14]
00002a  6820              LDR      r0,[r4,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  4620              MOV      r0,r4
000030  4788              BLX      r1
                  |L5.50|
;;;304    
;;;305      /* Initialize my private state */
;;;306      master->pass_number = 0;
000032  2000              MOVS     r0,#0
000034  60e8              STR      r0,[r5,#0xc]
;;;307      master->using_merged_upsample = use_merged_upsample(cinfo);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       use_merged_upsample
00003c  6128              STR      r0,[r5,#0x10]
;;;308    
;;;309      /* Color quantizer selection */
;;;310      master->quantizer_1pass = NULL;
00003e  2000              MOVS     r0,#0
000040  6168              STR      r0,[r5,#0x14]
;;;311      master->quantizer_2pass = NULL;
000042  61a8              STR      r0,[r5,#0x18]
;;;312      /* No mode changes if not using buffered-image mode. */
;;;313      if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
000044  6d60              LDR      r0,[r4,#0x54]
000046  b108              CBZ      r0,|L5.76|
000048  6c20              LDR      r0,[r4,#0x40]
00004a  b918              CBNZ     r0,|L5.84|
                  |L5.76|
;;;314        cinfo->enable_1pass_quant = FALSE;
00004c  2000              MOVS     r0,#0
00004e  6660              STR      r0,[r4,#0x64]
;;;315        cinfo->enable_external_quant = FALSE;
000050  66a0              STR      r0,[r4,#0x68]
;;;316        cinfo->enable_2pass_quant = FALSE;
000052  66e0              STR      r0,[r4,#0x6c]
                  |L5.84|
;;;317      }
;;;318      if (cinfo->quantize_colors) {
000054  6d60              LDR      r0,[r4,#0x54]
000056  2800              CMP      r0,#0
000058  d032              BEQ      |L5.192|
;;;319        if (cinfo->raw_data_out)
00005a  6c60              LDR      r0,[r4,#0x44]
00005c  b130              CBZ      r0,|L5.108|
;;;320          ERREXIT(cinfo, JERR_NOTIMPL);
00005e  202f              MOVS     r0,#0x2f
000060  6821              LDR      r1,[r4,#0]
000062  6148              STR      r0,[r1,#0x14]
000064  6820              LDR      r0,[r4,#0]
000066  6801              LDR      r1,[r0,#0]
000068  4620              MOV      r0,r4
00006a  4788              BLX      r1
                  |L5.108|
;;;321        /* 2-pass quantizer only works in 3-component color space. */
;;;322        if (cinfo->out_color_components != 3) {
00006c  6fa0              LDR      r0,[r4,#0x78]
00006e  2803              CMP      r0,#3
000070  d007              BEQ      |L5.130|
;;;323          cinfo->enable_1pass_quant = TRUE;
000072  2001              MOVS     r0,#1
000074  6660              STR      r0,[r4,#0x64]
;;;324          cinfo->enable_external_quant = FALSE;
000076  2000              MOVS     r0,#0
000078  66a0              STR      r0,[r4,#0x68]
;;;325          cinfo->enable_2pass_quant = FALSE;
00007a  66e0              STR      r0,[r4,#0x6c]
;;;326          cinfo->colormap = NULL;
00007c  f8c40088          STR      r0,[r4,#0x88]
000080  e00c              B        |L5.156|
                  |L5.130|
;;;327        } else if (cinfo->colormap != NULL) {
000082  f8d40088          LDR      r0,[r4,#0x88]
000086  b110              CBZ      r0,|L5.142|
;;;328          cinfo->enable_external_quant = TRUE;
000088  2001              MOVS     r0,#1
00008a  66a0              STR      r0,[r4,#0x68]
00008c  e006              B        |L5.156|
                  |L5.142|
;;;329        } else if (cinfo->two_pass_quantize) {
00008e  6de0              LDR      r0,[r4,#0x5c]
000090  b110              CBZ      r0,|L5.152|
;;;330          cinfo->enable_2pass_quant = TRUE;
000092  2001              MOVS     r0,#1
000094  66e0              STR      r0,[r4,#0x6c]
000096  e001              B        |L5.156|
                  |L5.152|
;;;331        } else {
;;;332          cinfo->enable_1pass_quant = TRUE;
000098  2001              MOVS     r0,#1
00009a  6660              STR      r0,[r4,#0x64]
                  |L5.156|
;;;333        }
;;;334    
;;;335        if (cinfo->enable_1pass_quant) {
00009c  6e60              LDR      r0,[r4,#0x64]
00009e  b128              CBZ      r0,|L5.172|
;;;336    #ifdef QUANT_1PASS_SUPPORTED
;;;337          jinit_1pass_quantizer(cinfo);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       jinit_1pass_quantizer
;;;338          master->quantizer_1pass = cinfo->cquantize;
0000a6  f8d401cc          LDR      r0,[r4,#0x1cc]
0000aa  6168              STR      r0,[r5,#0x14]
                  |L5.172|
;;;339    #else
;;;340          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;341    #endif
;;;342        }
;;;343    
;;;344        /* We use the 2-pass code to map to external colormaps. */
;;;345        if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
0000ac  6ee0              LDR      r0,[r4,#0x6c]
0000ae  b908              CBNZ     r0,|L5.180|
0000b0  6ea0              LDR      r0,[r4,#0x68]
0000b2  b128              CBZ      r0,|L5.192|
                  |L5.180|
;;;346    #ifdef QUANT_2PASS_SUPPORTED
;;;347          jinit_2pass_quantizer(cinfo);
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       jinit_2pass_quantizer
;;;348          master->quantizer_2pass = cinfo->cquantize;
0000ba  f8d401cc          LDR      r0,[r4,#0x1cc]
0000be  61a8              STR      r0,[r5,#0x18]
                  |L5.192|
;;;349    #else
;;;350          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;351    #endif
;;;352        }
;;;353        /* If both quantizers are initialized, the 2-pass one is left active;
;;;354         * this is necessary for starting with quantization to an external map.
;;;355         */
;;;356      }
;;;357    
;;;358      /* Post-processing: in particular, color conversion first */
;;;359      if (! cinfo->raw_data_out) {
0000c0  6c60              LDR      r0,[r4,#0x44]
0000c2  b978              CBNZ     r0,|L5.228|
;;;360        if (master->using_merged_upsample) {
0000c4  6928              LDR      r0,[r5,#0x10]
0000c6  b118              CBZ      r0,|L5.208|
;;;361    #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;362          jinit_merged_upsampler(cinfo); /* does color conversion too */
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       jinit_merged_upsampler
0000ce  e005              B        |L5.220|
                  |L5.208|
;;;363    #else
;;;364          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;365    #endif
;;;366        } else {
;;;367          jinit_color_deconverter(cinfo);
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       jinit_color_deconverter
;;;368          jinit_upsampler(cinfo);
0000d6  4620              MOV      r0,r4
0000d8  f7fffffe          BL       jinit_upsampler
                  |L5.220|
;;;369        }
;;;370        jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
0000dc  4620              MOV      r0,r4
0000de  6ee1              LDR      r1,[r4,#0x6c]
0000e0  f7fffffe          BL       jinit_d_post_controller
                  |L5.228|
;;;371      }
;;;372      /* Inverse DCT */
;;;373      jinit_inverse_dct(cinfo);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       jinit_inverse_dct
;;;374      /* Entropy decoding: either Huffman or arithmetic coding. */
;;;375      if (cinfo->arith_code) {
0000ea  f8d400e0          LDR      r0,[r4,#0xe0]
0000ee  b138              CBZ      r0,|L5.256|
;;;376        ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
0000f0  2001              MOVS     r0,#1
0000f2  6821              LDR      r1,[r4,#0]
0000f4  6148              STR      r0,[r1,#0x14]
0000f6  6820              LDR      r0,[r4,#0]
0000f8  6801              LDR      r1,[r0,#0]
0000fa  4620              MOV      r0,r4
0000fc  4788              BLX      r1
0000fe  e009              B        |L5.276|
                  |L5.256|
;;;377      } else {
;;;378        if (cinfo->progressive_mode) {
000100  f8d400dc          LDR      r0,[r4,#0xdc]
000104  b118              CBZ      r0,|L5.270|
;;;379    #ifdef D_PROGRESSIVE_SUPPORTED
;;;380          jinit_phuff_decoder(cinfo);
000106  4620              MOV      r0,r4
000108  f7fffffe          BL       jinit_phuff_decoder
00010c  e002              B        |L5.276|
                  |L5.270|
;;;381    #else
;;;382          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;383    #endif
;;;384        } else
;;;385          jinit_huff_decoder(cinfo);
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       jinit_huff_decoder
                  |L5.276|
;;;386      }
;;;387    
;;;388      /* Initialize principal buffer controllers. */
;;;389      use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
000114  f8d401b4          LDR      r0,[r4,#0x1b4]
000118  6900              LDR      r0,[r0,#0x10]
00011a  b908              CBNZ     r0,|L5.288|
00011c  6c20              LDR      r0,[r4,#0x40]
00011e  b108              CBZ      r0,|L5.292|
                  |L5.288|
000120  2001              MOVS     r0,#1
000122  e000              B        |L5.294|
                  |L5.292|
000124  2000              MOVS     r0,#0
                  |L5.294|
000126  4680              MOV      r8,r0
;;;390      jinit_d_coef_controller(cinfo, use_c_buffer);
000128  4641              MOV      r1,r8
00012a  4620              MOV      r0,r4
00012c  f7fffffe          BL       jinit_d_coef_controller
;;;391    
;;;392      if (! cinfo->raw_data_out)
000130  6c60              LDR      r0,[r4,#0x44]
000132  b918              CBNZ     r0,|L5.316|
;;;393        jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
000134  2100              MOVS     r1,#0
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       jinit_d_main_controller
                  |L5.316|
;;;394    
;;;395      /* We can now tell the memory manager to allocate virtual arrays. */
;;;396      (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
00013c  6860              LDR      r0,[r4,#4]
00013e  6981              LDR      r1,[r0,#0x18]
000140  4620              MOV      r0,r4
000142  4788              BLX      r1
;;;397    
;;;398      /* Initialize input side of decompressor to consume first scan. */
;;;399      (*cinfo->inputctl->start_input_pass) (cinfo);
000144  f8d401b4          LDR      r0,[r4,#0x1b4]
000148  6881              LDR      r1,[r0,#8]
00014a  4620              MOV      r0,r4
00014c  4788              BLX      r1
;;;400    
;;;401    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;402      /* If jpeg_start_decompress will read the whole file, initialize
;;;403       * progress monitoring appropriately.  The input step is counted
;;;404       * as one pass.
;;;405       */
;;;406      if (cinfo->progress != NULL && ! cinfo->buffered_image &&
00014e  68a0              LDR      r0,[r4,#8]
000150  b320              CBZ      r0,|L5.412|
000152  6c20              LDR      r0,[r4,#0x40]
000154  bb10              CBNZ     r0,|L5.412|
;;;407          cinfo->inputctl->has_multiple_scans) {
000156  f8d401b4          LDR      r0,[r4,#0x1b4]
00015a  6900              LDR      r0,[r0,#0x10]
00015c  b1f0              CBZ      r0,|L5.412|
;;;408        int nscans;
;;;409        /* Estimate number of scans to set pass_limit. */
;;;410        if (cinfo->progressive_mode) {
00015e  f8d410dc          LDR      r1,[r4,#0xdc]
000162  b121              CBZ      r1,|L5.366|
;;;411          /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
;;;412          nscans = 2 + 3 * cinfo->num_components;
000164  6a61              LDR      r1,[r4,#0x24]
000166  eb010141          ADD      r1,r1,r1,LSL #1
00016a  1c88              ADDS     r0,r1,#2
00016c  e000              B        |L5.368|
                  |L5.366|
;;;413        } else {
;;;414          /* For a nonprogressive multiscan file, estimate 1 scan per component. */
;;;415          nscans = cinfo->num_components;
00016e  6a60              LDR      r0,[r4,#0x24]
                  |L5.368|
;;;416        }
;;;417        cinfo->progress->pass_counter = 0L;
000170  2100              MOVS     r1,#0
000172  68a2              LDR      r2,[r4,#8]
000174  6051              STR      r1,[r2,#4]
;;;418        cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
000176  f8d41140          LDR      r1,[r4,#0x140]
00017a  4341              MULS     r1,r0,r1
00017c  68a2              LDR      r2,[r4,#8]
00017e  6091              STR      r1,[r2,#8]
;;;419        cinfo->progress->completed_passes = 0;
000180  2100              MOVS     r1,#0
000182  68a2              LDR      r2,[r4,#8]
000184  60d1              STR      r1,[r2,#0xc]
;;;420        cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
000186  6ee1              LDR      r1,[r4,#0x6c]
000188  b109              CBZ      r1,|L5.398|
00018a  2103              MOVS     r1,#3
00018c  e000              B        |L5.400|
                  |L5.398|
00018e  2102              MOVS     r1,#2
                  |L5.400|
000190  68a2              LDR      r2,[r4,#8]
000192  6111              STR      r1,[r2,#0x10]
;;;421        /* Count the input pass as done */
;;;422        master->pass_number++;
000194  68e9              LDR      r1,[r5,#0xc]
000196  1c49              ADDS     r1,r1,#1
000198  60e9              STR      r1,[r5,#0xc]
;;;423      }
00019a  bf00              NOP      
                  |L5.412|
;;;424    #endif /* D_MULTISCAN_FILES_SUPPORTED */
;;;425    }
00019c  e8bd81f0          POP      {r4-r8,pc}
;;;426    
                          ENDP


                          AREA ||i.prepare_for_output_pass||, CODE, READONLY, ALIGN=1

                  prepare_for_output_pass PROC
;;;437    METHODDEF(void)
;;;438    prepare_for_output_pass (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;439    {
000002  4604              MOV      r4,r0
;;;440      my_master_ptr master = (my_master_ptr) cinfo->master;
000004  f8d451a4          LDR      r5,[r4,#0x1a4]
;;;441    
;;;442      if (master->pub.is_dummy_pass) {
000008  68a8              LDR      r0,[r5,#8]
00000a  b1a0              CBZ      r0,|L6.54|
;;;443    #ifdef QUANT_2PASS_SUPPORTED
;;;444        /* Final pass of 2-pass quantization */
;;;445        master->pub.is_dummy_pass = FALSE;
00000c  2000              MOVS     r0,#0
00000e  60a8              STR      r0,[r5,#8]
;;;446        (*cinfo->cquantize->start_pass) (cinfo, FALSE);
000010  f8d401cc          LDR      r0,[r4,#0x1cc]
000014  2100              MOVS     r1,#0
000016  6802              LDR      r2,[r0,#0]
000018  4620              MOV      r0,r4
00001a  4790              BLX      r2
;;;447        (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
00001c  f8d401b0          LDR      r0,[r4,#0x1b0]
000020  2102              MOVS     r1,#2
000022  6802              LDR      r2,[r0,#0]
000024  4620              MOV      r0,r4
000026  4790              BLX      r2
;;;448        (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
000028  f8d401a8          LDR      r0,[r4,#0x1a8]
00002c  2102              MOVS     r1,#2
00002e  6802              LDR      r2,[r0,#0]
000030  4620              MOV      r0,r4
000032  4790              BLX      r2
000034  e04c              B        |L6.208|
                  |L6.54|
;;;449    #else
;;;450        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;451    #endif /* QUANT_2PASS_SUPPORTED */
;;;452      } else {
;;;453        if (cinfo->quantize_colors && cinfo->colormap == NULL) {
000036  6d60              LDR      r0,[r4,#0x54]
000038  b1c8              CBZ      r0,|L6.110|
00003a  f8d40088          LDR      r0,[r4,#0x88]
00003e  b9b0              CBNZ     r0,|L6.110|
;;;454          /* Select new quantization method */
;;;455          if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
000040  6de0              LDR      r0,[r4,#0x5c]
000042  b138              CBZ      r0,|L6.84|
000044  6ee0              LDR      r0,[r4,#0x6c]
000046  b128              CBZ      r0,|L6.84|
;;;456    	cinfo->cquantize = master->quantizer_2pass;
000048  69a8              LDR      r0,[r5,#0x18]
00004a  f8c401cc          STR      r0,[r4,#0x1cc]
;;;457    	master->pub.is_dummy_pass = TRUE;
00004e  2001              MOVS     r0,#1
000050  60a8              STR      r0,[r5,#8]
000052  e00c              B        |L6.110|
                  |L6.84|
;;;458          } else if (cinfo->enable_1pass_quant) {
000054  6e60              LDR      r0,[r4,#0x64]
000056  b118              CBZ      r0,|L6.96|
;;;459    	cinfo->cquantize = master->quantizer_1pass;
000058  6968              LDR      r0,[r5,#0x14]
00005a  f8c401cc          STR      r0,[r4,#0x1cc]
00005e  e006              B        |L6.110|
                  |L6.96|
;;;460          } else {
;;;461    	ERREXIT(cinfo, JERR_MODE_CHANGE);
000060  202e              MOVS     r0,#0x2e
000062  6821              LDR      r1,[r4,#0]
000064  6148              STR      r0,[r1,#0x14]
000066  6820              LDR      r0,[r4,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  4620              MOV      r0,r4
00006c  4788              BLX      r1
                  |L6.110|
;;;462          }
;;;463        }
;;;464        (*cinfo->idct->start_pass) (cinfo);
00006e  f8d401c0          LDR      r0,[r4,#0x1c0]
000072  6801              LDR      r1,[r0,#0]
000074  4620              MOV      r0,r4
000076  4788              BLX      r1
;;;465        (*cinfo->coef->start_output_pass) (cinfo);
000078  f8d401ac          LDR      r0,[r4,#0x1ac]
00007c  6881              LDR      r1,[r0,#8]
00007e  4620              MOV      r0,r4
000080  4788              BLX      r1
;;;466        if (! cinfo->raw_data_out) {
000082  6c60              LDR      r0,[r4,#0x44]
000084  bb20              CBNZ     r0,|L6.208|
;;;467          if (! master->using_merged_upsample)
000086  6928              LDR      r0,[r5,#0x10]
000088  b920              CBNZ     r0,|L6.148|
;;;468    	(*cinfo->cconvert->start_pass) (cinfo);
00008a  f8d401c8          LDR      r0,[r4,#0x1c8]
00008e  6801              LDR      r1,[r0,#0]
000090  4620              MOV      r0,r4
000092  4788              BLX      r1
                  |L6.148|
;;;469          (*cinfo->upsample->start_pass) (cinfo);
000094  f8d401c4          LDR      r0,[r4,#0x1c4]
000098  6801              LDR      r1,[r0,#0]
00009a  4620              MOV      r0,r4
00009c  4788              BLX      r1
;;;470          if (cinfo->quantize_colors)
00009e  6d60              LDR      r0,[r4,#0x54]
0000a0  b128              CBZ      r0,|L6.174|
;;;471    	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
0000a2  68a9              LDR      r1,[r5,#8]
0000a4  f8d401cc          LDR      r0,[r4,#0x1cc]
0000a8  6802              LDR      r2,[r0,#0]
0000aa  4620              MOV      r0,r4
0000ac  4790              BLX      r2
                  |L6.174|
;;;472          (*cinfo->post->start_pass) (cinfo,
0000ae  68a8              LDR      r0,[r5,#8]
0000b0  b108              CBZ      r0,|L6.182|
;;;473    	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
0000b2  2003              MOVS     r0,#3
0000b4  e000              B        |L6.184|
                  |L6.182|
0000b6  2000              MOVS     r0,#0
                  |L6.184|
0000b8  4601              MOV      r1,r0
0000ba  f8d401b0          LDR      r0,[r4,#0x1b0]
0000be  6802              LDR      r2,[r0,#0]
0000c0  4620              MOV      r0,r4
0000c2  4790              BLX      r2
;;;474          (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
0000c4  f8d401a8          LDR      r0,[r4,#0x1a8]
0000c8  2100              MOVS     r1,#0
0000ca  6802              LDR      r2,[r0,#0]
0000cc  4620              MOV      r0,r4
0000ce  4790              BLX      r2
                  |L6.208|
;;;475        }
;;;476      }
;;;477    
;;;478      /* Set up progress monitor's pass info if present */
;;;479      if (cinfo->progress != NULL) {
0000d0  68a0              LDR      r0,[r4,#8]
0000d2  b1d8              CBZ      r0,|L6.268|
;;;480        cinfo->progress->completed_passes = master->pass_number;
0000d4  68e8              LDR      r0,[r5,#0xc]
0000d6  68a1              LDR      r1,[r4,#8]
0000d8  60c8              STR      r0,[r1,#0xc]
;;;481        cinfo->progress->total_passes = master->pass_number +
0000da  e9d51002          LDRD     r1,r0,[r5,#8]
0000de  b109              CBZ      r1,|L6.228|
;;;482    				    (master->pub.is_dummy_pass ? 2 : 1);
0000e0  2102              MOVS     r1,#2
0000e2  e000              B        |L6.230|
                  |L6.228|
0000e4  2101              MOVS     r1,#1
                  |L6.230|
0000e6  4408              ADD      r0,r0,r1
0000e8  68a1              LDR      r1,[r4,#8]
0000ea  6108              STR      r0,[r1,#0x10]
;;;483        /* In buffered-image mode, we assume one more output pass if EOI not
;;;484         * yet reached, but no more passes if EOI has been reached.
;;;485         */
;;;486        if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
0000ec  6c20              LDR      r0,[r4,#0x40]
0000ee  b168              CBZ      r0,|L6.268|
0000f0  f8d401b4          LDR      r0,[r4,#0x1b4]
0000f4  6940              LDR      r0,[r0,#0x14]
0000f6  b948              CBNZ     r0,|L6.268|
;;;487          cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
0000f8  68a0              LDR      r0,[r4,#8]
0000fa  6900              LDR      r0,[r0,#0x10]
0000fc  6ee1              LDR      r1,[r4,#0x6c]
0000fe  b109              CBZ      r1,|L6.260|
000100  2102              MOVS     r1,#2
000102  e000              B        |L6.262|
                  |L6.260|
000104  2101              MOVS     r1,#1
                  |L6.262|
000106  4408              ADD      r0,r0,r1
000108  68a1              LDR      r1,[r4,#8]
00010a  6108              STR      r0,[r1,#0x10]
                  |L6.268|
;;;488        }
;;;489      }
;;;490    }
00010c  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP


                          AREA ||i.prepare_range_limit_table||, CODE, READONLY, ALIGN=1

                  prepare_range_limit_table PROC
;;;247    LOCAL(void)
;;;248    prepare_range_limit_table (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;249    /* Allocate and fill in the sample_range_limit table */
;;;250    {
000002  4606              MOV      r6,r0
;;;251      JSAMPLE * table;
;;;252      int i;
;;;253    
;;;254      table = (JSAMPLE *)
000004  6870              LDR      r0,[r6,#4]
000006  f44f62b0          MOV      r2,#0x580
00000a  2101              MOVS     r1,#1
00000c  6803              LDR      r3,[r0,#0]
00000e  4630              MOV      r0,r6
000010  4798              BLX      r3
000012  4604              MOV      r4,r0
;;;255        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;256    		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
;;;257      table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
000014  f5047480          ADD      r4,r4,#0x100
;;;258      cinfo->sample_range_limit = table;
000018  f8c64144          STR      r4,[r6,#0x144]
;;;259      /* First segment of "simple" table: limit[x] = 0 for x < 0 */
;;;260      MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
00001c  f5a47080          SUB      r0,r4,#0x100
000020  f44f7180          MOV      r1,#0x100
000024  f7fffffe          BL       __aeabi_memclr
;;;261      /* Main part of "simple" table: limit[x] = x */
;;;262      for (i = 0; i <= MAXJSAMPLE; i++)
000028  2500              MOVS     r5,#0
00002a  e001              B        |L7.48|
                  |L7.44|
;;;263        table[i] = (JSAMPLE) i;
00002c  5565              STRB     r5,[r4,r5]
00002e  1c6d              ADDS     r5,r5,#1              ;262
                  |L7.48|
000030  2dff              CMP      r5,#0xff              ;262
000032  ddfb              BLE      |L7.44|
;;;264      table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
000034  3480              ADDS     r4,r4,#0x80
;;;265      /* End of simple table, rest of first half of post-IDCT table */
;;;266      for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
000036  2580              MOVS     r5,#0x80
000038  e002              B        |L7.64|
                  |L7.58|
;;;267        table[i] = MAXJSAMPLE;
00003a  20ff              MOVS     r0,#0xff
00003c  5560              STRB     r0,[r4,r5]
00003e  1c6d              ADDS     r5,r5,#1              ;266
                  |L7.64|
000040  f5b57f00          CMP      r5,#0x200             ;266
000044  dbf9              BLT      |L7.58|
;;;268      /* Second half of post-IDCT table */
;;;269      MEMZERO(table + (2 * (MAXJSAMPLE+1)),
000046  f44f71c0          MOV      r1,#0x180
00004a  f5047000          ADD      r0,r4,#0x200
00004e  f7fffffe          BL       __aeabi_memclr
;;;270    	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
;;;271      MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
000052  2280              MOVS     r2,#0x80
000054  f5047060          ADD      r0,r4,#0x380
000058  f8d61144          LDR      r1,[r6,#0x144]
00005c  f7fffffe          BL       __aeabi_memcpy
;;;272    	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
;;;273    }
000060  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP


                          AREA ||i.use_merged_upsample||, CODE, READONLY, ALIGN=1

                  use_merged_upsample PROC
;;;43     LOCAL(boolean)
;;;44     use_merged_upsample (j_decompress_ptr cinfo)
000000  4601              MOV      r1,r0
;;;45     {
;;;46     #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;47       /* Merging is the equivalent of plain box-filter upsampling */
;;;48       if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
000002  6cc8              LDR      r0,[r1,#0x4c]
000004  b910              CBNZ     r0,|L8.12|
000006  f8d1012c          LDR      r0,[r1,#0x12c]
00000a  b108              CBZ      r0,|L8.16|
                  |L8.12|
;;;49         return FALSE;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;50       /* jdmerge.c only supports YCC=>RGB color conversion */
;;;51       if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
;;;52           cinfo->out_color_space != JCS_RGB ||
;;;53           cinfo->out_color_components != RGB_PIXELSIZE)
;;;54         return FALSE;
;;;55       /* and it only handles 2h1v or 2h2v sampling ratios */
;;;56       if (cinfo->comp_info[0].h_samp_factor != 2 ||
;;;57           cinfo->comp_info[1].h_samp_factor != 1 ||
;;;58           cinfo->comp_info[2].h_samp_factor != 1 ||
;;;59           cinfo->comp_info[0].v_samp_factor >  2 ||
;;;60           cinfo->comp_info[1].v_samp_factor != 1 ||
;;;61           cinfo->comp_info[2].v_samp_factor != 1)
;;;62         return FALSE;
;;;63       /* furthermore, it doesn't work if we've scaled the IDCTs differently */
;;;64       if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
;;;65           cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
;;;66           cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
;;;67         return FALSE;
;;;68       /* ??? also need to test for upsample-time rescaling, when & if supported */
;;;69       return TRUE;			/* by golly, it'll work... */
;;;70     #else
;;;71       return FALSE;
;;;72     #endif
;;;73     }
00000e  4770              BX       lr
                  |L8.16|
000010  f8910028          LDRB     r0,[r1,#0x28]         ;51
000014  2803              CMP      r0,#3                 ;51
000016  d109              BNE      |L8.44|
000018  6a48              LDR      r0,[r1,#0x24]         ;51
00001a  2803              CMP      r0,#3                 ;51
00001c  d106              BNE      |L8.44|
00001e  f8910029          LDRB     r0,[r1,#0x29]         ;52
000022  2802              CMP      r0,#2                 ;52
000024  d102              BNE      |L8.44|
000026  6f88              LDR      r0,[r1,#0x78]         ;53
000028  2803              CMP      r0,#3                 ;53
00002a  d001              BEQ      |L8.48|
                  |L8.44|
00002c  2000              MOVS     r0,#0                 ;54
00002e  e7ee              B        |L8.14|
                  |L8.48|
000030  f8d100d8          LDR      r0,[r1,#0xd8]         ;56
000034  6880              LDR      r0,[r0,#8]            ;56
000036  2802              CMP      r0,#2                 ;56
000038  d11a              BNE      |L8.112|
00003a  f8d100d8          LDR      r0,[r1,#0xd8]         ;57
00003e  6dc0              LDR      r0,[r0,#0x5c]         ;57
000040  2801              CMP      r0,#1                 ;57
000042  d115              BNE      |L8.112|
000044  f8d100d8          LDR      r0,[r1,#0xd8]         ;58
000048  f8d000b0          LDR      r0,[r0,#0xb0]         ;58
00004c  2801              CMP      r0,#1                 ;58
00004e  d10f              BNE      |L8.112|
000050  f8d100d8          LDR      r0,[r1,#0xd8]         ;59
000054  68c0              LDR      r0,[r0,#0xc]          ;59
000056  2802              CMP      r0,#2                 ;59
000058  dc0a              BGT      |L8.112|
00005a  f8d100d8          LDR      r0,[r1,#0xd8]         ;60
00005e  6e00              LDR      r0,[r0,#0x60]         ;60
000060  2801              CMP      r0,#1                 ;60
000062  d105              BNE      |L8.112|
000064  f8d100d8          LDR      r0,[r1,#0xd8]         ;61
000068  f8d000b4          LDR      r0,[r0,#0xb4]         ;61
00006c  2801              CMP      r0,#1                 ;61
00006e  d001              BEQ      |L8.116|
                  |L8.112|
000070  2000              MOVS     r0,#0                 ;62
000072  e7cc              B        |L8.14|
                  |L8.116|
000074  f8d100d8          LDR      r0,[r1,#0xd8]         ;64
000078  6a40              LDR      r0,[r0,#0x24]         ;64
00007a  f8d1213c          LDR      r2,[r1,#0x13c]        ;64
00007e  4290              CMP      r0,r2                 ;64
000080  d10e              BNE      |L8.160|
000082  f8d100d8          LDR      r0,[r1,#0xd8]         ;65
000086  6f80              LDR      r0,[r0,#0x78]         ;65
000088  f8d1213c          LDR      r2,[r1,#0x13c]        ;65
00008c  4290              CMP      r0,r2                 ;65
00008e  d107              BNE      |L8.160|
000090  f8d100d8          LDR      r0,[r1,#0xd8]         ;66
000094  f8d000cc          LDR      r0,[r0,#0xcc]         ;66
000098  f8d1213c          LDR      r2,[r1,#0x13c]        ;66
00009c  4290              CMP      r0,r2                 ;66
00009e  d001              BEQ      |L8.164|
                  |L8.160|
0000a0  2000              MOVS     r0,#0                 ;67
0000a2  e7b4              B        |L8.14|
                  |L8.164|
0000a4  2001              MOVS     r0,#1                 ;69
0000a6  e7b2              B        |L8.14|
;;;74     
                          ENDP

